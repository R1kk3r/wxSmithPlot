Index: acinclude.m4
===================================================================
diff --git a/trunk/acinclude.m4 b/trunk/acinclude.m4
--- a/trunk/acinclude.m4	(révision 10042)
+++ b/trunk/acinclude.m4	(copie de travail)
@@ -335,6 +335,7 @@
 	AM_CONDITIONAL([BUILD_WXSMITH], [false])
 	AM_CONDITIONAL([BUILD_WXSMITHCONTRIB], [false])
 	AM_CONDITIONAL([BUILD_WXSMITHAUI], [false])
+	AM_CONDITIONAL([BUILD_WXSMITHPLOT], [false])
 	AM_CONDITIONAL([BUILD_HEXEDITOR], [false])
 	AM_CONDITIONAL([BUILD_INCSEARCH], [false])
 	AM_CONDITIONAL([BUILD_MOUSESAP], [false])
@@ -377,6 +378,7 @@
 	AM_CONDITIONAL([BUILD_WXSMITH], [true])
 	AM_CONDITIONAL([BUILD_WXSMITHCONTRIB], [true])
 	AM_CONDITIONAL([BUILD_WXSMITHAUI], [true])
+	AM_CONDITIONAL([BUILD_WXSMITHPLOT], [true])
 	AM_CONDITIONAL([BUILD_HEXEDITOR], [true])
 	AM_CONDITIONAL([BUILD_INCSEARCH], [true])
 	AM_CONDITIONAL([BUILD_MOUSESAP], [true])
@@ -399,7 +401,7 @@
   [                        		     codestat, copystrings, Cscope, DoxyBlocks, dragscroll, EditorConfig, EditorTweaks, envvars, ]
   [                        		     FileManager, headerfixup, help, hexeditor, incsearch, keybinder, libfinder, MouseSap, ]
   [                        		     NassiShneiderman, ProjectOptionsManipulator, profiler, regex, ReopenEditor, exporter, smartindent, spellchecker, ]
-  [                        		     symtab, ThreadSearch, ToolsPlus, Valgrind, wxcontrib, wxsmith, wxsmithcontrib, wxsmithaui ],
+  [                        		     symtab, ThreadSearch, ToolsPlus, Valgrind, wxcontrib, wxsmith, wxsmithcontrib, wxsmithaui, wxsmithplot ],
   plugins="$withval", plugins="none")
 
 plugins=`echo $plugins | sed 's/,/ /g'`
@@ -511,6 +513,9 @@
 	wxsmithaui)
 		AM_CONDITIONAL([BUILD_WXSMITHAUI], [true])
 		;;
+	wxsmithplot)
+		AM_CONDITIONAL([BUILD_WXSMITHPLOT], [true])
+		;;
 	hexeditor)
 		AM_CONDITIONAL([BUILD_HEXEDITOR], [true])
 		;;
@@ -625,6 +630,9 @@
 	-wxsmithaui)
 		AM_CONDITIONAL([BUILD_WXSMITHAUI], [false])
 		;;
+	-wxsmithplot)
+		AM_CONDITIONAL([BUILD_WXSMITHPLOT], [false])
+		;;
 	-hexeditor)
 		AM_CONDITIONAL([BUILD_HEXEDITOR], [false])
 		;;
@@ -692,6 +700,7 @@
 AC_SUBST(BUILD_WXSMITH)
 AC_SUBST(BUILD_WXSMITHCONTRIB)
 AC_SUBST(BUILD_WXSMITHAUI)
+AC_SUBST(BUILD_WXSMITHPLOT)
 
 GCC_PCH=0
 PCH_FLAGS=
Index: configure.ac
===================================================================
diff --git a/trunk/configure.ac b/trunk/configure.ac
--- a/trunk/configure.ac	(révision 10042)
+++ b/trunk/configure.ac	(copie de travail)
@@ -507,6 +507,8 @@
 	src/plugins/contrib/wxSmithDemo/Makefile
 	src/plugins/contrib/wxSmithIExplore/Makefile
 	src/plugins/contrib/wxSmithPlot/Makefile
+        src/plugins/contrib/wxSmithPlot/wxsmithplot.pc
+        src/plugins/contrib/wxSmithPlot/wxmathplot/Makefile
 	src/plugins/contrib/wxSmithSTC/Makefile
 	src/plugins/contrib/lib_finder/Makefile
 	src/plugins/contrib/lib_finder/lib_finder/Makefile
Index: src/plugins/contrib/Makefile.am
===================================================================
diff --git a/trunk/src/plugins/contrib/Makefile.am b/trunk/src/plugins/contrib/Makefile.am
--- a/trunk/src/plugins/contrib/Makefile.am	(révision 10042)
+++ b/trunk/src/plugins/contrib/Makefile.am	(copie de travail)
@@ -130,6 +130,10 @@
 MAYBE_WXSMITHAUI=wxSmith wxSmithAui
 endif
 
+if BUILD_WXSMITHPLOT
+MAYBE_WXSMITHPLOT=wxSmith wxSmithPlot
+endif
+
 if BUILD_HEXEDITOR
 MAYBE_HEXEDITOR=HexEditor
 endif
@@ -192,7 +196,8 @@
 		$(MAYBE_WXCONTRIB) \
 		$(MAYBE_WXSMITH) \
 		$(MAYBE_WXSMITHCONTRIB) \
-		$(MAYBE_WXSMITHAUI)
+		$(MAYBE_WXSMITHAUI) \
+		$(MAYBE_WXSMITHPLOT)
 
 DIST_SUBDIRS = AutoVersioning \
 		BrowseTracker \
Index: src/plugins/contrib/wxSmithPlot/Makefile.am
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/Makefile.am b/trunk/src/plugins/contrib/wxSmithPlot/Makefile.am
--- a/trunk/src/plugins/contrib/wxSmithPlot/Makefile.am	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/Makefile.am	(copie de travail)
@@ -1,3 +1,24 @@
+SUBDIRS = wxmathplot
+
+AM_CPPFLAGS = $(WX_CXXFLAGS) \
+                -I$(top_srcdir)/src/include \
+                -I$(top_srcdir)/src/sdk/wxscintilla/include \
+                $(WXPROPGRID_INCLUDE) \
+                -I$(top_srcdir)/src/plugins/contrib/wxSmith \
+		-I$(top_srcdir)/src/plugins/contrib/wxSmithPlot/wxmathplot 
+
+pluginlibdir = $(pkglibdir)/plugins
+
+pluginlib_LTLIBRARIES = libwxSmithPlot.la
+
+libwxSmithPlot_la_LDFLAGS = -pthread -module -version-info 0:1:0 -shared -no-undefined -avoid-version
+
+libwxSmithPlot_la_LIBADD = ../../../sdk/libcodeblocks.la \
+                       ../wxSmith/libwxsmithlib.la \
+                       ./wxmathplot/libwxsmithplot_wxmathplot.la \
+                       $(WX_LIBS)
+
+
 EXTRA_DIST = 	$(srcdir)/*.cpp \
 		$(srcdir)/*.h \
 		$(srcdir)/*.cbp \
@@ -10,3 +31,29 @@
 		$(srcdir)/test/resource.rc \
 		$(srcdir)/test/*.cbp \
 		$(srcdir)/test/wxsmith/*.wxs
+
+pkgdata_DATA = wxSmithPlot.zip
+
+CLEANFILES = $(pkgdata_DATA)
+
+wxSmithPlot.zip: manifest.xml
+	PWD=`pwd` cd $(srcdir) && zip $(PWD)/wxSmithPlot.zip manifest.xml > /dev/null
+
+libwxSmithPlot_la_SOURCES = \
+./wxsAxis.cpp \
+./wxsText.cpp \
+./wxsMarker.cpp \
+./wxsMathPlot.cpp \
+./wxsVector.cpp \
+./wxsSmithPlot.cpp
+
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = wxsmithplot.pc
+
+noinst_HEADERS = \
+./wxsAxis.h \
+./wxsText.h \
+./wxsMarker.h \
+./wxsMathPlot.h \
+./wxsVector.h \
+./wxsSmithPlot.h
Index: src/plugins/contrib/wxSmithPlot/README
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/README b/trunk/src/plugins/contrib/wxSmithPlot/README
new file mode 10644
--- /dev/null	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/README	(copie de travail)
@@ -0,0 +1,251 @@
+/*
+* This file is part of a wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2007  Bartlomiej Swiecki
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* wxSmith and this file is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
+* 
+* Ron Collins
+* rcoll@theriver.com
+* 26-Feb-2010
+* 
+*/
+
+=============
+wxSmithPlot
+=============
+
+-------------------
+General Description
+-------------------
+
+The wxSmithPlot build directory has the following structure:
+wxSmithPlot\   
+    images\             // a set of usefull XPM images for buttons         
+    test\               // this is the Code::Blocks project to create a test
+                        // program for wxMathPlot with wxSmithPlot
+        wxsmith\        // used by Code::Blocks and wxSmith
+    wxmathplot\         // this is the location of the wxMathPlot library
+                        // that will be built and linked to wxSmithPlot
+
+---------
+Windows
+---------
+
+The Code::Blocks projects used here (wxsSmithPlot.cbp) were created and tested under Windows XP,
+using Code::Blocks SVN version 5866, and wxWidgets version 2.8.  The correct 
+order to build these projects is:
+
+1) Build the library (target "MathPlot")
+2) Build the wxSmith plugin (target "wxSmithPlot")
+3) Exit Code::Blocks and install the plugins
+   copy "wxsSmithPlot.dll" to "<Code::Blocks>\share\CodeBlocks\plugins"
+   copy "wxsSmithPlot.zip" to "<Code::Blocks>\share\CodeBlocks"
+4) Re-start Code::Blocks and build the test program (project found in the
+   "test\" directory)
+
+---------
+Linux
+---------
+
+To build this plugin under Linux:
+
+1) Go to the root folder of the source tree
+2) Run the following commands:
+      ./bootstrap
+      ./configure --with-contrib-plugins=all
+      make
+3) Copy the newly generated files
+      "<wxsmithplot_src_dir>/wxSmithPlot.zip" into /usr/share/codeblocks
+      "<wxsmithplot_src_dir>/.libs/libwxsSmithPlot.so" into /usr/lib/codeblocks/plugins/
+
+4) Re-start Code::Blocks and build the test program (project found in the "test\" directory)
+
+
+Tips&Trick
+-----------
+
+Typically under Debian with those repo configured:
+
+deb http://apt.jenslody.de/testing jessie main
+deb-src http://apt.jenslody.de/testing jessie main
+
+Code::Blocks is linked with some wxWidget 2.8 special Debian library.
+If you want to generate wxSmithPlot plugin for a working Code::Blocks installation,
+you need to modify both Makefiles
+"<wxsmithplot_src_dir>/Makefile.am" and "<wxsmithplot_src_dir>/wxmathplot/Makefile.am"
+to link the plugin with the same libraries of your Code::Blocks binary instead of those
+generated in the source tree.
+
+
+In <wxsmithplot_src_dir>/Makefile.am, replace libwxSmithPlot_la_LIBAD variable with:
+
+-------------------------------------------
+libwxSmithPlot_la_LIBADD = -L/usr/lib/ \
+-l:libcodeblocks.so.0 \
+-l:libwxsmithlib.so.0 \
+./wxmathplot/libwxsmithplot_wxmathplot.la \
+-L/usr/lib/x86_64-linux-gnu/ \
+-l:libwx_gtk2u_richtext-2.8.so.0 \
+-l:libwx_gtk2u_aui-2.8.so.0 \
+-l:libwx_gtk2u_xrc-2.8.so.0 \
+-l:libwx_gtk2u_qa-2.8.so.0 \
+-l:libwx_gtk2u_html-2.8.so.0 \
+-l:libwx_gtk2u_adv-2.8.so.0 \
+-l:libwx_gtk2u_core-2.8.so.0 \
+-l:libwx_baseu_xml-2.8.so.0 \
+-l:libwx_baseu_net-2.8.so.0 \
+-l:libwx_baseu-2.8.so.0
+-----------------------------------------
+
+In <wxsmithplot_src_dir>/wxmathplot/Makefile.am, replace libwxsmithplot_wxmathplot_la_LIBADD variable with:
+
+-----------------------------------------
+libwxsmithplot_wxmathplot_la_LIBADD = -L/usr/lib/x86_64-linux-gnu/ \
+-l:libwx_gtk2u_richtext-2.8.so.0 \
+-l:libwx_gtk2u_aui-2.8.so.0 \
+-l:libwx_gtk2u_xrc-2.8.so.0 \
+-l:libwx_gtk2u_qa-2.8.so.0 \
+-l:libwx_gtk2u_html-2.8.so.0 \
+-l:libwx_gtk2u_adv-2.8.so.0 \
+-l:libwx_gtk2u_core-2.8.so.0 \
+-l:libwx_baseu_xml-2.8.so.0 \
+-l:libwx_baseu_net-2.8.so.0 \
+-l:libwx_baseu-2.8.so.0
+-----------------------------------------
+
+Clean the source tree of previous build files and rebuild the whole thing.
+
+=============
+wxMathPlot
+=============
+
+-------------------
+General Description
+-------------------
+
+wxMathPlot is a framework for mathematical graph plotting in wxWindows.
+
+The framework is designed for convenience and ease of use.
+
+The heart of wxMathPlot is mpWindow, which is a 2D canvas for plot layers.
+mpWindow can be embedded as subwindow in a wxPane, a wxFrame, or any other 
+wxWindow.  mpWindow provides a zoomable and moveable view of the layers. The 
+current view can be controlled with the mouse, the scrollbars, and a context 
+menu.
+
+Plot layers are implementations of the abstract base class mpLayer. Those can
+be function plots, scale rulers, or any other vector data visualisation. 
+wxMathPlot provides two mpLayer implementations for plotting horizontal and 
+vertical rulers: mpScaleX and mpScaleY.  For convenient function plotting three 
+more abstract base classes derived from mpLayer are provided: mpFX, mpFY and 
+mpFXY. These base classes already come with plot code, own functions can be 
+implemented by overiding just one member for retrieving a function value.
+Another class, mpFXYVector, is provided since version 0.03. This non-virtual 
+class renders 2D graphs from a pair of std::vector's. One of the utility of this 
+class is that you can use it directly in GUI designers such as wxSmith within 
+Code::Blocks.
+
+From version 0.03, the mpWindow has built-in support for mouse-based pan and 
+zoom through intuitive combinations of buttons and the mouse wheel. It also 
+incorporate an optional double buffering mechanism to avoid flicker.
+
+wxMathPlot sticks to wxWindow's coding conventions. All entities defined by 
+wxMathPlot have the prefix "mp".
+
+wxMathPlot is published under the terms of the wxWindow license.
+The original author is David Schalig <mrhill@users.sourceforge.net>.
+From June 2007 the project is maintained by Davide Rondini. 
+<cdron@users.sourceforge.net>.
+Authors can be contacted via the wxMathPlot's homepage at
+http://sourceforge.net/projects/wxmathplot.
+Contributors:
+Jose Luis Blanco <jlblanco@ctima.uma.es>, Val Greene.
+
+----------------------   
+Properties Description
+----------------------
+
+WxMathPlot has a plugin for Code::Blocks, that works with the wxSmith GUI
+designer.  This plugin makes 4 components available on the wxSmith component
+pallette, found on the "MathPlot" tab: mpWindow, mpAxis, mpVector, and
+mpMarker.
+
+mpWindow
+--------
+This is an implementation of the "mpWindow" described in "mathplot.h".  The
+properties tab allows you to preset all the attributes normally associated
+with any widget component (size, position, background colour, etc).  An
+mpWindow simply provides a place to draw lines and curves.
+
+The mpWindow also handles almost all of the "detail" work associated with
+displaying a large set of numerical data; details such as setting scale,
+aligning the axis and tic-marks, and fitting the data to the display area
+are all taken care of by mpWindow.
+
+In addition, mpWindow provides a popup menu (right-click on the mouse) that
+allows the user to zoom in, zoom out, and move the center of the plot.
+
+mpAxis
+------
+An axis displays a line with (optional) tic-marks, and provides a scale with
+which to measure the relative amplitude of values plotted upon the mpWindow.
+
+When a mpAxis is selected and placed upon an mpWindow, a text-label widget is
+displayed on the GUI designer with the name of the mpAxis.  This text-label
+is simply a "place holder", and is used only for designer purposes.  It does
+not appear on the final (compiled) display.  By clicking on the place-holder,
+the properties for the axis appear in the property tab, and allows the user to
+select attibutes such as type (X-axis or Y-axis), axis label, and colour.
+
+mpVector
+--------
+A vector is an implementation of mpFXYVector() (described in "mathplot.h").
+This component allows the user to define numerical data as a set of X,Y data
+points and draw them as a single curve on the mpWindow.  (Other vector types
+such as mpFX() or mpFY() may only be implemented programattically by the user,
+as they return X or Y data only on demand).
+
+When a vector is selected and placed upon an mpWindow, a text-label widget is
+displayed on the GUI designer with the name of the mpVector.  This text-label
+is simply a "place holder", and is used only for designer purposes.  It does
+not appear on the final (compiled) display.  By clicking on the place-holder,
+the properties for the vector appear in the property tab, and allows the user to
+select attibutes such as vector label, continuous line, and colour.  It also
+allows the user the option to pre-load data for the vector.
+
+When pre-loading data for a vector, define the data as a set of X,Y points; 
+this is, 2 floating-point numbers seperated by a comma.  Blank lines and lines
+starting with "!" are ignored when mpVector reads the data.  Also, since the
+data is stored as a wxArrayString, there is a limit as to how many lines may
+be entered (currently about 16 000 lines maximum).
+
+mpText
+--------
+A text is simply a text label that appears at a given location on the
+mpWindow, located in graph units. The label are positionedrelative to the
+edges of the mpWindow (such as north-east corner or along the bottom edge) and
+the location is given with an mpWindows's offset based on a percentage of
+(0-100).
+
+mpMarker
+--------
+A marker is simply a text label that appears at a given location on the
+mpWindow, located in graph units.  While other text labels are positioned
+relative to the edges of the mpWindow (such as north-east corner or along
+the bottom edge) a marker is positioned just as if it were another numerical
+datum (for example, at position [0.0, 0.0] or position [-5.0, 11.5]).  The
+text is centered upon the specified point. 
+      
+
Index: src/plugins/contrib/wxSmithPlot/ReadMe.txt
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/ReadMe.txt b/trunk/src/plugins/contrib/wxSmithPlot/ReadMe.txt
deleted file mode 10644
--- a/trunk/src/plugins/contrib/wxSmithPlot/ReadMe.txt	(révision 10042)
+++ /dev/null	(copie de travail)
@@ -1,193 +0,0 @@
-/*
-* This file is part of a wxSmith plugin for Code::Blocks Studio
-* Copyright (C) 2007  Bartlomiej Swiecki
-*
-* wxSmith is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation; either version 2 of the License, or
-* (at your option) any later version.
-*
-* wxSmith and this file is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with wxSmith; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
-* 
-* Ron Collins
-* rcoll@theriver.com
-* 26-Feb-2010
-* 
-*/
-
-
-
-=============
-wxMathPlot
-=============
-
--------------------
-General Description
--------------------
-
-wxMathPlot is a framework for mathematical graph plotting in wxWindows.
-
-The framework is designed for convenience and ease of use.
-
-The heart of wxMathPlot is mpWindow, which is a 2D canvas for plot layers.
-mpWindow can be embedded as subwindow in a wxPane, a wxFrame, or any other 
-wxWindow.  mpWindow provides a zoomable and moveable view of the layers. The 
-current view can be controlled with the mouse, the scrollbars, and a context 
-menu.
-
-Plot layers are implementations of the abstract base class mpLayer. Those can
-be function plots, scale rulers, or any other vector data visualisation. 
-wxMathPlot provides two mpLayer implementations for plotting horizontal and 
-vertical rulers: mpScaleX and mpScaleY.  For convenient function plotting three 
-more abstract base classes derived from mpLayer are provided: mpFX, mpFY and 
-mpFXY. These base classes already come with plot code, own functions can be 
-implemented by overiding just one member for retrieving a function value.
-Another class, mpFXYVector, is provided since version 0.03. This non-virtual 
-class renders 2D graphs from a pair of std::vector's. One of the utility of this 
-class is that you can use it directly in GUI designers such as wxSmith within 
-Code::Blocks.
-
-From version 0.03, the mpWindow has built-in support for mouse-based pan and 
-zoom through intuitive combinations of buttons and the mouse wheel. It also 
-incorporate an optional double buffering mechanism to avoid flicker.
-
-wxMathPlot sticks to wxWindow's coding conventions. All entities defined by 
-wxMathPlot have the prefix "mp".
-
-wxMathPlot is published under the terms of the wxWindow license.
-The original author is David Schalig <mrhill@users.sourceforge.net>.
-From June 2007 the project is maintained by Davide Rondini. 
-<cdron@users.sourceforge.net>.
-Authors can be contacted via the wxMathPlot's homepage at
-http://sourceforge.net/projects/wxmathplot.
-Contributors:
-Jose Luis Blanco <jlblanco@ctima.uma.es>, Val Greene.
-
-
-
-The wxMathPlot build directory has the following structure:
-MathPlot\
-    bin\                // this dir contains the binary file output of the 
-                        // Code::Blocks projects; files include "TestPlot.exe",
-                        // "wxsSmithPlot.dll",  "wxsSmithPlot.zip", and 
-                        // "CopySmithPlot.bat"    
-    images\             // a set of usefull XPM images for buttons         
-    include\            // the include file "wxMathPlot.h" is here
-    lib\                // the library "wxMathPlot.a" is here
-    obj\                // intermediate files for all compiles
-    project\            // this is the Code::Bocks project to create the
-                        // wxMathPlot library; it creates the file
-                        // "wxMathPlot.a" and places the library file and
-                        // the include file in the proper directories 
-    src\                // source files for component wxMathPlot
-    test\               // this is the Code::Blocks project to create a test
-                        // program for wxMathPlot; the output file
-                        // "TestPlot.exe" is placed in the ..\bin\ directory
-        wxsmith\        // used by Code::Blocks and wxSmith
-    wxs\                // this is the Code::Blocks project to create the
-                        // plugin for Code::Blocks and wxSmith, to put the
-                        // component wxMathPlot on the wxSmith palette.
-                        // the output files "wxsSmithPlot.dll" and
-                        // and "wxsSmithPlot.zip" are placed in the ..\bin\
-                        // directory; they must be manually copied to the
-                        // plugin directory of your Code::Blocks installation.
-                        // see the batch file "CopySmithPlot.bat" to
-                        // make this easier  
-        images\         // images used on the wxSmith palette 
-        src\            // source code for the property pages used by
-                        // wxSmith for the wxMathPlot component
-
-The Code::Blocks projects used here were created and tested under Windows XP,
-using Code::Blocks SVN version 5866, and wxWidgets version 2.8.  The correct 
-order to build these projects is:
-
-1) Build the library (project found in the "project\" directory)
-2) Build the wxSmith plugin (project found in the "wxs\" directory)
-3) Exit Code::Blocks and install the plugins
-   copy "bin\wxsSmithPlot.dll" to "<Code::Blocks>\share\CodeBlocks\plugins"
-   copy "bin\wxsSmithPlot.zip" to "<Code::Blocks>\share\CodeBlocks"
-4) Re-start Code::Blocks and build the test program (project found in the
-   "test\" directory)
-
-(For Windows XP, all of these projects and programs are already compiled; you
-only need to install the plugin files into your own Code::Blocks installation
-directory).
-
-
- 
-
-----------------------   
-Properties Description
-----------------------
-
-WxMathPlot has a plugin for Code::Blocks, that works with the wxSmith GUI
-designer.  This plugin makes 4 components available on the wxSmith component
-pallette, found on the "MathPlot" tab: mpWindow, mpAxis, mpVector, and
-mpMarker.
-
-mpWindow
---------
-This is an implementation of the "mpWindow" described in "mathplot.h".  The
-properties tab allows you to preset all the attributes normally associated
-with any widget component (size, position, background colour, etc).  An
-mpWindow simply provides a place to draw lines and curves.
-
-The mpWindow also handles almost all of the "detail" work associated with
-displaying a large set of numerical data; details such as setting scale,
-aligning the axis and tic-marks, and fitting the data to the display area
-are all taken care of by mpWindow.
-
-In addition, mpWindow provides a popup menu (right-click on the mouse) that
-allows the user to zoom in, zoom out, and move the center of the plot.
-
-mpAxis
-------
-An axis displays a line with (optional) tic-marks, and provides a scale with
-which to measure the relative amplitude of values plotted upon the mpWindow.
-
-When a mpAxis is selected and placed upon an mpWindow, a text-label widget is
-displayed on the GUI designer with the name of the mpAxis.  This text-label
-is simply a "place holder", and is used only for designer purposes.  It does
-not appear on the final (compiled) display.  By clicking on the place-holder,
-the properties for the axis appear in the property tab, and allows the user to
-select attibutes such as type (X-axis or Y-axis), axis label, and colour.
-
-mpVector
---------
-A vector is an implementation of mpFXYVector() (described in "mathplot.h").
-This component allows the user to define numerical data as a set of X,Y data
-points and draw them as a single curve on the mpWindow.  (Other vector types
-such as mpFX() or mpFY() may only be implemented programattically by the user,
-as they return X or Y data only on demand).
-
-When a vector is selected and placed upon an mpWindow, a text-label widget is
-displayed on the GUI designer with the name of the mpVector.  This text-label
-is simply a "place holder", and is used only for designer purposes.  It does
-not appear on the final (compiled) display.  By clicking on the place-holder,
-the properties for the vector appear in the property tab, and allows the user to
-select attibutes such as vector label, continuous line, and colour.  It also
-allows the user the option to pre-load data for the vector.
-
-When pre-loading data for a vector, define the data as a set of X,Y points; 
-this is, 2 floating-point numbers seperated by a comma.  Blank lines and lines
-starting with "!" are ignored when mpVector reads the data.  Also, since the
-data is stored as a wxArrayString, there is a limit as to how many lines may
-be entered (currently about 16 000 lines maximum).
-
-mpMarker
---------
-A marker is simply a text label that appears at a given location on the
-mpWindow, located in graph units.  While other text labels are positioned
-relative to the edges of the mpWindow (such as north-east corner or along
-the bottom edge) a marker is positioned just as if it were another numerical
-datum (for example, at position [0.0, 0.0] or position [-5.0, 11.5]).  The
-text is centered upon the specified point. 
-      
-
Index: src/plugins/contrib/wxSmithPlot/images/marker16.bmp
===================================================================
Impossible d'afficher : fichier considéré comme binaire.
svn:mime-type = application/octet-stream
Index: src/plugins/contrib/wxSmithPlot/images/marker16.xpm
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/images/marker16.xpm b/trunk/src/plugins/contrib/wxSmithPlot/images/marker16.xpm
--- a/trunk/src/plugins/contrib/wxSmithPlot/images/marker16.xpm	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/images/marker16.xpm	(copie de travail)
@@ -20,15 +20,15 @@
 " &&&&&&&&&&&&&&&",
 " ))&)))&)))&)))&",
 " ))&)))&)))&)))&",
-" ))&>*)&)))>>>)&",
-" &&&>>&&&&&>>&&&",
-" ))&>>&&))&>>))&",
-" ))&>>*&)**>>))&",
-" ))&>>)>)>)>>))&",
-" &&&>>&&>&&>>&&&",
-" ))&>>)&&))>>))&",
-" ))&>>)&)))>>))&",
-" ))&>>>>)>>>>>)&",
+" )>>>))&)))>>>)&",
+" &&>>&&&&&&>>&&&",
+" ))>>>)&))>>>))&",
+" ))>>>>&)>>>>))&",
+" ))>>)>>>>)>>))&",
+" &&>>&&>>&&>>&&&",
+" ))>>))&)))>>))&",
+" ))>>))&)))>>))&",
+" )>>>>>&)>>>>>)&",
 " &&&&&&&&&&&&&&&",
 " ))&)))&)))&)))&",
 " ))&)))&)))&)))&",
Index: src/plugins/contrib/wxSmithPlot/images/marker32.bmp
===================================================================
Impossible d'afficher : fichier considéré comme binaire.
svn:mime-type = application/octet-stream
Index: src/plugins/contrib/wxSmithPlot/images/marker32.xpm
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/images/marker32.xpm b/trunk/src/plugins/contrib/wxSmithPlot/images/marker32.xpm
--- a/trunk/src/plugins/contrib/wxSmithPlot/images/marker32.xpm	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/images/marker32.xpm	(copie de travail)
@@ -23,24 +23,24 @@
 "  ))))&&))))&&))))&&))))&&))))&&",
 "  ))))&&))))&&))))&&))))&&))))&&",
 "  ))))&&))))&&))))&&))))&&))))&&",
-"  &&&&&&&>>>&&&&&&&&>>>>&&&&&&&&",
-"  &&&&&&&>>>&&&&&&&&>>>>&&&&&&&&",
-"  ))))&&))>>>&))))&>>>))&&))))&&",
-"  ))))&&))>>>&))))&>>>))&&))))&&",
-"  ))))&&))>>>>))))>>>>))&&))))&&",
-"  ))))&&))>>&>*))*>&>>))&&))))&&",
-"  &&&&&&&&>>&>>&&>>&>>&&&&&&&&&&",
-"  &&&&&&&&>>&&>>>>&&>>&&&&&&&&&&",
-"  ))))&&))>>&&*>>*&&>>))&&))))&&",
-"  ))))&&))>>&&)>>)&&>>))&&))))&&",
-"  ))))&&))>>&&))))&&>>))&&))))&&",
-"  ))))&&))>>&&))))&&>>))&&))))&&",
-"  &&&&&&&>>>>>>&&>>>>>>>&&&&&&&&",
-"  &&&&&&&>>>>>>&&>>>>>>>&&&&&&&&",
-"  ))))&&))))&&))))&&))))&&))))&&",
-"  ))))&&))))&&))))&&))))&&))))&&",
-"  ))))&&))))&&))))&&))))&&))))&&",
-"  ))))&&))))&&))))&&))))&&))))&&",
+"  &&>>>>>>&&&&&&&&&&&&>>>>>>&&&&",
+"  &&>>>>>>&&&&&&&&&&&&>>>>>>&&&&",
+"  ))))>>>>))&&))))&&))>>>>))))&&",
+"  ))))>>>>>)&&))))&&)>>>>>))))&&",
+"  ))))>>>>>>&&))))&&>>>>>>))))&&",
+"  ))))>>>>>>>&))))&>>>>>>>))))&&",
+"  &&&&>>>>>>>>&&&&>>>>>>>>&&&&&&",
+"  &&&&>>>>>>>>>&&>>>>>>>>>&&&&&&",
+"  ))))>>>>))>>>>>>>>))>>>>))))&&",
+"  ))))>>>>))>>>>>>>>))>>>>))))&&",
+"  ))))>>>>))&&>>>>&&))>>>>))))&&",
+"  ))))>>>>))&&>>>>&&))>>>>))))&&",
+"  &&&&>>>>&&&&&&&&&&&&>>>>&&&&&&",
+"  &&&&>>>>&&&&&&&&&&&&>>>>&&&&&&",
+"  ))))>>>>))&&))))&&))>>>>))))&&",
+"  ))))>>>>))&&))))&&))>>>>))))&&",
+"  ))>>>>>>>>>>))))>>>>>>>>>>))&&",
+"  ))>>>>>>>>>>))))>>>>>>>>>>))&&",
 "  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&",
 "  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&",
 "  ))))&&))))&&))))&&))))&&))))&&",
Index: src/plugins/contrib/wxSmithPlot/images/text16.bmp
===================================================================
Impossible d'afficher : fichier considéré comme binaire.
svn:mime-type = application/octet-stream
Index: src/plugins/contrib/wxSmithPlot/images/text16.bmp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/images/text16.bmp b/trunk/src/plugins/contrib/wxSmithPlot/images/text16.bmp
--- a/trunk/src/plugins/contrib/wxSmithPlot/images/text16.bmp	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/images/text16.bmp	(copie de travail)

Modification de propriétés sur trunk/src/plugins/contrib/wxSmithPlot/images/text16.bmp
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: src/plugins/contrib/wxSmithPlot/images/text16.xpm
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/images/text16.xpm b/trunk/src/plugins/contrib/wxSmithPlot/images/text16.xpm
new file mode 10644
--- /dev/null	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/images/text16.xpm	(copie de travail)
@@ -0,0 +1,35 @@
+/* XPM */
+static const char * text16_xpm[] = {
+"16 16 16 1",
+" 	c #000000",
+".	c #800000",
+"+	c #008000",
+"@	c #808000",
+"#	c #000080",
+"$	c #800080",
+"%	c #008080",
+"&	c #808080",
+"*	c #C0C0C0",
+"=	c #FF0000",
+"-	c #00FF00",
+";	c #FFFF00",
+">	c #0000FF",
+",	c #FF00FF",
+"'	c #00FFFF",
+")	c #FFFFFF",
+" &&&&&&&&&&&&&&&",
+" ))&)))&)))&)))&",
+" ))&)))&)))&)))&",
+" ))>>>>>>>>>>))&",
+" &&>>>>>>>>>>&&&",
+" ))>)))>>))&>))&",
+" ))&)))>>))&)))&",
+" ))&)))>>))&)))&",
+" &&&&&&>>&&&&&&&",
+" ))&)))>>))&)))&",
+" ))&)))>>))&)))&",
+" ))&))>>>>)&)))&",
+" &&&&&&&&&&&&&&&",
+" ))&)))&)))&)))&",
+" ))&)))&)))&)))&",
+"                "};
Index: src/plugins/contrib/wxSmithPlot/images/text32.bmp
===================================================================
Impossible d'afficher : fichier considéré comme binaire.
svn:mime-type = application/octet-stream
Index: src/plugins/contrib/wxSmithPlot/images/text32.bmp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/images/text32.bmp b/trunk/src/plugins/contrib/wxSmithPlot/images/text32.bmp
--- a/trunk/src/plugins/contrib/wxSmithPlot/images/text32.bmp	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/images/text32.bmp	(copie de travail)

Modification de propriétés sur trunk/src/plugins/contrib/wxSmithPlot/images/text32.bmp
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: src/plugins/contrib/wxSmithPlot/images/text32.xpm
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/images/text32.xpm b/trunk/src/plugins/contrib/wxSmithPlot/images/text32.xpm
new file mode 10644
--- /dev/null	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/images/text32.xpm	(copie de travail)
@@ -0,0 +1,51 @@
+/* XPM */
+static const char * text32_xpm[] = {
+"32 32 16 1",
+" 	c #000000",
+".	c #800000",
+"+	c #008000",
+"@	c #808000",
+"#	c #000080",
+"$	c #800080",
+"%	c #008080",
+"&	c #808080",
+"*	c #C0C0C0",
+"=	c #FF0000",
+"-	c #00FF00",
+";	c #FFFF00",
+">	c #0000FF",
+",	c #FF00FF",
+"'	c #00FFFF",
+")	c #FFFFFF",
+"  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&",
+"  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&",
+"  ))))&&))))&&))))&&))))&&))))&&",
+"  ))))&&))))&&))))&&))))&&))))&&",
+"  ))))>>>>>>>>>>>>>>>>>>>>))))&&",
+"  ))))>>>>>>>>>>>>>>>>>>>>))))&&",
+"  &&&&>>>>>>>>>>>>>>>>>>>>&&&&&&",
+"  &&&&>>>>>>>>>>>>>>>>>>>>&&&&&&",
+"  ))))>>))))&&>>>>&&))))>>))))&&",
+"  ))))&&))))&&>>>>&&))))&&))))&&",
+"  ))))&&))))&&>>>>&&))))&&))))&&",
+"  ))))&&))))&&>>>>&&))))&&))))&&",
+"  &&&&&&&&&&&&>>>>&&&&&&&&&&&&&&",
+"  &&&&&&&&&&&&>>>>&&&&&&&&&&&&&&",
+"  ))))&&))))&&>>>>&&))))&&))))&&",
+"  ))))&&))))&&>>>>&&))))&&))))&&",
+"  ))))&&))))&&>>>>&&))))&&))))&&",
+"  ))))&&))))&&>>>>&&))))&&))))&&",
+"  &&&&&&&&&&&&>>>>&&&&&&&&&&&&&&",
+"  &&&&&&&&&&&&>>>>&&&&&&&&&&&&&&",
+"  ))))&&))))&&>>>>&&))))&&))))&&",
+"  ))))&&))))&&>>>>&&))))&&))))&&",
+"  ))))&&))))>>>>>>>>))))&&))))&&",
+"  ))))&&))))>>>>>>>>))))&&))))&&",
+"  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&",
+"  &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&",
+"  ))))&&))))&&))))&&))))&&))))&&",
+"  ))))&&))))&&))))&&))))&&))))&&",
+"  ))))&&))))&&))))&&))))&&))))&&",
+"  ))))&&))))&&))))&&))))&&))))&&",
+"                                ",
+"                                "};
Index: src/plugins/contrib/wxSmithPlot/manifest.xml
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/manifest.xml b/trunk/src/plugins/contrib/wxSmithPlot/manifest.xml
--- a/trunk/src/plugins/contrib/wxSmithPlot/manifest.xml	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/manifest.xml	(copie de travail)
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
 <CodeBlocks_plugin_manifest_file>
-    <SdkVersion major="1" minor="0"  release="0" />
+    <SdkVersion major="1" minor="23"  release="0" />
     <Plugin name="wxsSmithPlot">
         <Value title="wxsSmithPlot - Curve Plotting" />
-        <Value version="1.0" />
+        <Value version="1.1" />
         <Value description="A Component To Plot Computed Curves" />
-        <Value author="" />
+        <Value author="R1kk3r" />
         <Value authorEmail="" />
-        <Value authorWebsite="" />
+        <Value authorWebsite="https://github.com/R1kk3r" />
         <Value thanksTo="" />
         <Value license="GPL" />
     </Plugin>
Index: src/plugins/contrib/wxSmithPlot/mathplot.cpp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/mathplot.cpp b/trunk/src/plugins/contrib/wxSmithPlot/mathplot.cpp
deleted file mode 10644
--- a/trunk/src/plugins/contrib/wxSmithPlot/mathplot.cpp	(révision 10042)
+++ /dev/null	(copie de travail)
@@ -1,1127 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:            mathplot.cpp
-// Purpose:         Framework for plotting in wxWindows
-// Original Author: David Schalig
-// Maintainer:      Davide Rondini
-// Contributors:    Jose Luis Blanco, Val Greene
-// Created:         21/07/2003
-// Last edit:       09/09/2007
-// Copyright:       (c) David Schalig, Davide Rondini
-// Licence:         wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifdef __GNUG__
-// #pragma implementation "plot.h"
-#pragma implementation "mathplot.h"
-#endif
-
-// For compilers that support precompilation, includes "wx.h".
-#include <wx/window.h>
-//#include <wx/wxprec.h>
-
-// Comment out for release operation:
-// (Added by J.L.Blanco, Aug 2007)
-// #define MATHPLOT_DO_LOGGING
-
-#ifdef __BORLANDC__
-#pragma hdrstop
-#endif
-
-#ifndef WX_PRECOMP
-#include "wx/object.h"
-#include "wx/font.h"
-#include "wx/colour.h"
-#include "wx/settings.h"
-#include "wx/sizer.h"
-#include "wx/log.h"
-#include "wx/intl.h"
-#include "wx/dcclient.h"
-#include "wx/cursor.h"
-#endif
-
-#include "mathplot.h"
-#include <wx/bmpbuttn.h>
-#include <wx/module.h>
-#include <wx/msgdlg.h>
-
-#include <math.h>
-#include <cstdio> // used only for debug
-
-//-----------------------------------------------------------------------------
-// mpLayer
-//-----------------------------------------------------------------------------
-
-IMPLEMENT_ABSTRACT_CLASS(mpLayer, wxObject)
-
-mpLayer::mpLayer()
-{
-    SetPen((wxPen&) *wxBLACK_PEN);
-    SetFont((wxFont&) *wxNORMAL_FONT);
-    m_continuous = FALSE; // Default
-}
-
-//-----------------------------------------------------------------------------
-// mpLayer implementations - functions
-//-----------------------------------------------------------------------------
-
-IMPLEMENT_ABSTRACT_CLASS(mpFX, mpLayer)
-
-mpFX::mpFX(wxString name, int flags)
-{
-    SetName(name);
-    m_flags = flags;
-}
-
-void mpFX::Plot(wxDC & dc, mpWindow & w)
-{
-    dc.SetPen( m_pen);
-    dc.SetTextForeground(m_pen.GetColour());
-
-    if (m_pen.GetWidth() <= 1)
-    {
-        for (wxCoord i = -(w.GetScrX()>>1); i < (w.GetScrX()>>1); ++i)
-        {
-            dc.DrawPoint(i, (wxCoord) ((w.GetPosY() - GetY( (double)i / w.GetScaleX() + w.GetPosX()) ) * w.GetScaleY()));
-        }
-    }
-    else
-    {
-        for (wxCoord i = -(w.GetScrX()>>1); i < (w.GetScrX()>>1); ++i)
-        {
-            wxCoord c = (wxCoord) ((w.GetPosY() - GetY( (double)i / w.GetScaleX() + w.GetPosX()) ) * w.GetScaleY());
-            dc.DrawLine( i, c, i, c);
-        }
-    }
-
-    if (!m_name.IsEmpty())
-    {
-        dc.SetFont(m_font);
-
-        wxCoord tx, ty;
-        dc.GetTextExtent(m_name, &tx, &ty);
-
-        if ((m_flags & mpALIGNMASK) == mpALIGN_RIGHT)
-            tx = (w.GetScrX()>>1) - tx - 8;
-        else if ((m_flags & mpALIGNMASK) == mpALIGN_CENTER)
-            tx = -tx/2;
-        else
-            tx = -(w.GetScrX()>>1) + 8;
-
-        dc.DrawText( m_name, tx, (wxCoord) ((w.GetPosY() - GetY( (double)tx / w.GetScaleX() + w.GetPosX())) * w.GetScaleY()) );
-    }
-}
-
-IMPLEMENT_ABSTRACT_CLASS(mpFY, mpLayer)
-
-mpFY::mpFY(wxString name, int flags)
-{
-    SetName(name);
-    m_flags = flags;
-}
-
-void mpFY::Plot(wxDC & dc, mpWindow & w)
-{
-    dc.SetPen( m_pen);
-    dc.SetTextForeground(m_pen.GetColour());
-
-
-    wxCoord i;
-
-    if (m_pen.GetWidth() <= 1)
-    {
-        for (i = -(w.GetScrY()>>1); i < (w.GetScrY()>>1); ++i)
-        {
-            dc.DrawPoint((wxCoord) ((GetX( (double)i / w.GetScaleY() + w.GetPosY()) - w.GetPosX()) * w.GetScaleX()), -i);
-        }
-    }
-    else
-    {
-        for (i = -(w.GetScrY()>>1); i < (w.GetScrY()>>1); ++i)
-        {
-            wxCoord c =  (wxCoord) ((GetX( (double)i / w.GetScaleY() + w.GetPosY()) - w.GetPosX()) * w.GetScaleX());
-            dc.DrawLine(c, -i, c, -i);
-        }
-    }
-
-    if (!m_name.IsEmpty())
-    {
-        dc.SetFont(m_font);
-
-        wxCoord tx, ty;
-        dc.GetTextExtent(m_name, &tx, &ty);
-
-        if ((m_flags & mpALIGNMASK) == mpALIGN_TOP)
-            ty = (w.GetScrY()>>1) - 8;
-        else if ((m_flags & mpALIGNMASK) == mpALIGN_CENTER)
-            ty = 16 - ty/2;
-        else
-            ty = -(w.GetScrY()>>1) + 8;
-
-        dc.DrawText( m_name, (wxCoord) ((GetX( (double)i / w.GetScaleY() + w.GetPosY()) - w.GetPosX()) * w.GetScaleX()), -ty);
-    }
-}
-
-IMPLEMENT_ABSTRACT_CLASS(mpFXY, mpLayer)
-
-mpFXY::mpFXY(wxString name, int flags)
-{
-    SetName(name);
-    m_flags = flags;
-}
-
-void mpFXY::Plot(wxDC & dc, mpWindow & w)
-{
-    dc.SetPen( m_pen);
-    dc.SetTextForeground(m_pen.GetColour());
-
-
-    double x, y;
-    Rewind();
-
-    if (!m_continuous)
-    {
-        // for some reason DrawPoint does not use the current pen,
-        // so we use DrawLine for fat pens
-        if (m_pen.GetWidth() <= 1)
-        {
-            while (GetNextXY(x, y))
-            {
-                dc.DrawPoint( (wxCoord) ((x - w.GetPosX()) * w.GetScaleX()) ,
-                              (wxCoord) ((w.GetPosY() - y) * w.GetScaleY()) );
-            }
-        }
-        else
-        {
-            while (GetNextXY(x, y))
-            {
-                wxCoord cx = (wxCoord) ((x - w.GetPosX()) * w.GetScaleX());
-                wxCoord cy = (wxCoord) ((w.GetPosY() - y) * w.GetScaleY());
-                dc.DrawLine(cx, cy, cx, cy);
-            }
-        }
-    }
-    else
-    {
-        wxCoord cx0=0,cy0=0;
-        bool    first = TRUE;
-        while (GetNextXY(x, y))
-        {
-            wxCoord cx = (wxCoord) ((x - w.GetPosX()) * w.GetScaleX());
-            wxCoord cy = (wxCoord) ((w.GetPosY() - y) * w.GetScaleY());
-            if (first)
-            {
-                first=FALSE;
-                cx0=cx;cy0=cy;
-            }
-            dc.DrawLine(cx0, cy0, cx, cy);
-            cx0=cx; cy0=cy;
-        }
-    }
-
-    if (!m_name.IsEmpty())
-    {
-        dc.SetFont(m_font);
-
-        wxCoord tx, ty;
-        dc.GetTextExtent(m_name, &tx, &ty);
-
-        // xxx implement else ... if (!HasBBox())
-        {
-            const int sx = w.GetScrX()>>1;
-            const int sy = w.GetScrY()>>1;
-
-            if ((m_flags & mpALIGNMASK) == mpALIGN_NE)
-            {
-                tx = sx - tx - 8;
-                ty = -sy + 8;
-            }
-            else if ((m_flags & mpALIGNMASK) == mpALIGN_NW)
-            {
-                tx = -sx + 8;
-                ty = -sy + 8;
-            }
-            else if ((m_flags & mpALIGNMASK) == mpALIGN_SW)
-            {
-                tx = -sx + 8;
-                ty = sy - 8 - ty;
-            }
-            else
-            {
-                tx = sx - tx - 8;
-                ty = sy - 8 - ty;
-            }
-        }
-
-        dc.DrawText( m_name, tx, ty);
-    }
-}
-
-//-----------------------------------------------------------------------------
-// mpProfile implementation
-//-----------------------------------------------------------------------------
-
-IMPLEMENT_ABSTRACT_CLASS(mpProfile, mpLayer)
-
-mpProfile::mpProfile(wxString name, int flags)
-{
-    SetName(name);
-    m_flags = flags;
-}
-
-void mpProfile::Plot(wxDC & dc, mpWindow & w)
-{
-    dc.SetPen( m_pen);
-    dc.SetTextForeground(m_pen.GetColour());
-
-
-   // Plot profile linking subsequent point of the profile, instead of mpFY, which plots simple points.
-   for (wxCoord i = -(w.GetScrX()>>1); i < (w.GetScrX()>>1)-1; ++i)
- 	{
-        wxCoord c0 = (wxCoord) ((w.GetYpos() - GetY( (double)i / w.GetXscl() + w.GetXpos()) ) * w.GetYscl());
-	wxCoord c1 = (wxCoord) ((w.GetYpos() - GetY( (double)(i+1) / w.GetXscl() + (w.GetXpos() ) ) ) * w.GetYscl());
-	dc.DrawLine(i, c0, i+1, c1);
-        };
-    if (!m_name.IsEmpty())
-    {
-        dc.SetFont(m_font);
-
-        wxCoord tx, ty;
-        dc.GetTextExtent(m_name, &tx, &ty);
-
-        if ((m_flags & mpALIGNMASK) == mpALIGN_RIGHT)
-            tx = (w.GetScrX()>>1) - tx - 8;
-        else if ((m_flags & mpALIGNMASK) == mpALIGN_CENTER)
-            tx = -tx/2;
-        else
-            tx = -(w.GetScrX()>>1) + 8;
-
-        dc.DrawText( m_name, tx, (wxCoord) ((w.GetPosY() - GetY( (double)tx / w.GetScaleX() + w.GetPosX())) * w.GetScaleY()) );
-    }
-}
-
-//-----------------------------------------------------------------------------
-// mpLayer implementations - furniture (scales, ...)
-//-----------------------------------------------------------------------------
-
-#define mpLN10 2.3025850929940456840179914546844
-
-IMPLEMENT_CLASS(mpScaleX, mpLayer)
-
-mpScaleX::mpScaleX(wxString name, int flags, bool ticks)
-{
-    SetName(name);
-    SetFont( (wxFont&) *wxSMALL_FONT);
-    SetPen( (wxPen&) *wxGREY_PEN);
-    m_flags = flags;
-    m_ticks = ticks;
-}
-
-void mpScaleX::Plot(wxDC & dc, mpWindow & w)
-{
-    dc.SetPen( m_pen);
-    dc.SetFont( m_font);
-    dc.SetTextForeground(m_pen.GetColour());
-
-    int orgy;
-
-    const int extend = w.GetScrX()/2;
-    if (m_flags == mpALIGN_CENTER)
-       orgy   = (int)(w.GetPosY() * w.GetScaleY());
-    if (m_flags == mpALIGN_TOP)
-       orgy   = -(w.GetScrY()/2 - 10);
-    if (m_flags == mpALIGN_BOTTOM)
-       orgy   = (w.GetScrY()/2 - 25);
-    if (m_flags == mpALIGN_BORDER_BOTTOM )
-       orgy = dc.LogicalToDeviceY(0) - 1;
-    if (m_flags == mpALIGN_BORDER_TOP )
-       orgy = -dc.LogicalToDeviceY(0);
-
-    dc.DrawLine( -extend, orgy, extend, orgy);
-
-    const double dig  = floor( log( 128.0 / w.GetScaleX() ) / mpLN10 );
-    const double step = exp( mpLN10 * dig);
-    const double end  = w.GetPosX() + (double)extend / w.GetScaleX();
-
-    wxCoord tx, ty;
-    wxString s;
-    wxString fmt;
-    int tmp = (int)dig;
-    if (tmp>=1) {
-        fmt = wxT("%.f");
-    } else {
-        tmp=8-tmp;
-        fmt.Printf(wxT("%%.%df"), tmp >= -1 ? 2 : -tmp);
-    }
-
-    double n = floor( (w.GetPosX() - (double)extend / w.GetScaleX()) / step ) * step ;
-
-    tmp=-65535;
-    for (;n < end; n += step)
-    {
-        const int p = (int)((n - w.GetPosX()) * w.GetScaleX());
-        if (m_ticks) { // draw axis ticks
-            if (m_flags == mpALIGN_BORDER_BOTTOM)
-                dc.DrawLine( p, orgy, p, orgy-4);
-            else
-                dc.DrawLine( p, orgy, p, orgy+4);
-        } else { // draw grid dotted lines
-            m_pen.SetStyle(wxDOT);
-            dc.SetPen(m_pen);
-            dc.DrawLine( p, -w.GetScrY(), p, w.GetScrY() );
-            m_pen.SetStyle(wxSOLID);
-            dc.SetPen(m_pen);
-        }
-
-
-        s.Printf(fmt, n);
-        dc.GetTextExtent(s, &tx, &ty);
-        if ((p-tx/2-tmp) > 64) {
-            if (m_flags == mpALIGN_BORDER_BOTTOM)
-                dc.DrawText( s, p-tx/2, orgy-4-ty);
-            else
-                dc.DrawText( s, p-tx/2, orgy+4);
-            tmp=p+tx/2;
-        }
-    }
-
-    if (m_flags != mpALIGN_TOP) {
-        dc.GetTextExtent(m_name, &tx, &ty);
-        if (m_flags == mpALIGN_BORDER_BOTTOM) {
-            dc.DrawText( m_name, extend - tx - 4, orgy - 4 - (ty*2));
-        } else {
-            dc.DrawText( m_name, extend - tx - 4, orgy - 4 - ty); //orgy + 4 + ty);
-        }
-    };
-}
-
-IMPLEMENT_CLASS(mpScaleY, mpLayer)
-
-mpScaleY::mpScaleY(wxString name, int flags, bool ticks)
-{
-    SetName(name);
-    SetFont( (wxFont&) *wxSMALL_FONT);
-    SetPen( (wxPen&) *wxGREY_PEN);
-    m_flags = flags;
-    m_ticks = ticks;
-}
-
-void mpScaleY::Plot(wxDC & dc, mpWindow & w)
-{
-    dc.SetPen( m_pen);
-    dc.SetFont( m_font);
-    dc.SetTextForeground(m_pen.GetColour());
-
-
-    int orgx;
-    const int extend = w.GetScrY()/2;
-    if (m_flags == mpALIGN_CENTER)
-        orgx   = -(int)(w.GetPosX() * w.GetScaleX());
-    if (m_flags == mpALIGN_LEFT)
-        orgx   = -(w.GetScrX()/2 - 40);
-    if (m_flags == mpALIGN_RIGHT)
-        orgx   = (w.GetScrX()/2 - 10);
-    if (m_flags == mpALIGN_BORDER_RIGHT )
-        orgx = dc.LogicalToDeviceX(0) - 1;
-    if (m_flags == mpALIGN_BORDER_LEFT )
-        orgx = -dc.LogicalToDeviceX(0);
-
-
-    dc.DrawLine( orgx, -extend, orgx, extend);
-
-    const double dig  = floor( log( 128.0 / w.GetScaleY() ) / mpLN10 );
-    const double step = exp( mpLN10 * dig);
-    const double end  = w.GetPosY() + (double)extend / w.GetScaleY();
-
-    wxCoord tx, ty;
-    wxString s;
-    wxString fmt;
-    int tmp = (int)dig;
-    if (tmp>=1)
-    {
-        fmt = wxT("%.f");
-    }
-    else
-    {
-        tmp=8-tmp;
-        fmt.Printf(wxT("%%.%df"), tmp >= -1 ? 2 : -tmp);
-    }
-
-    double n = floor( (w.GetPosY() - (double)extend / w.GetScaleY()) / step ) * step ;
-
-    tmp=65536;
-    for (;n < end; n += step)
-    {
-        const int p = (int)((w.GetPosY() - n) * w.GetScaleY());
-        if (m_ticks) { // Draw axis ticks
-            if (m_flags == mpALIGN_BORDER_LEFT) {
-                dc.DrawLine( orgx, p, orgx+4, p);
-            } else {
-                dc.DrawLine( orgx-4, p, orgx, p); //( orgx, p, orgx+4, p);
-            }
-        } else {
-            m_pen.SetStyle(wxDOT);
-            dc.SetPen( m_pen);
-            dc.DrawLine( -w.GetScrX(), p, w.GetScrX(), p);
-            m_pen.SetStyle(wxSOLID);
-            dc.SetPen( m_pen);
-        }
-
-
-        s.Printf(fmt, n);
-        dc.GetTextExtent(s, &tx, &ty);
-        if ((tmp-p+ty/2) > 32)
-        {
-            if (m_flags == mpALIGN_BORDER_LEFT)
-                dc.DrawText( s, orgx+4, p-ty/2);
-            else
-                dc.DrawText( s, orgx-4-tx, p-ty/2); //( s, orgx+4, p-ty/2);
-            tmp=p-ty/2;
-        }
-    }
-
-    if (m_flags != mpALIGN_RIGHT) {
-	dc.GetTextExtent(m_name, &tx, &ty);
-	if (m_flags == mpALIGN_BORDER_LEFT) {
-            dc.DrawText( m_name, orgx-tx-4, -extend + ty + 4);
-        } else {
-            if (m_flags == mpALIGN_BORDER_RIGHT )
-                dc.DrawText( m_name, orgx-(tx*2)-4, -extend + ty + 4);
-            else
-                dc.DrawText( m_name, orgx + 4, -extend + 4);
-        }
-    };
-}
-
-//-----------------------------------------------------------------------------
-// mpWindow
-//-----------------------------------------------------------------------------
-
-IMPLEMENT_DYNAMIC_CLASS(mpWindow, wxScrolledWindow)
-
-BEGIN_EVENT_TABLE(mpWindow, wxScrolledWindow)
-    EVT_PAINT    ( mpWindow::OnPaint)
-    EVT_SIZE     ( mpWindow::OnSize)
-    EVT_SCROLLWIN( mpWindow::OnScroll2)
-
-    EVT_MIDDLE_UP( mpWindow::OnShowPopupMenu)
-    EVT_RIGHT_DOWN( mpWindow::OnMouseRightDown) // JLB
-    EVT_RIGHT_UP ( mpWindow::OnShowPopupMenu)
-    EVT_MOUSEWHEEL( mpWindow::OnMouseWheel )   // JLB
-    EVT_MOTION( mpWindow::OnMouseMove )   // JLB
-
-    EVT_MENU( mpID_CENTER,    mpWindow::OnCenter)
-    EVT_MENU( mpID_FIT,       mpWindow::OnFit)
-    EVT_MENU( mpID_ZOOM_IN,   mpWindow::OnZoomIn)
-    EVT_MENU( mpID_ZOOM_OUT,  mpWindow::OnZoomOut)
-    EVT_MENU( mpID_LOCKASPECT,mpWindow::OnLockAspect)
-    EVT_MENU( mpID_HELP_MOUSE,mpWindow::OnMouseHelp)
-END_EVENT_TABLE()
-
-mpWindow::mpWindow( wxWindow *parent, wxWindowID id, const wxPoint &pos, const wxSize &size, int flag )
-    : wxScrolledWindow( parent, id, pos, size, flag, wxT("mathplot") )
-{
-    m_scaleX = m_scaleY = 1.0;
-    m_posX   = m_posY   = 0;
-    m_scrX   = m_scrY   = 64;
-    m_minX   = m_minY   = 0;
-    m_maxX   = m_maxY   = 0;
-    m_last_lx= m_last_ly= 0;
-    m_buff_bmp = NULL;
-    m_enableDoubleBuffer        = FALSE;
-    m_enableMouseNavigation     = TRUE;
-    m_mouseMovedAfterRightClick = FALSE;
-
-    m_lockaspect = FALSE;
-
-    m_popmenu.Append( mpID_CENTER,     _("Center"),      _("Center plot view to this position"));
-    m_popmenu.Append( mpID_FIT,        _("Fit"),         _("Set plot view to show all items"));
-    m_popmenu.Append( mpID_ZOOM_IN,    _("Zoom in"),     _("Zoom in plot view."));
-    m_popmenu.Append( mpID_ZOOM_OUT,   _("Zoom out"),    _("Zoom out plot view."));
-    m_popmenu.AppendCheckItem( mpID_LOCKASPECT, _("Lock aspect"), _("Lock horizontal and vertical zoom aspect."));
-    m_popmenu.Append( mpID_HELP_MOUSE,   _("Show mouse commands..."),    _("Show help about the mouse commands."));
-
-    //m_layers.DeleteContents(TRUE);
-    m_layers.clear();
-    SetBackgroundColour( *wxWHITE );
-    EnableScrolling(FALSE, FALSE);
-    SetSizeHints(128, 128);
-
-    // J.L.Blanco: Eliminates the "flick" with the double buffer.
-    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
-
-    UpdateAll();
-}
-
-mpWindow::~mpWindow()
-{
-    if (m_buff_bmp)
-    {
-        delete m_buff_bmp;
-        m_buff_bmp = NULL;
-    }
-}
-
-// Mouse handler, for detecting when the user drag with the right button or just "clicks" for the menu
-// JLB
-void mpWindow::OnMouseRightDown(wxMouseEvent     &event)
-{
-    m_mouseMovedAfterRightClick = FALSE;
-    m_mouseRClick_X = event.GetX();
-    m_mouseRClick_Y = event.GetY();
-    if (m_enableMouseNavigation)
-    {
-        SetCursor( *wxCROSS_CURSOR );
-    }
-}
-
-// Process mouse wheel events
-// JLB
-void mpWindow::OnMouseWheel( wxMouseEvent &event )
-{
-    if (!m_enableMouseNavigation)
-    {
-        event.Skip();
-        return;
-    }
-
-    int width, height;
-    GetClientSize( &width, &height);
-
-    if (event.m_controlDown)
-    {
-        // CTRL key hold: Zoom in/out:
-        if (event.GetWheelRotation()>0)
-                ZoomIn();
-        else    ZoomOut();
-    }
-    else
-    {
-        // Scroll vertically or horizontally (this is SHIFT is hold down).
-        int change = - event.GetWheelRotation(); // Opposite direction (More intuitive)!
-        float changeUnitsX = change / m_scaleX;
-        float changeUnitsY = change / m_scaleY;
-
-        if (event.m_shiftDown)
-                m_posX += changeUnitsX;
-        else    m_posY -= changeUnitsY;
-
-        UpdateAll();
-    }
-}
-
-// If the user "drags" with the right buttom pressed, do "pan"
-// JLB
-void mpWindow::OnMouseMove(wxMouseEvent     &event)
-{
-    if (!m_enableMouseNavigation)
-    {
-        event.Skip();
-        return;
-    }
-
-    if (event.m_rightDown)
-    {
-        m_mouseMovedAfterRightClick = TRUE;  // Hides the popup menu after releasing the button!
-
-        // The change:
-        int  Ax= m_mouseRClick_X - event.GetX();
-        int  Ay= m_mouseRClick_Y - event.GetY();
-
-        // For the next event, use relative to this coordinates.
-        m_mouseRClick_X = event.GetX();
-        m_mouseRClick_Y = event.GetY();
-
-        float   Ax_units = Ax / m_scaleX;
-        float   Ay_units = -Ay / m_scaleY;
-
-        m_posX += Ax_units;
-        m_posY += Ay_units;
-
-        UpdateAll();
-
-#ifdef MATHPLOT_DO_LOGGING
-        wxLogMessage(_("[mpWindow::OnMouseMove] Ax:%i Ay:%i"),Ax,Ay);
-#endif
-    }
-}
-
-void mpWindow::Fit()
-{
-    if (UpdateBBox())
-    {
-        int cx, cy;
-        GetClientSize( &cx, &cy);
-
-        double d;
-        d = m_maxX - m_minX;
-        if (d!=0)
-        {
-            m_scaleX = cx/d;
-#ifdef MATHPLOT_DO_LOGGING
-            wxLogMessage(_("mpWindow::Fit() m_scaleX = %f , cx = %d, d = %f"), m_scaleX, cx, d);
-#endif
-            m_posX = m_minX + d/2;
-        }
-        d = m_maxY - m_minY;
-        if (d!=0)
-        {
-            m_scaleY = cy/d;
-            m_posY = m_minY + d/2;
-        }
-
-        if (m_lockaspect)
-        {
-            double s = (m_scaleX + m_scaleY)/2;
-            m_scaleX = s;
-#ifdef MATHPLOT_DO_LOGGING
-            wxLogMessage(_("mpWindow::Fit(lock) m_scaleX = %f"), m_scaleX);
-#endif
-            m_scaleY = s;
-        }
-
-        UpdateAll();
-    }
-}
-
-void mpWindow::ZoomIn()
-{
-    m_scaleX = m_scaleX * 2;
-    m_scaleY = m_scaleY * 2;
-
-#ifdef MATHPLOT_DO_LOGGING
-    wxLogMessage(_("mpWindow::ZoomIn() m_scaleX = %f"), m_scaleX);
-#endif
-
-    UpdateAll();
-
-#ifdef MATHPLOT_DO_LOGGING
-    wxLogMessage(_("mpWindow::ZoomIn() m_scaleX(Updated) = %f"), m_scaleX);
-#endif
-}
-
-void mpWindow::ZoomOut()
-{
-    m_scaleX = m_scaleX / 2;
-    m_scaleY = m_scaleY / 2;
-
-#ifdef MATHPLOT_DO_LOGGING
-    wxLogMessage(_("mpWindow::ZoomOut() m_scaleX = %f"), m_scaleX);
-#endif
-    UpdateAll();
-
-#ifdef MATHPLOT_DO_LOGGING
-    wxLogMessage(_("mpWindow::ZoomOut() m_scaleX(Updated) = %f"), m_scaleX);
-#endif
-}
-
-void mpWindow::LockAspect(bool enable)
-{
-    m_lockaspect = enable;
-
-    m_popmenu.Check(mpID_LOCKASPECT, enable);
-
-    if (m_lockaspect)
-    {
-        double s = (m_scaleX + m_scaleY)/2;
-        m_scaleX = s;
-        m_scaleY = s;
-    }
-
-    UpdateAll();
-}
-
-void mpWindow::OnShowPopupMenu(wxMouseEvent &event)
-{
-    // Only display menu if the user has not "dragged" the figure
-    if (m_enableMouseNavigation)
-    {
-        SetCursor( *wxSTANDARD_CURSOR );
-    }
-
-    if (!m_mouseMovedAfterRightClick)   // JLB
-    {
-        m_clickedX = event.GetX();
-        m_clickedY = event.GetY();
-        PopupMenu( &m_popmenu, event.GetX(), event.GetY());
-    }
-}
-
-void mpWindow::OnLockAspect(wxCommandEvent &event)
-{
-    LockAspect( !m_lockaspect ); //m_popmenu.IsChecked(mpID_LOCKASPECT) );
-}
-
-void mpWindow::OnMouseHelp(wxCommandEvent &event)
-{
-    wxMessageBox(_("Supported Mouse commands:\n \
-        - Mouse Move+CTRL: Pan (Move)\n \
-        - Mouse Wheel: Vertical scroll\n \
-        - Mouse Wheel+SHIFT: Horizontal scroll\n \
-        - Mouse Wheel+CTRL: Zoom in/out"),_("wxMathPlot help"),wxOK,this);
-}
-
-void mpWindow::OnFit(wxCommandEvent &event)
-{
-    Fit();
-}
-
-void mpWindow::OnCenter(wxCommandEvent &event)
-{
-    int cx, cy;
-    GetClientSize(&cx, &cy);
-    SetPos( (double)(m_clickedX-cx/2) / m_scaleX + m_posX, (double)(cy/2-m_clickedY) / m_scaleY + m_posY);
-}
-
-void mpWindow::OnZoomIn(wxCommandEvent &event)
-{
-    int cx, cy;
-    GetClientSize(&cx, &cy);
-    m_posX = (double)(m_clickedX-cx/2) / m_scaleX + m_posX;
-    m_posY = (double)(cy/2-m_clickedY) / m_scaleY + m_posY;
-    ZoomIn();
-}
-
-void mpWindow::OnZoomOut(wxCommandEvent &event)
-{
-    ZoomOut();
-}
-
-void mpWindow::OnSize( wxSizeEvent &event )
-{
-    UpdateAll();
-}
-
-bool mpWindow::AddLayer( mpLayer* layer)
-{
-    if (layer != NULL) {
-    	int layNo = m_layers.size();
-    	m_layers[layNo] = layer;
-    	UpdateAll();
-    	return true;
-    	};
-    return false;
-    // Old version, using wxList
-    /*bool ret = m_layers.Append( layer) != NULL;
-    UpdateAll();
-    return ret;*/
-}
-
-bool mpWindow::DelLayer( mpLayer* layer)
-{
-    //m_layers.DeleteObject( layer);
-    // New version, using wxHashMap, and with layer presence check
-    wxLayerList::iterator layIt;
-    for (layIt = m_layers.begin(); layIt != m_layers.end(); layIt++) {
-    	if (layIt->second == layer) break;
-    	};
-    if (layIt != m_layers.end()) {
-    	m_layers.erase(layIt); // this way only refereice is deleted, layer object still exists!
-    	UpdateAll();
-    	return true;
-    	};
-    return false;
-}
-
-void mpWindow::OnPaint( wxPaintEvent &event )
-{
-    wxPaintDC dc(this);
-    dc.GetSize(&m_scrX, &m_scrY);   // This is the size of the visible area only!
-
-
-#ifdef MATHPLOT_DO_LOGGING
-    {
-        int px, py;
-        GetViewStart( &px, &py );
-        wxLogMessage(_("[mpWindow::OnPaint] vis.area:%ix%i px=%i py=%i"),m_scrX,m_scrY,px,py);
-    }
-#endif
-
-    // Selects direct or buffered draw:
-    wxDC    *trgDc;
-
-    // J.L.Blanco @ Aug 2007: Added double buffer support
-    if (m_enableDoubleBuffer)
-    {
-        if (m_last_lx!=m_scrX || m_last_ly!=m_scrY)
-        {
-            if (m_buff_bmp) delete m_buff_bmp;
-            m_buff_bmp = new wxBitmap(m_scrX,m_scrY);
-            m_buff_dc.SelectObject(*m_buff_bmp);
-            m_last_lx=m_scrX;
-            m_last_ly=m_scrY;
-        }
-        trgDc = &m_buff_dc;
-    }
-    else
-    {
-        trgDc = &dc;
-    }
-
-    // Draw background:
-    trgDc->SetDeviceOrigin(0,0);
-    trgDc->SetPen( *wxTRANSPARENT_PEN );
-    wxBrush brush( GetBackgroundColour() );
-    trgDc->SetBrush( brush );
-    trgDc->DrawRectangle(0,0,m_scrX,m_scrY);
-
-    // Draw all the layers:
-    trgDc->SetDeviceOrigin( m_scrX>>1, m_scrY>>1);  // Origin at the center
-    wxLayerList::iterator li;
-    for (li = m_layers.begin(); li != m_layers.end(); li++)
-    {
-    	mpLayer* f = li->second;
-    	f->Plot(*trgDc, *this);
-    };
-
-    // If doublebuffer, draw now to the window:
-    if (m_enableDoubleBuffer)
-    {
-        trgDc->SetDeviceOrigin(0,0);
-        dc.SetDeviceOrigin(0,0);  // Origin at the center
-        dc.Blit(0,0,m_scrX,m_scrY,trgDc,0,0);
-    }
-}
-
-void mpWindow::OnScroll2(wxScrollWinEvent &event)
-{
-    int width, height;
-    GetClientSize( &width, &height);
-    int px, py;
-    GetViewStart( &px, &py);
-
-    if (event.GetOrientation() == wxHORIZONTAL)
-    {
-        //SetPosX( (double)px / GetScaleX() + m_minX + (double)(width>>1)/GetScaleX());
-        m_posX = m_minX + (double)(px + (width>>1))/GetScaleX();
-    }
-    else
-    {
-        //SetPosY( m_maxY - (double)py / GetScaleY() - (double)(height>>1)/GetScaleY());
-        //m_posY = m_maxY - (double)py / GetScaleY() - (double)(height>>1)/GetScaleY();
-        m_posY = m_maxY - (double)(py + (height>>1))/GetScaleY();
-    }
-
-#ifdef MATHPLOT_DO_LOGGING
-    wxLogMessage(_("[mpWindow::OnScroll2] m_posX=%f m_posY=%f"),m_posX,m_posY);
-#endif
-
-    FitInside();
-    Refresh( FALSE );
-    event.Skip();
-}
-
-bool mpWindow::UpdateBBox()
-{
-    bool first = TRUE;
-
-    for (wxLayerList::iterator li = m_layers.begin(); li != m_layers.end(); li++)
-    {
-        mpLayer* f = li->second;
-
-        if (f->HasBBox())
-        {
-            if (first)
-            {
-                first = FALSE;
-                m_minX = f->GetMinX(); m_maxX=f->GetMaxX();
-                m_minY = f->GetMinY(); m_maxY=f->GetMaxY();
-            }
-            else
-            {
-                if (f->GetMinX()<m_minX) m_minX=f->GetMinX(); if (f->GetMaxX()>m_maxX) m_maxX=f->GetMaxX();
-                if (f->GetMinY()<m_minY) m_minY=f->GetMinY(); if (f->GetMaxY()>m_maxY) m_maxY=f->GetMaxY();
-            }
-        }
-        //node = node->GetNext();
-    }
-
-    return first == FALSE;
-}
-
-void mpWindow::UpdateAll()
-{
-    //printf("placeholder 1\n");
-    bool box = UpdateBBox();
-    //printf("placeholder 3 (Box = %d)\n", (int) box);
-    if (box)
-    {
-        int cx, cy;
-        GetClientSize( &cx, &cy);
-
-        // The "virtual size" of the scrolled window:
-        const int sx = (int)((m_maxX - m_minX) * GetScaleX());
-        const int sy = (int)((m_maxY - m_minY) * GetScaleY());
-
-        const int px = (int)((GetPosX() - m_minX) * GetScaleX() - (cx>>1));
-
-        // J.L.Blanco, Aug 2007: Formula fixed:
-        const int py = (int)((m_maxY - GetPosY()) * GetScaleY() - (cy>>1));
-
-        SetScrollbars( 1, 1, sx, sy, px, py, TRUE);
-
-#ifdef MATHPLOT_DO_LOGGING
-        wxLogMessage(_("[mpWindow::UpdateAll] Size:%ix%i ScrollBars:%i,%i"),sx,sy,px,py);
-#endif
-    }
-
-    FitInside();
-    Refresh( FALSE );
-}
-
-void mpWindow::SetScaleX(double scaleX)
-{
-    if (scaleX!=0) m_scaleX=scaleX;
-    //printf("mpWindow::SetScaleX() m_scaleX = %f, scaleX = %f ", m_scaleX, scaleX);
-    UpdateAll();
-    //printf(" m_scaleX(Updated) = %f\n", m_scaleX);
-}
-
-// New methods implemented by Davide Rondini
-
-unsigned int mpWindow::CountLayers()
-{
-    //wxNode *node = m_layers.GetFirst();
-    unsigned int layerNo = 0;
-    for(wxLayerList::iterator li = m_layers.begin(); li != m_layers.end(); li++)//while(node)
-    	{
-        if (li->second->HasBBox()) layerNo++;
-	// node = node->GetNext();
-    	};
-    return layerNo;
-}
-
-mpLayer* mpWindow::GetLayer(int position)
-{
-    if ((position >= m_layers.size()) || position < 0) return NULL;
-    return m_layers[position];
-}
-
-//-----------------------------------------------------------------------------
-// mpFXYVector implementation - by Jose Luis Blanco (AGO-2007)
-//-----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(mpFXYVector, mpFXY)
-
-// Constructor
-mpFXYVector::mpFXYVector(wxString name, int flags ) : mpFXY(name,flags)
-{
-    m_index = 0;
-    m_minX  = -1;
-    m_maxX  = 1;
-    m_minY  = -1;
-    m_maxY  = 1;
-}
-
-void mpFXYVector::Rewind()
-{
-    m_index = 0;
-}
-
-bool mpFXYVector::GetNextXY(double & x, double & y)
-{
-    if (m_index>=m_xs.size())
-        return FALSE;
-    else
-    {
-        x = m_xs[m_index];
-        y = m_ys[m_index++];
-        return m_index<m_xs.size();
-    }
-}
-
-void mpFXYVector::Clear()
-{
-    m_xs.clear();
-    m_ys.clear();
-}
-
-void mpFXYVector::SetData( const std::vector<float> &xs,const std::vector<float> &ys)
-{
-    // Copy the data:
-    m_xs = xs;
-    m_ys = ys;
-
-
-    // Update internal variables for the bounding box.
-    if (xs.size()>0)
-    {
-        m_minX  = xs[0];
-        m_maxX  = xs[0];
-        m_minY  = ys[0];
-        m_maxY  = ys[0];
-
-        std::vector<float>::const_iterator  it;
-
-        for (it=xs.begin();it!=xs.end();it++)
-        {
-            if (*it<m_minX) m_minX=*it;
-            if (*it>m_maxX) m_maxX=*it;
-        }
-        for (it=ys.begin();it!=ys.end();it++)
-        {
-            if (*it<m_minY) m_minY=*it;
-            if (*it>m_maxY) m_maxY=*it;
-        }
-        m_minX-=0.5f;
-        m_minY-=0.5f;
-        m_maxX+=0.5f;
-        m_maxY+=0.5f;
-    }
-    else
-    {
-        m_minX  = -1;
-        m_maxX  = 1;
-        m_minY  = -1;
-        m_maxY  = 1;
-    }
-}
-
-//-----------------------------------------------------------------------------
-// mpText - provided by Val Greene
-//-----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(mpText, mpLayer)
-
-
-/** @param name text to be displayed
-@param offsetx x position in percentage (0-100)
-@param offsetx y position in percentage (0-100)
-*/
-mpText::mpText( wxString name, int offsetx, int offsety )
-{
-    SetName(name);
-
-    if (offsetx >= 0 && offsetx <= 100)
-        m_offsetx = offsetx;
-    else
-        m_offsetx = 5;
-
-    if (offsety >= 0 && offsety <= 100)
-        m_offsety = offsety;
-    else
-        m_offsetx = 50;
-}
-
-/** mpText Layer plot handler.
-This implementation will plot the text adjusted to the visible area.
-*/
-
-void mpText::Plot(wxDC & dc, mpWindow & w)
-{
-    dc.SetPen(m_pen);
-    dc.SetFont(m_font);
-    dc.SetTextForeground(m_pen.GetColour());
-
-
-    wxCoord tw=0, th=0;
-    dc.GetTextExtent( GetName(), &tw, &th);
-
-    int left = -dc.LogicalToDeviceX(0);
-    int width = dc.LogicalToDeviceX(0) - left;
-    int bottom = dc.LogicalToDeviceY(0);
-    int height = bottom - -dc.LogicalToDeviceY(0);
-
-    dc.DrawText( GetName(),
-    (int)((((float)width/100.0) * m_offsety) + left - (tw/2)),
-    (int)((((float)height/100.0) * m_offsetx) - bottom) );
-}
Index: src/plugins/contrib/wxSmithPlot/mathplot.h
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/mathplot.h b/trunk/src/plugins/contrib/wxSmithPlot/mathplot.h
deleted file mode 10644
--- a/trunk/src/plugins/contrib/wxSmithPlot/mathplot.h	(révision 10042)
+++ /dev/null	(copie de travail)
@@ -1,875 +0,0 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:            mathplot.cpp
-// Purpose:         Framework for plotting in wxWindows
-// Original Author: David Schalig
-// Maintainer:      Davide Rondini
-// Contributors:    Jose Luis Blanco, Val Greene
-// Created:         21/07/2003
-// Last edit:       09/09/2007
-// Copyright:       (c) David Schalig, Davide Rondini
-// Licence:         wxWindows licence
-/////////////////////////////////////////////////////////////////////////////
-
-#ifndef _MP_MATHPLOT_H_
-#define _MP_MATHPLOT_H_
-
-/** @file mathplot.h */
-/** @mainpage wxMathPlot
-    wxMathPlot is a framework for mathematical graph plotting in wxWindows.
-
-    The framework is designed for convenience and ease of use.
-
-    @section screenshots Screenshots
-    <a href="screenshots.html">Go to the screenshots page.</a>
-
-    @section overview Overview
-    The heart of wxMathPlot is mpWindow, which is a 2D canvas for plot layers.
-    mpWindow can be embedded as subwindow in a wxPane, a wxFrame, or any other wxWindow.
-    mpWindow provides a zoomable and moveable view of the layers. The current view can
-    be controlled with the mouse, the scrollbars, and a context menu.
-
-    Plot layers are implementations of the abstract base class mpLayer. Those can
-    be function plots, scale rulers, or any other vector data visualisation. wxMathPlot provides two mpLayer implementations for plotting horizontal and vertical rulers: mpScaleX and mpScaleY.
-    For convenient function plotting three more abstract base classes derived from mpLayer are provided: mpFX, mpFY and mpFXY. These base classes already come with plot code, own functions can be implemented by overiding just one member for retrieving a function value.
-    Another class, mpFXYVector, is provided since version 0.03. This non-virtual class
-    renders 2D graphs from a pair of std::vector's. One of the utility of this class is that you can use it directly in GUI designers such as wxSmith within Code::Blocks.
-
-    From version 0.03, the mpWindow has built-in support for mouse-based pan and zoom through intuitive combinations of buttons and the mouse wheel. It also incorporate an optional double buffering mechanism to avoid flicker.
-
-    @section coding Coding conventions
-    wxMathPlot sticks to wxWindow's coding conventions. All entities defined by wxMathPlot
-    have the prefix <i>mp</i>.
-
-    @section author Author and license
-    wxMathPlot is published under the terms of the wxWindow license.
-    The original author is David Schalig <mrhill@users.sourceforge.net>.
-    From June 2007 the project is maintained by Davide Rondini. <cdron@users.sourceforge.net>.
-    Authors can be contacted via the wxMathPlot's homepage at
-    http://sourceforge.net/projects/wxmathplot.
-    Contributors:
-    Jose Luis Blanco <jlblanco@ctima.uma.es>, Val Greene.
-*/
-
-#if defined(__GNUG__) && !defined(__APPLE__)
-#pragma interface "mathplot.h"
-#endif
-
-#include <vector>
-
-#include "wx/defs.h"
-#include "wx/menu.h"
-#include "wx/scrolwin.h"
-#include "wx/event.h"
-#include "wx/dynarray.h"
-#include "wx/pen.h"
-#include "wx/dcmemory.h"
-
-
-//-----------------------------------------------------------------------------
-// we do not always want to use a DLL
-
-#ifndef     BUILD_MATHPLOT_DLL
-#ifdef      WXDLLEXPORT
-#undef      WXDLLEXPORT
-#endif
-
-#define     WXDLLEXPORT
-#endif
-
-
-
-
-//-----------------------------------------------------------------------------
-// classes
-//-----------------------------------------------------------------------------
-
-class WXDLLEXPORT mpLayer;
-class WXDLLEXPORT mpFX;
-class WXDLLEXPORT mpFY;
-class WXDLLEXPORT mpFXY;
-class WXDLLEXPORT mpFXYVector;
-class WXDLLEXPORT mpScaleX;
-class WXDLLEXPORT mpScaleY;
-class WXDLLEXPORT mpWindow;
-class WXDLLEXPORT mpText;
-
-/** Command IDs used by mpWindow */
-enum
-{
-    mpID_FIT = 2000,    //!< Fit view to match bounding box of all layers
-    mpID_ZOOM_IN,       //!< Zoom into view at clickposition / window center
-    mpID_ZOOM_OUT,      //!< Zoom out
-    mpID_CENTER,        //!< Center view on click position
-    mpID_LOCKASPECT,    //!< Lock x/y scaling aspect
-    mpID_HELP_MOUSE,    //!< Shows information about the mouse commands
-};
-
-//-----------------------------------------------------------------------------
-// mpLayer
-//-----------------------------------------------------------------------------
-
-/** Plot layer, abstract base class.
-    Any number of mpLayer implementations can be attached to mpWindow.
-    Examples for mpLayer implementations are function graphs, or scale rulers.
-
-    For convenience mpLayer defines a name, a font (wxFont), a pen (wxPen),
-    and a continuity property (bool) as class members.
-    The default values at constructor are the default font, a black pen, and
-     continuity set to false (draw separate points).
-    These may or may not be used by implementations.
-*/
-class WXDLLEXPORT mpLayer : public wxObject
-{
-public:
-    mpLayer();
-
-    virtual ~mpLayer() {};
-
-    /** Check whether this layer has a bounding box.
-        The default implementation returns \a TRUE. Overide and return
-        FALSE if your mpLayer implementation should be ignored by the calculation
-        of the global bounding box for all layers in a mpWindow.
-        @retval TRUE Has bounding box
-        @retval FALSE Has not bounding box
-    */
-    virtual bool   HasBBox() { return TRUE; }
-
-    /** Get inclusive left border of bounding box.
-        @return Value
-    */
-    virtual double GetMinX() { return -1.0; }
-
-    /** Get inclusive right border of bounding box.
-        @return Value
-    */
-    virtual double GetMaxX() { return  1.0; }
-
-    /** Get inclusive bottom border of bounding box.
-        @return Value
-    */
-    virtual double GetMinY() { return -1.0; }
-
-    /** Get inclusive top border of bounding box.
-        @return Value
-    */
-    virtual double GetMaxY() { return  1.0; }
-
-    /** Plot given view of layer to the given device context.
-        An implementation of this function has to transform layer coordinates to
-        wxDC coordinates based on the view parameters retrievable from the mpWindow
-        passed in \a w. The passed device context \a dc has its coordinate origin set
-        to the center of the visible area. The coordinate orientation is as show in the
-        following picture:
-        <pre>
-        +--------------------------------------------------+
-        |                                                  |
-        |                                                  |
-        |                (wxDC origin 0,0)                 |
-        |                       x-------------> acending X |
-        |                       |                          |
-        |                       |                          |
-        |                       V ascending Y              |
-        +--------------------------------------------------+
-        </pre>
-        Note that Y ascends in downward direction, whereas the usual vertical orientation
-        for mathematical plots is vice versa. Thus Y-orientation will be swapped usually,
-        when transforming between wxDC and mpLayer coordinates.
-
-        <b> Rules for transformation between mpLayer and wxDC coordinates </b>
-        @code
-        dc_X = (layer_X - mpWindow::GetPosX()) * mpWindow::GetScaleX()
-        dc_Y = (mpWindow::GetPosY() - layer_Y) * mpWindow::GetScaleY() // swapping Y-orientation
-
-        layer_X = (dc_X / mpWindow::GetScaleX()) + mpWindow::GetPosX() // scale guaranted to be not 0
-        layer_Y = mpWindow::GetPosY() - (dc_Y / mpWindow::GetScaleY()) // swapping Y-orientation
-        @endcode
-
-        @param dc Device context to plot to.
-        @param w  View to plot. The visible area can be retrieved from this object.
-    */
-    virtual void   Plot(wxDC & dc, mpWindow & w) = 0;
-
-    /** Get layer name.
-        @return Name
-    */
-    wxString       GetName() const { return m_name; }
-
-    /** Get font set for this layer.
-        @return Font
-    */
-    const wxFont&  GetFont() const { return m_font; }
-
-    /** Get pen set for this layer.
-        @return Pen
-    */
-    const wxPen&   GetPen()  const { return m_pen;  }
-
-    /** Set the 'continuity' property of the layer (true:draws a continuous line, false:draws separate points).
-      * \sa GetContinuity
-      */
-    void SetContinuity(bool continuity) {m_continuous = continuity;}
-
-    /** Gets the 'continuity' property of the layer.
-      * \sa SetContinuity
-      */
-    bool GetContinuity() const {return m_continuous;}
-
-    /** Set layer name
-        @param name Name, will be copied to internal class member
-    */
-    void SetName(wxString name) { m_name = name; }
-
-    /** Set layer font
-        @param font Font, will be copied to internal class member
-    */
-    void SetFont(wxFont& font)  { m_font = font; }
-
-    /** Set layer pen
-        @param pen Pen, will be copied to internal class member
-    */
-    void SetPen(wxPen& pen)     { m_pen  = pen;  }
-
-protected:
-    wxFont   m_font;    //!< Layer's font
-    wxPen    m_pen;     //!< Layer's pen
-    wxString m_name;    //!< Layer's name
-    bool     m_continuous; //!< Specify if the layer will be plotted as a continuous line or a set of points.
-
-    DECLARE_CLASS(mpLayer)
-};
-
-//-----------------------------------------------------------------------------
-// mpLayer implementations - functions
-//-----------------------------------------------------------------------------
-
-/** @name Label alignment constants
-@{*/
-
-/** @internal */
-#define mpALIGNMASK    0x03
-/** Aligns label to the right. For use with mpFX. */
-#define mpALIGN_RIGHT  0x00
-/** Aligns label to the center. For use with mpFX and mpFY. */
-#define mpALIGN_CENTER 0x01
-/** Aligns label to the left. For use with mpFX. */
-#define mpALIGN_LEFT   0x02
-/** Aligns label to the top. For use with mpFY. */
-#define mpALIGN_TOP    mpALIGN_RIGHT
-/** Aligns label to the bottom. For use with mpFY. */
-#define mpALIGN_BOTTOM mpALIGN_LEFT
-/** Aligns X axis to bottom border. For mpScaleX */
-#define mpALIGN_BORDER_BOTTOM  0x04
-/** Aligns X axis to top border. For mpScaleX */
-#define mpALIGN_BORDER_TOP  0x05
-/** Aligns Y axis to left border. For mpScaleY */
-#define mpALIGN_BORDER_LEFT mpALIGN_BORDER_BOTTOM
-/** Aligns Y axis to right border. For mpScaleY */
-#define mpALIGN_BORDER_RIGHT mpALIGN_BORDER_TOP
-/** Aligns label to north-east. For use with mpFXY. */
-#define mpALIGN_NE     0x00
-/** Aligns label to north-west. For use with mpFXY. */
-#define mpALIGN_NW     0x01
-/** Aligns label to south-west. For use with mpFXY. */
-#define mpALIGN_SW     0x02
-/** Aligns label to south-east. For use with mpFXY. */
-#define mpALIGN_SE     0x03
-
-/*@}*/
-
-/** @name mpLayer implementations - functions
-@{*/
-
-/** Abstract base class providing plot and labeling functionality for functions F:X->Y.
-    Override mpFX::GetY to implement a function.
-    Optionally implement a constructor and pass a name (label) and a label alignment
-    to the constructor mpFX::mpFX. If the layer name is empty, no label will be plotted.
-*/
-class WXDLLEXPORT mpFX : public mpLayer
-{
-public:
-    /** @param name  Label
-        @param flags Label alignment, pass one of #mpALIGN_RIGHT, #mpALIGN_CENTER, #mpALIGN_LEFT.
-    */
-    mpFX(wxString name = wxEmptyString, int flags = mpALIGN_RIGHT);
-
-    /** Get function value for argument.
-        Override this function in your implementation.
-        @param x Argument
-        @return Function value
-    */
-    virtual double GetY( double x ) = 0;
-
-    /** Layer plot handler.
-        This implementation will plot the function in the visible area and
-        put a label according to the aligment specified.
-    */
-    virtual void Plot(wxDC & dc, mpWindow & w);
-
-protected:
-    int m_flags; //!< Holds label alignment
-
-    DECLARE_CLASS(mpFX)
-};
-
-/** Abstract base class providing plot and labeling functionality for functions F:Y->X.
-    Override mpFY::GetX to implement a function.
-    Optionally implement a constructor and pass a name (label) and a label alignment
-    to the constructor mpFY::mpFY. If the layer name is empty, no label will be plotted.
-*/
-class WXDLLEXPORT mpFY : public mpLayer
-{
-public:
-    /** @param name  Label
-        @param flags Label alignment, pass one of #mpALIGN_BOTTOM, #mpALIGN_CENTER, #mpALIGN_TOP.
-    */
-    mpFY(wxString name = wxEmptyString, int flags = mpALIGN_TOP);
-
-    /** Get function value for argument.
-        Override this function in your implementation.
-        @param y Argument
-        @return Function value
-    */
-    virtual double GetX( double y ) = 0;
-
-    /** Layer plot handler.
-        This implementation will plot the function in the visible area and
-        put a label according to the aligment specified.
-    */
-    virtual void Plot(wxDC & dc, mpWindow & w);
-
-protected:
-    int m_flags; //!< Holds label alignment
-
-    DECLARE_CLASS(mpFY)
-};
-
-/** Abstract base class providing plot and labeling functionality for a locus plot F:N->X,Y.
-    Locus argument N is assumed to be in range 0 .. MAX_N, and implicitely derived by enumrating
-    all locus values. Override mpFXY::Rewind and mpFXY::GetNextXY to implement a locus.
-    Optionally implement a constructor and pass a name (label) and a label alignment
-    to the constructor mpFXY::mpFXY. If the layer name is empty, no label will be plotted.
-*/
-class WXDLLEXPORT mpFXY : public mpLayer
-{
-public:
-    /** @param name  Label
-        @param flags Label alignment, pass one of #mpALIGN_NE, #mpALIGN_NW, #mpALIGN_SW, #mpALIGN_SE.
-    */
-    mpFXY(wxString name = wxEmptyString, int flags = mpALIGN_NE);
-
-    /** Rewind value enumeration with mpFXY::GetNextXY.
-        Override this function in your implementation.
-    */
-    virtual void Rewind() = 0;
-
-    /** Get locus value for next N.
-        Override this function in your implementation.
-        @param x Returns X value
-        @param y Returns Y value
-    */
-    virtual bool GetNextXY(double & x, double & y) = 0;
-
-    /** Layer plot handler.
-        This implementation will plot the locus in the visible area and
-        put a label according to the aligment specified.
-    */
-    virtual void Plot(wxDC & dc, mpWindow & w);
-
-protected:
-    int m_flags; //!< Holds label alignment
-
-    DECLARE_CLASS(mpFXY)
-};
-
-/** Abstract base class providing plot and labeling functionality for functions F:Y->X.
-    Override mpProfile::GetX to implement a function.
-    This class if similar to mpFY, but the Plot method is different. The plot is in fact represented by lines instead of points, which gives best rendering of rapidly-varying functions, and in general, data which are not so close one to another.
-    Optionally implement a constructor and pass a name (label) and a label alignment
-    to the constructor mpProfile::mpProfile. If the layer name is empty, no label will be plotted.
-*/
-class WXDLLEXPORT mpProfile : public mpLayer
-{
-public:
-    /** @param name  Label
-        @param flags Label alignment, pass one of #mpALIGN_BOTTOM, #mpALIGN_CENTER, #mpALIGN_TOP.
-    */
-    mpProfile(wxString name = wxEmptyString, int flags = mpALIGN_TOP);
-
-    /** Get function value for argument.
-        Override this function in your implementation.
-        @param x Argument
-        @return Function value
-    */
-    virtual double GetY( double x ) = 0;
-
-    /** Layer plot handler.
-        This implementation will plot the function in the visible area and
-        put a label according to the aligment specified.
-    */
-    virtual void Plot(wxDC & dc, mpWindow & w);
-
-protected:
-    int m_flags; //!< Holds label alignment
-
-    DECLARE_CLASS(mpProfile)
-};
-
-/*@}*/
-
-//-----------------------------------------------------------------------------
-// mpLayer implementations - furniture (scales, ...)
-//-----------------------------------------------------------------------------
-
-/** @name mpLayer implementations - furniture (scales, ...)
-@{*/
-
-/** Plot layer implementing a x-scale ruler.
-    The ruler is fixed at Y=0 in the coordinate system. A label is plotted at
-    the bottom-right hand of the ruler. The scale numbering automatically
-    adjusts to view and zoom factor.
-*/
-class WXDLLEXPORT mpScaleX : public mpLayer
-{
-public:
-    /** @param name Label to plot by the ruler
-        @param flags Set position of the scale respect to the window.
-        @param ticks Select ticks or grid. Give TRUE for drawing axis ticks, FALSe for drawing the grid */
-    mpScaleX(wxString name = wxT("X"), int flags = mpALIGN_CENTER, bool ticks = true);
-
-    /** Layer plot handler.
-        This implementation will plot the ruler adjusted to the visible area.
-    */
-    virtual void Plot(wxDC & dc, mpWindow & w);
-
-    /** Check whether this layer has a bounding box.
-        This implementation returns \a FALSE thus making the ruler invisible
-        to the plot layer bounding box calculation by mpWindow.
-    */
-    virtual bool HasBBox() { return FALSE; }
-
-    /** Set X axis alignment.
-        @param align alignment (choose between mpALIGN_BORDER_BOTTOM, mpALIGN_BOTTOM, mpALIGN_CENTER, mpALIGN_TOP, mpALIGN_BORDER_TOP */
-    void SetAlign(int align) { m_flags = align; };
-
-    /** Set X axis ticks or grid
-        @param ticks TRUE to plot axis ticks, FALSE to plot grid. */
-    void SetTicks(bool ticks) { m_ticks = ticks; };
-
-    /** Get X axis ticks or grid
-        @return TRUE if plot is drawing axis ticks, FALSE if the grid is active. */
-    bool GetTicks() { return m_ticks; };
-
-protected:
-    int m_flags; //!< Flag for axis alignment
-    bool m_ticks; //!< Flag to toggle between ticks or grid
-
-    DECLARE_CLASS(mpScaleX)
-};
-
-/** Plot layer implementing a y-scale ruler.
-    If align is set to mpALIGN_CENTER, the ruler is fixed at X=0 in the coordinate system. If the align is set to mpALIGN_TOP or mpALIGN_BOTTOM, the axis is always drawn respectively at top or bottom of the window. A label is plotted at
-    the top-right hand of the ruler. The scale numbering automatically
-    adjusts to view and zoom factor.
-*/
-class WXDLLEXPORT mpScaleY : public mpLayer
-{
-public:
-    /** @param name Label to plot by the ruler
-        @param flags Set position of the scale respect to the window.
-        @param ticks Select ticks or grid. Give TRUE for drawing axis ticks, FALSe for drawing the grid */
-    mpScaleY(wxString name = wxT("Y"), int flags = mpALIGN_CENTER, bool ticks = true);
-
-    /** Layer plot handler.
-        This implementation will plot the ruler adjusted to the visible area.
-    */
-    virtual void Plot(wxDC & dc, mpWindow & w);
-
-    /** Check whether this layer has a bounding box.
-        This implementation returns \a FALSE thus making the ruler invisible
-        to the plot layer bounding box calculation by mpWindow.
-    */
-    virtual bool HasBBox() { return FALSE; }
-
-    /** Set Y axis alignment.
-        @param align alignment (choose between mpALIGN_BORDER_LEFT, mpALIGN_LEFT, mpALIGN_CENTER, mpALIGN_RIGHT, mpALIGN_BORDER_RIGHT) */
-    void SetAlign(int align) { m_flags = align; };
-
-    /** Set Y axis ticks or grid
-        @param ticks TRUE to plot axis ticks, FALSE to plot grid. */
-    void SetTicks(bool ticks) { m_ticks = ticks; };
-
-    /** Get Y axis ticks or grid
-        @return TRUE if plot is drawing axis ticks, FALSE if the grid is active. */
-    bool GetTicks() { return m_ticks; };
-
-protected:
-    int m_flags; //!< Flag for axis alignment
-    bool m_ticks; //!< Flag to toggle between ticks or grid
-
-    DECLARE_CLASS(mpScaleY)
-};
-
-//-----------------------------------------------------------------------------
-// mpWindow
-//-----------------------------------------------------------------------------
-
-/** @name Constants defining mouse modes for mpWindow
-@{*/
-
-/** Mouse panning drags the view. Mouse mode for mpWindow. */
-#define mpMOUSEMODE_DRAG    0
-/** Mouse panning creates a zoom box. Mouse mode for mpWindow. */
-#define mpMOUSEMODE_ZOOMBOX 1
-
-/*@}*/
-/** Define the hash map for managing the layer list inside mpWindow */
-WX_DECLARE_HASH_MAP( int, mpLayer*, wxIntegerHash, wxIntegerEqual, wxLayerList );
-
-/** Canvas for plotting mpLayer implementations.
-
-    This class defines a zoomable and moveable 2D plot canvas. Any number
-    of mpLayer implementations (scale rulers, function plots, ...) can be
-    attached using mpWindow::AddLayer.
-
-    The canvas window provides a context menu with actions for navigating the view.
-    The context menu can be retrieved with mpWindow::GetPopupMenu, e.g. for extending it
-    externally.
-
-    Since wxMathPlot version 0.03, the mpWindow incorporate the following features:
-        - DoubleBuffering (Default=disabled): Can be set with EnableDoubleBuffer
-        - Mouse based pan/zoom (Default=enable): Can be set with EnableMousePanZoom.
-
-    The mouse commands can be visualized by the user through the popup menu, and are:
-        - Mouse Move+CTRL: Pan (Move)
-        - Mouse Wheel: Vertical scroll
-        - Mouse Wheel+SHIFT: Horizontal scroll
-        - Mouse Wheel UP+CTRL: Zoom in
-        - Mouse Wheel DOWN+CTRL: Zoom out
-
-*/
-class WXDLLEXPORT mpWindow : public wxScrolledWindow
-{
-public:
-    mpWindow() {}
-    mpWindow( wxWindow *parent, wxWindowID id,
-                     const wxPoint &pos = wxDefaultPosition,
-                     const wxSize &size = wxDefaultSize,
-                     int flags = 0);
-    ~mpWindow();
-
-    /** Get reference to context menu of the plot canvas.
-        @return Pointer to menu. The menu can be modified.
-    */
-    wxMenu* GetPopupMenu() { return &m_popmenu; }
-
-    /** Add a plot layer to the canvas.
-        @param layer Pointer to layer. The mpLayer object will get under control of mpWindow,
-                     i.e. it will be delete'd on mpWindow destruction
-        @retval TRUE Success
-        @retval FALSE Failure due to out of memory.
-    */
-    bool AddLayer( mpLayer* layer);
-
-    /** Remove a plot layer from the canvas.
-        @param layer Pointer to layer. The mpLayer object will be destructed using delete.
-        @return true if layer is deleted correctly
-
-        N.B. Only the layer reference in the mpWindow is deleted, the layer object still exists!
-    */
-    bool DelLayer( mpLayer* layer);
-
-    /*! Get the layer in list position indicated.
-        N.B. You <i>must</i> know the index of the layer inside the list!
-        @param position position of the layer in the layers list
-        @return pointer to mpLayer
-    */
-    mpLayer* GetLayer(int position);
-
-
-    /** Get current view's X scale.
-        See @ref mpLayer::Plot "rules for coordinate transformation"
-        @return Scale
-    */
-    double GetXscl() { return m_scaleX; }
-    double GetScaleX(void) const{ return m_scaleX; }; // Schaling's method: maybe another method esists with the same name
-
-    /** Get current view's Y scale.
-        See @ref mpLayer::Plot "rules for coordinate transformation"
-        @return Scale
-    */
-    double GetYscl() const { return m_scaleY; }
-    double GetScaleY(void) const { return m_scaleY; } // Schaling's method: maybe another method esists with the same name
-
-    /** Get current view's X position.
-        See @ref mpLayer::Plot "rules for coordinate transformation"
-        @return X Position in layer coordinate system, that corresponds to the center point of the view.
-    */
-    double GetXpos() const { return m_posX; }
-    double GetPosX(void) const { return m_posX; }
-
-    /** Get current view's Y position.
-        See @ref mpLayer::Plot "rules for coordinate transformation"
-        @return Y Position in layer coordinate system, that corresponds to the center point of the view.
-    */
-    double GetYpos() const { return m_posY; }
-    double GetPosY(void) const { return m_posY; }
-
-    /** Get current view's X dimension in device context units.
-        Usually this is equal to wxDC::GetSize, but it might differ thus mpLayer
-        implementations should rely on the value returned by the function.
-        See @ref mpLayer::Plot "rules for coordinate transformation"
-        @return X dimension.
-    */
-    int GetScrX(void) const { return m_scrX; }
-
-    /** Get current view's Y dimension in device context units.
-        Usually this is equal to wxDC::GetSize, but it might differ thus mpLayer
-        implementations should rely on the value returned by the function.
-        See @ref mpLayer::Plot "rules for coordinate transformation"
-        @return Y dimension.
-    */
-    int GetScrY(void) const { return m_scrY; }
-
-    /** Set current view's X scale and refresh display.
-        @param scaleX New scale, must not be 0.
-    */
-    void SetScaleX(double scaleX);
-
-    /** Set current view's Y scale and refresh display.
-        @param scaleY New scale, must not be 0.
-    */
-    void SetScaleY(double scaleY) { if (scaleY!=0) m_scaleY=scaleY; UpdateAll(); }
-
-    /** Set current view's X position and refresh display.
-        @param posX New position that corresponds to the center point of the view.
-    */
-    void SetPosX(double posX) { m_posX=posX; UpdateAll(); }
-
-    /** Set current view's Y position and refresh display.
-        @param posY New position that corresponds to the center point of the view.
-    */
-    void SetPosY(double posY) { m_posY=posY; UpdateAll(); }
-
-    /** Set current view's X and Y position and refresh display.
-        @param posX New position that corresponds to the center point of the view.
-        @param posY New position that corresponds to the center point of the view.
-    */
-    void SetPos( double posX, double posY) { m_posX=posX; m_posY=posY; UpdateAll(); }
-
-    /** Enable/disable the double-buffering of the window, eliminating the flicker (default=disabled).
-     */
-    void EnableDoubleBuffer( bool enabled ) { m_enableDoubleBuffer = enabled; }
-
-    /** Enable/disable the feature of pan/zoom with the mouse (default=enabled)
-     */
-    void EnableMousePanZoom( bool enabled ) { m_enableMouseNavigation = enabled; }
-
-    /** Enable or disable X/Y scale aspect locking for the view.
-        @note Explicit calls to mpWindow::SetScaleX and mpWindow::SetScaleY will set
-              an unlocked apect, but any other action changing the view scale will
-              lock the aspect again.
-    */
-    void LockAspect(bool enable = TRUE);
-
-    /** Checks whether the X/Y scale aspect is locked.
-        @retval TRUE Locked
-        @retval FALSE Unlocked
-    */
-    inline bool IsAspectLocked() { return m_lockaspect; }
-
-    /** Set view to fit global bounding box of all plot layers and refresh display.
-        Scale and position will be set to a show all attached mpLayers.
-        The X/Y scale aspect lock is taken into account.
-    */
-    void Fit();
-
-    /** Zoom into current view and refresh display */
-    void ZoomIn();
-
-    /** Zoom out current view and refresh display */
-    void ZoomOut();
-
-    /** Refresh display */
-    void UpdateAll();
-
-    // Added methods by Davide Rondini
-
-    /** Counts the number of plot layers, axis excluded.
-    	\return The number of profiles plotted.
-    */
-    unsigned int CountLayers();
-
-protected:
-    void OnPaint         (wxPaintEvent     &event); //!< Paint handler, will plot all attached layers
-    void OnSize          (wxSizeEvent      &event); //!< Size handler, will update scroll bar sizes
-    void OnScroll2       (wxScrollWinEvent &event); //!< Scroll handler, will move canvas
-    void OnShowPopupMenu (wxMouseEvent     &event); //!< Mouse handler, will show context menu
-    void OnMouseRightDown(wxMouseEvent     &event); //!< Mouse handler, for detecting when the user drag with the right button or just "clicks" for the menu
-    void OnCenter        (wxCommandEvent   &event); //!< Context menu handler
-    void OnFit           (wxCommandEvent   &event); //!< Context menu handler
-    void OnZoomIn        (wxCommandEvent   &event); //!< Context menu handler
-    void OnZoomOut       (wxCommandEvent   &event); //!< Context menu handler
-    void OnLockAspect    (wxCommandEvent   &event); //!< Context menu handler
-    void OnMouseHelp     (wxCommandEvent   &event); //!< Context menu handler
-    void OnMouseWheel    (wxMouseEvent     &event); //!< Mouse handler for the wheel
-    void OnMouseMove     (wxMouseEvent     &event); //!< Mouse handler for mouse motion (for pan)
-
-    /** Recalculate global layer bounding box, and save it in m_minX,...
-      * \return true if there is any valid BBox information.
-      */
-    bool UpdateBBox(); //!<
-
-    //wxList m_layers;    //!< List of attached plot layers
-    wxLayerList m_layers; //!< List of attached plot layers
-    wxMenu m_popmenu;   //!< Canvas' context menu
-    bool   m_lockaspect;//!< Scale aspect is locked or not
-
-    double m_minX;      //!< Global layer bounding box, left border incl.
-    double m_maxX;      //!< Global layer bounding box, right border incl.
-    double m_minY;      //!< Global layer bounding box, bottom border incl.
-    double m_maxY;      //!< Global layer bounding box, top border incl.
-    double m_scaleX;    //!< Current view's X scale
-    double m_scaleY;    //!< Current view's Y scale
-    double m_posX;      //!< Current view's X position
-    double m_posY;      //!< Current view's Y position
-    int    m_scrX;      //!< Current view's X dimension
-    int    m_scrY;      //!< Current view's Y dimension
-    int    m_clickedX;  //!< Last mouse click X position, for centering and zooming the view
-    int    m_clickedY;  //!< Last mouse click Y position, for centering and zooming the view
-
-    int          m_last_lx,m_last_ly;   //!< For double buffering
-    wxMemoryDC   m_buff_dc;             //!< For double buffering
-    wxBitmap     *m_buff_bmp;            //!< For double buffering
-    bool          m_enableDoubleBuffer;  //!< For double buffering
-    bool          m_enableMouseNavigation;  //!< For pan/zoom with the mouse.
-    bool          m_mouseMovedAfterRightClick;
-    long          m_mouseRClick_X,m_mouseRClick_Y; //!< For the right button "drag" feature
-
-    DECLARE_CLASS(mpWindow)
-    DECLARE_EVENT_TABLE()
-};
-
-//-----------------------------------------------------------------------------
-// mpFXYVector - provided by Jose Luis Blanco
-//-----------------------------------------------------------------------------
-
-/** A class providing graphs functionality for a 2D plot (either continuous or a set of points), from vectors of data.
-     This class can be used directly, the user does not need to derive any new class. Simply pass the data as two vectors
-     with the same length containing the X and Y coordinates to the method SetData.
-
-     To generate a graph with a set of points, call
-     \code
-     layerVar->SetContinuity(false)
-     \endcode
-
-     or
-
-     \code
-     layerVar->SetContinuity(true)
-     \endcode
-
-     to render the sequence of coordinates as a continuous line.
-
-     (Added: Jose Luis Blanco, AGO-2007)
-*/
-class WXDLLEXPORT mpFXYVector : public mpFXY
-{
-public:
-    /** @param name  Label
-        @param flags Label alignment, pass one of #mpALIGN_NE, #mpALIGN_NW, #mpALIGN_SW, #mpALIGN_SE.
-    */
-    mpFXYVector(wxString name = wxEmptyString, int flags = mpALIGN_NE);
-
-    /** Changes the internal data: the set of points to draw.
-        Both vectors MUST be of the same length. This method DOES NOT refresh the mpWindow, do it manually.
-      * \sa Clear
-    */
-    void SetData( const std::vector<float> &xs,const std::vector<float> &ys);
-
-    /** Clears all the data, leaving the layer empty.
-      * \sa SetData
-      */
-    void Clear();
-
-protected:
-    /** The internal copy of the set of data to draw.
-      */
-    std::vector<float>  m_xs,m_ys;
-
-    /** The internal counter for the "GetNextXY" interface
-      */
-    size_t              m_index;
-
-    /** Loaded at SetData
-      */
-    double              m_minX,m_maxX,m_minY,m_maxY;
-
-    /** Rewind value enumeration with mpFXY::GetNextXY.
-        Overrided in this implementation.
-    */
-    void Rewind();
-
-    /** Get locus value for next N.
-        Overrided in this implementation.
-        @param x Returns X value
-        @param y Returns Y value
-    */
-    bool GetNextXY(double & x, double & y);
-
-    /** Returns the actual minimum X data (loaded in SetData).
-      */
-    double GetMinX() { return m_minX; }
-
-    /** Returns the actual minimum Y data (loaded in SetData).
-      */
-    double GetMinY() { return m_minY; }
-
-    /** Returns the actual maximum X data (loaded in SetData).
-      */
-    double GetMaxX() { return m_maxX; }
-
-    /** Returns the actual maximum  Y data (loaded in SetData).
-      */
-    double GetMaxY() { return m_maxY; }
-
-    int     m_flags; //!< Holds label alignment
-
-    DECLARE_CLASS(mpFXYVector)
-};
-
-//-----------------------------------------------------------------------------
-// mpText - provided by Val Greene
-//-----------------------------------------------------------------------------
-
-/** Plot layer implementing a text string.
-The text is plotted using a percentage system 0-100%, so the actual
-coordinates for the location are not required, and the text stays
-on the plot reguardless of the other layers location and scaling
-factors.
-*/
-class WXDLLEXPORT mpText : public mpLayer
-{
-public:
-    /** @param name text to be drawn in the plot
-        @param offsetx holds offset for the X location in percentage (0-100)
-        @param offsety holds offset for the Y location in percentage (0-100) */
-    mpText(wxString name = wxT("Title"), int offsetx = 5, int offsety = 50);
-
-    /** Text Layer plot handler.
-        This implementation will plot text adjusted to the visible area. */
-    virtual void Plot(wxDC & dc, mpWindow & w);
-
-    /** mpText should not be used for scaling decisions. */
-    virtual bool HasBBox() { return FALSE; }
-
-protected:
-    int m_offsetx; //!< Holds offset for X in percentage
-    int m_offsety; //!< Holds offset for Y in percentage
-
-    DECLARE_CLASS(mpText)
-};
-
-
-/*@}*/
-
-#endif // _MP_MATHPLOT_H_
Index: src/plugins/contrib/wxSmithPlot/mpMarker.cpp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/mpMarker.cpp b/trunk/src/plugins/contrib/wxSmithPlot/mpMarker.cpp
deleted file mode 10644
--- a/trunk/src/plugins/contrib/wxSmithPlot/mpMarker.cpp	(révision 10042)
+++ /dev/null	(copie de travail)
@@ -1,54 +0,0 @@
-
-#include "mpMarker.h"
-
-
-//-----------------------------------------------------------------------------
-// mpText - provided by Val Greene
-//-----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(mpMarker, mpLayer)
-
-
-//-----------------------------------------------------------------------------
-
-/** @param name text to be displayed
-@param offsetx x position in percentage (0-100)
-@param offsetx y position in percentage (0-100)
-*/
-mpMarker::mpMarker( wxString name, double atX, double atY ) {
-    SetName(name);
-    mX = atX;
-    mY = atY;
-}
-
-//-----------------------------------------------------------------------------
-
-void mpMarker::Plot(wxDC & dc, mpWindow & w) {
-wxCoord     cx, cy, tw, th;
-wxColour    cc;
-wxString    ss;
-
-// setup
-
-    dc.SetPen(m_pen);
-    dc.SetFont(m_font);
-
-// part of setup is setting the text color
-
-    cc = m_pen.GetColour();
-    dc.SetTextForeground(cc);
-
-// what to draw
-
-    ss = GetName();
-
-// where to draw
-
-    dc.GetTextExtent(ss, &tw, &th);
-    cx = (wxCoord) ((mX - w.GetPosX()) * w.GetScaleX()) - (tw / 2);
-    cy = (wxCoord) ((w.GetPosY() - mY) * w.GetScaleY()) - (th / 2);
-
-// do it
-
-    dc.DrawText( ss, cx, cy);
-}
Index: src/plugins/contrib/wxSmithPlot/mpMarker.h
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/mpMarker.h b/trunk/src/plugins/contrib/wxSmithPlot/mpMarker.h
deleted file mode 10644
--- a/trunk/src/plugins/contrib/wxSmithPlot/mpMarker.h	(révision 10042)
+++ /dev/null	(copie de travail)
@@ -1,35 +0,0 @@
-
-#ifndef _MP_MATHPLOTEXTRA_H_
-#define _MP_MATHPLOTEXTRA_H_
-
-#include    <mathplot.h>
-
-
-
-//-----------------------------------------------------------------------------
-// mpText - provided by Val Greene
-//-----------------------------------------------------------------------------
-
-class mpMarker : public mpLayer
-{
-public:
-
-    mpMarker(wxString name = wxT("[M]"), double atX = 0.0, double atY = 0.0);
-
-            void SetPos(double atX, double atY) {mX = atX, mY = atY; };
-
-    virtual void Plot(wxDC & dc, mpWindow & w);
-
-    virtual bool HasBBox() { return FALSE; }
-
-protected:
-
-    double  mX, mY;
-
-    DECLARE_CLASS(mpText)
-};
-
-
-/*@}*/
-
-#endif // _MP_MATHPLOT_H_
Index: src/plugins/contrib/wxSmithPlot/wxmathplot/Makefile.am
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/Makefile.am b/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/Makefile.am
new file mode 10644
--- /dev/null	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/Makefile.am	(copie de travail)
@@ -0,0 +1,17 @@
+AM_CPPFLAGS = $(WX_CXXFLAGS)
+
+noinst_LTLIBRARIES = libwxsmithplot_wxmathplot.la
+
+libwxsmithplot_wxmathplot_la_LDFLAGS = -pthread -module -version-info 0:1:0 -shared -no-undefined -avoid-version
+
+libwxsmithplot_wxmathplot_la_LIBADD = $(WX_LIBS)
+
+EXTRA_DIST = 	$(srcdir)/*.cpp \
+		$(srcdir)/*.h
+
+
+libwxsmithplot_wxmathplot_la_SOURCES = \
+./mathplot.cpp
+
+noinst_HEADERS = \
+./mathplot.h
Index: src/plugins/contrib/wxSmithPlot/wxmathplot/README
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/README b/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/README
new file mode 10644
--- /dev/null	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/README	(copie de travail)
@@ -0,0 +1 @@
+Source from https://github.com/R1kk3r/wxMathPlot
Index: src/plugins/contrib/wxSmithPlot/wxmathplot/mathplot.cpp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/mathplot.cpp b/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/mathplot.cpp
new file mode 10644
--- /dev/null	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/mathplot.cpp	(copie de travail)
@@ -0,0 +1,3080 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:            mathplot.cpp
+// Purpose:         Framework for plotting in wxWindows
+// Original Author: David Schalig
+// Maintainer:      Davide Rondini
+// Contributors:    Jose Luis Blanco, Val Greene, R1kk3r
+// Created:         21/07/2003
+// Last edit:       26/11/2014
+// Copyright:       (c) David Schalig, Davide Rondini
+// Licence:         wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifdef __GNUG__
+// #pragma implementation "plot.h"
+#pragma implementation "mathplot.h"
+#endif
+
+// For compilers that support precompilation, includes "wx.h".
+#include <wx/wx.h>
+// #include <wx/window.h>
+// #include <wx/wxprec.h>
+
+// Comment out for release operation:
+// (Added by J.L.Blanco, Aug 2007)
+// #define MATHPLOT_DO_LOGGING
+
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+
+#ifndef WX_PRECOMP
+#include "wx/object.h"
+#include "wx/font.h"
+#include "wx/colour.h"
+#include "wx/settings.h"
+#include "wx/sizer.h"
+#include "wx/log.h"
+#include "wx/intl.h"
+#include "wx/dcclient.h"
+#include "wx/cursor.h"
+#endif
+
+#include "mathplot.h"
+#include <wx/bmpbuttn.h>
+#include <wx/module.h>
+#include <wx/msgdlg.h>
+#include <wx/image.h>
+#include <wx/tipwin.h>
+
+#include <cmath>
+#include <cstdio> // used only for debug
+#include <ctime> // used for representation of x axes involving date
+
+// #include "pixel.xpm"
+
+// Memory leak debugging
+#ifdef _DEBUG
+#define new DEBUG_NEW
+#endif
+
+// Legend margins
+#define mpLEGEND_MARGIN 5
+#define mpLEGEND_LINEWIDTH 10
+
+// Minimum axis label separation
+#define mpMIN_X_AXIS_LABEL_SEPARATION 64
+#define mpMIN_Y_AXIS_LABEL_SEPARATION 32
+
+// Number of pixels to scroll when scrolling by a line
+#define mpSCROLL_NUM_PIXELS_PER_LINE  10
+
+// See doxygen comments.
+double mpWindow::zoomIncrementalFactor = 1.5;
+
+//-----------------------------------------------------------------------------
+// mpLayer
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_ABSTRACT_CLASS(mpLayer, wxObject)
+
+mpLayer::mpLayer() : m_type(mpLAYER_UNDEF)
+{
+    SetPen((wxPen&) *wxBLACK_PEN);
+    SetFont((wxFont&) *wxNORMAL_FONT);
+    m_continuous = FALSE; // Default
+    m_showName   = TRUE;  // Default
+    m_drawOutsideMargins = TRUE;
+	m_visible = true;
+}
+
+wxBitmap mpLayer::GetColourSquare(int side)
+{
+    wxBitmap square(side, side, -1);
+    wxColour filler = m_pen.GetColour();
+    wxBrush brush(filler, wxSOLID);
+    wxMemoryDC dc;
+    dc.SelectObject(square);
+    dc.SetBackground(brush);
+    dc.Clear();
+    dc.SelectObject(wxNullBitmap);
+    return square;
+}
+
+//-----------------------------------------------------------------------------
+// mpInfoLayer
+//-----------------------------------------------------------------------------
+IMPLEMENT_DYNAMIC_CLASS(mpInfoLayer, mpLayer)
+
+mpInfoLayer::mpInfoLayer()
+{
+    m_dim = wxRect(0,0,1,1);
+    m_brush = *wxTRANSPARENT_BRUSH;
+    m_reference.x = 0; m_reference.y = 0;
+    m_winX = 1; //parent->GetScrX();
+    m_winY = 1; //parent->GetScrY();
+    m_type = mpLAYER_INFO;
+}
+
+mpInfoLayer::mpInfoLayer(wxRect rect, const wxBrush* brush) : m_dim(rect)
+{
+    m_brush = *brush;
+	m_reference.x = rect.x;
+    m_reference.y = rect.y;
+    m_winX = 1; //parent->GetScrX();
+    m_winY = 1; //parent->GetScrY();
+    m_type = mpLAYER_INFO;
+}
+
+mpInfoLayer::~mpInfoLayer()
+{
+
+}
+
+void mpInfoLayer::UpdateInfo(mpWindow& w, wxEvent& event)
+{
+    
+}
+
+bool mpInfoLayer::Inside(wxPoint& point)
+{
+#if wxCHECK_VERSION(2, 8, 0)
+    return m_dim.Contains(point);
+#else
+	return m_dim.Inside(point);
+#endif
+}
+
+void mpInfoLayer::Move(wxPoint delta)
+{
+    m_dim.SetX(m_reference.x + delta.x);
+    m_dim.SetY(m_reference.y + delta.y);
+}
+
+void mpInfoLayer::UpdateReference()
+{
+    m_reference.x = m_dim.x;
+    m_reference.y = m_dim.y;
+}
+
+
+void   mpInfoLayer::Plot(wxDC & dc, mpWindow & w)
+{
+    if (m_visible) {
+        // Adjust relative position inside the window
+        int scrx = w.GetScrX();
+        int scry = w.GetScrY();
+		// Avoid dividing by 0
+		if(scrx == 0) scrx=1;
+		if(scry == 0) scry=1;
+		
+        if ((m_winX != scrx) || (m_winY != scry)) {
+#ifdef MATHPLOT_DO_LOGGING
+            // wxLogMessage(_("mpInfoLayer::Plot() screen size has changed from %d x %d to %d x %d"), m_winX, m_winY, scrx, scry);
+#endif
+            if (m_winX != 1) m_dim.x = (int) floor((double)(m_dim.x*scrx/m_winX));
+            if (m_winY != 1) {
+                m_dim.y = (int) floor((double)(m_dim.y*scry/m_winY));
+                UpdateReference();
+            }
+            // Finally update window size
+            m_winX = scrx;
+            m_winY = scry;
+        }
+        dc.SetPen(m_pen);
+//     wxImage image0(wxT("pixel.png"), wxBITMAP_TYPE_PNG);
+//     wxBitmap image1(image0);
+//     wxBrush semiWhite(image1);
+        dc.SetBrush(m_brush);
+        dc.DrawRectangle(m_dim.x, m_dim.y, m_dim.width, m_dim.height);
+    }
+}
+
+wxPoint mpInfoLayer::GetPosition()
+{
+    return m_dim.GetPosition();
+}
+
+wxSize mpInfoLayer::GetSize()
+{
+    return m_dim.GetSize();
+}
+
+mpInfoCoords::mpInfoCoords() : mpInfoLayer()
+{
+    
+}
+
+mpInfoCoords::mpInfoCoords(wxRect rect, const wxBrush* brush) : mpInfoLayer(rect, brush)
+{
+    
+}
+    
+mpInfoCoords::~mpInfoCoords()
+{
+    
+}
+
+void mpInfoCoords::UpdateInfo(mpWindow& w, wxEvent& event)
+{
+    if (event.GetEventType() == wxEVT_MOTION) {
+        int mouseX = ((wxMouseEvent&)event).GetX();
+        int mouseY = ((wxMouseEvent&)event).GetY();
+/* It seems that Windows port of wxWidgets don't support multi-line test to be drawn in a wxDC.
+   wxGTK instead works perfectly with it.
+   Info on wxForum: http://wxforum.shadonet.com/viewtopic.php?t=3451&highlight=drawtext+eol */
+#ifdef _WINDOWS
+        m_content.Printf(wxT("x = %f y = %f"), w.p2x(mouseX), w.p2y(mouseY));
+#else
+		m_content.Printf(wxT("x = %f\ny = %f"), w.p2x(mouseX), w.p2y(mouseY));
+#endif
+    }
+}
+
+void mpInfoCoords::Plot(wxDC & dc, mpWindow & w)
+{
+    if (m_visible) {
+        // Adjust relative position inside the window
+        int scrx = w.GetScrX();
+        int scry = w.GetScrY();
+        if ((m_winX != scrx) || (m_winY != scry)) {
+#ifdef MATHPLOT_DO_LOGGING
+            // wxLogMessage(_("mpInfoLayer::Plot() screen size has changed from %d x %d to %d x %d"), m_winX, m_winY, scrx, scry);
+#endif
+            if (m_winX != 1) m_dim.x = (int) floor((double)(m_dim.x*scrx/m_winX));
+            if (m_winY != 1) {
+                m_dim.y = (int) floor((double)(m_dim.y*scry/m_winY));
+                UpdateReference();
+            }
+            // Finally update window size
+            m_winX = scrx;
+            m_winY = scry;
+        }
+        dc.SetPen(m_pen);
+//     wxImage image0(wxT("pixel.png"), wxBITMAP_TYPE_PNG);
+//     wxBitmap image1(image0);
+//     wxBrush semiWhite(image1);
+        dc.SetBrush(m_brush);
+        dc.SetFont(m_font);
+        int textX, textY;
+        dc.GetTextExtent(m_content, &textX, &textY);
+        if (m_dim.width < textX + 10) m_dim.width = textX + 10;
+        if (m_dim.height < textY + 10) m_dim.height = textY + 10;
+        dc.DrawRectangle(m_dim.x, m_dim.y, m_dim.width, m_dim.height);
+        dc.DrawText(m_content, m_dim.x + 5, m_dim.y + 5);
+    }
+}
+
+mpInfoLegend::mpInfoLegend() : mpInfoLayer()
+{
+    
+}
+
+mpInfoLegend::mpInfoLegend(wxRect rect, const wxBrush* brush) : mpInfoLayer(rect, brush)
+{
+    
+}
+
+mpInfoLegend::~mpInfoLegend()
+{
+    
+}
+
+void mpInfoLegend::UpdateInfo(mpWindow& w, wxEvent& event)
+{
+    
+}
+
+void mpInfoLegend::Plot(wxDC & dc, mpWindow & w)
+{
+    if (m_visible) {
+        // Adjust relative position inside the window
+        int scrx = w.GetScrX();
+        int scry = w.GetScrY();
+        if ((m_winX != scrx) || (m_winY != scry)) {
+#ifdef MATHPLOT_DO_LOGGING
+            // wxLogMessage(_("mpInfoLayer::Plot() screen size has changed from %d x %d to %d x %d"), m_winX, m_winY, scrx, scry);
+#endif
+            if (m_winX != 1) m_dim.x = (int) floor((double)(m_dim.x*scrx/m_winX));
+            if (m_winY != 1) {
+                m_dim.y = (int) floor((double)(m_dim.y*scry/m_winY));
+                UpdateReference();
+            }
+            // Finally update window size
+            m_winX = scrx;
+            m_winY = scry;
+        }
+//     wxImage image0(wxT("pixel.png"), wxBITMAP_TYPE_PNG);
+//     wxBitmap image1(image0);
+//     wxBrush semiWhite(image1);
+        dc.SetBrush(m_brush);
+        dc.SetFont(m_font);
+        const int baseWidth = (mpLEGEND_MARGIN*2 + mpLEGEND_LINEWIDTH);
+        int textX = baseWidth, textY = mpLEGEND_MARGIN;
+        int plotCount = 0;
+        int posY = 0;
+        int tmpX = 0, tmpY = 0;
+        mpLayer* ly = NULL;
+        wxPen lpen;
+        wxString label;
+        for (unsigned int p = 0; p < w.CountAllLayers(); p++) {
+            ly = w.GetLayer(p);
+            if ((ly->GetLayerType() == mpLAYER_PLOT) && (ly->IsVisible())) {
+                label = ly->GetName();
+                dc.GetTextExtent(label, &tmpX, &tmpY);
+                textX = (textX > (tmpX + baseWidth)) ? textX : (tmpX + baseWidth + mpLEGEND_MARGIN);
+                textY += (tmpY);
+#ifdef MATHPLOT_DO_LOGGING
+                // wxLogMessage(_("mpInfoLegend::Plot() Adding layer %d: %s"), p, label.c_str());
+#endif
+            }
+        }
+        dc.SetPen(m_pen);
+        dc.SetBrush(m_brush);
+        m_dim.width = textX;
+		if (textY != mpLEGEND_MARGIN) { // Don't draw any thing if there are no visible layers
+			textY += mpLEGEND_MARGIN;
+			m_dim.height = textY;
+			dc.DrawRectangle(m_dim.x, m_dim.y, m_dim.width, m_dim.height);
+			for (unsigned int p2 = 0; p2 < w.CountAllLayers(); p2++) {
+				ly = w.GetLayer(p2);
+				if ((ly->GetLayerType() == mpLAYER_PLOT) && (ly->IsVisible())) {
+					label = ly->GetName();
+					lpen = ly->GetPen();
+					dc.GetTextExtent(label, &tmpX, &tmpY);
+					dc.SetPen(lpen);
+					//textX = (textX > (tmpX + baseWidth)) ? textX : (tmpX + baseWidth);
+					//textY += (tmpY + mpLEGEND_MARGIN);
+					posY = m_dim.y + mpLEGEND_MARGIN + plotCount*tmpY + (tmpY>>1);
+					dc.DrawLine(m_dim.x + mpLEGEND_MARGIN,   // X start coord
+								posY,                        // Y start coord
+								m_dim.x + mpLEGEND_LINEWIDTH + mpLEGEND_MARGIN, // X end coord
+								posY);
+					//dc.DrawRectangle(m_dim.x + 5, m_dim.y + 5 + plotCount*tmpY, 5, 5);
+					dc.DrawText(label, m_dim.x + baseWidth, m_dim.y + mpLEGEND_MARGIN + plotCount*tmpY);
+					plotCount++;
+				}
+			}
+		}
+    }
+}
+
+
+
+//-----------------------------------------------------------------------------
+// mpLayer implementations - functions
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_ABSTRACT_CLASS(mpFX, mpLayer)
+
+mpFX::mpFX(wxString name, int flags)
+{
+    SetName(name);
+    m_flags = flags;
+    m_type = mpLAYER_PLOT;
+}
+
+void mpFX::Plot(wxDC & dc, mpWindow & w)
+{
+    if (m_visible) {
+		dc.SetPen( m_pen);
+
+		wxCoord startPx = m_drawOutsideMargins ? 0 : w.GetMarginLeft();
+		wxCoord endPx   = m_drawOutsideMargins ? w.GetScrX() : w.GetScrX() - w.GetMarginRight();
+		wxCoord minYpx  = m_drawOutsideMargins ? 0 : w.GetMarginTop();
+		wxCoord maxYpx  = m_drawOutsideMargins ? w.GetScrY() : w.GetScrY() - w.GetMarginBottom();
+
+		wxCoord iy = 0;
+		if (m_pen.GetWidth() <= 1)
+		{
+			for (wxCoord i = startPx; i < endPx; ++i)
+			{
+				iy = w.y2p( GetY(w.p2x(i)));
+				// Draw the point only if you can draw outside margins or if the point is inside margins
+				if (m_drawOutsideMargins || ((iy >= minYpx) && (iy <= maxYpx)))
+					dc.DrawPoint(i, iy );// (wxCoord) ((w.GetPosY() - GetY( (double)i / w.GetScaleX() + w.GetPosX()) ) * w.GetScaleY()));
+			}
+		}
+		else
+		{
+			for (wxCoord i = startPx; i < endPx; ++i)
+			{
+				iy = w.y2p( GetY(w.p2x(i)));
+				// Draw the point only if you can draw outside margins or if the point is inside margins
+				if (m_drawOutsideMargins || ((iy >= minYpx) && (iy <= maxYpx)))
+					dc.DrawLine( i, iy, i, iy);
+	//             wxCoord c = w.y2p( GetY(w.p2x(i)) ); //(wxCoord) ((w.GetPosY() - GetY( (double)i / w.GetScaleX() + w.GetPosX()) ) * w.GetScaleY());
+				
+			}
+		}
+
+		if (!m_name.IsEmpty() && m_showName)
+		{
+			dc.SetFont(m_font);
+
+			wxCoord tx, ty;
+			dc.GetTextExtent(m_name, &tx, &ty);
+
+			/*if ((m_flags & mpALIGNMASK) == mpALIGN_RIGHT)
+				tx = (w.GetScrX()>>1) - tx - 8;
+			else if ((m_flags & mpALIGNMASK) == mpALIGN_CENTER)
+				tx = -tx/2;
+			else
+				tx = -(w.GetScrX()>>1) + 8;
+			*/
+			if ((m_flags & mpALIGNMASK) == mpALIGN_RIGHT) 
+				tx = (w.GetScrX() - tx) - w.GetMarginRight() - 8; 
+			else if ((m_flags & mpALIGNMASK) == mpALIGN_CENTER) 
+				tx = ((w.GetScrX() - w.GetMarginRight() - w.GetMarginLeft() - tx) / 2) + w.GetMarginLeft(); 
+			else 
+				tx = w.GetMarginLeft() + 8;
+			dc.DrawText( m_name, tx, w.y2p(GetY(w.p2x(tx))) ); // (wxCoord) ((w.GetPosY() - GetY( (double)tx / w.GetScaleX() + w.GetPosX())) * w.GetScaleY()) );
+		}
+	}
+}
+
+IMPLEMENT_ABSTRACT_CLASS(mpFY, mpLayer)
+
+mpFY::mpFY(wxString name, int flags)
+{
+    SetName(name);
+    m_flags = flags;
+    m_type = mpLAYER_PLOT;
+}
+
+void mpFY::Plot(wxDC & dc, mpWindow & w)
+{
+	if (m_visible) {
+		dc.SetPen( m_pen);
+
+		wxCoord i, ix;
+
+		wxCoord startPx = m_drawOutsideMargins ? 0 : w.GetMarginLeft();
+		wxCoord endPx   = m_drawOutsideMargins ? w.GetScrX() : w.GetScrX() - w.GetMarginRight();
+		wxCoord minYpx  = m_drawOutsideMargins ? 0 : w.GetMarginTop();
+		wxCoord maxYpx  = m_drawOutsideMargins ? w.GetScrY() : w.GetScrY() - w.GetMarginBottom();
+
+		if (m_pen.GetWidth() <= 1)
+		{
+			for (i = minYpx; i < maxYpx; ++i)
+			{
+				ix = w.x2p(GetX(w.p2y(i)));
+				if (m_drawOutsideMargins || ((ix >= startPx) && (ix <= endPx)))
+					dc.DrawPoint(ix, i);
+			}
+		}
+		else
+		{
+			for (i=0;i< w.GetScrY(); ++i)
+			{
+				ix = w.x2p(GetX(w.p2y(i)));
+				if (m_drawOutsideMargins || ((ix >= startPx) && (ix <= endPx)))
+					dc.DrawLine(ix, i, ix, i);
+	//             wxCoord c =  w.x2p(GetX(w.p2y(i))); //(wxCoord) ((GetX( (double)i / w.GetScaleY() + w.GetPosY()) - w.GetPosX()) * w.GetScaleX());
+	//             dc.DrawLine(c, i, c, i);
+			}
+		}
+
+		if (!m_name.IsEmpty() && m_showName)
+		{
+			dc.SetFont(m_font);
+
+			wxCoord tx, ty;
+			dc.GetTextExtent(m_name, &tx, &ty);
+
+			if ((m_flags & mpALIGNMASK) == mpALIGN_TOP)
+				ty = w.GetMarginTop() + 8;
+			else if ((m_flags & mpALIGNMASK) == mpALIGN_CENTER)
+				ty = ((w.GetScrY() - w.GetMarginTop() - w.GetMarginBottom() - ty) / 2) + w.GetMarginTop();
+			else
+				ty = w.GetScrY() - 8 - ty - w.GetMarginBottom();
+
+			dc.DrawText( m_name, w.x2p(GetX(w.p2y(ty))), ty ); // (wxCoord) ((GetX( (double)i / w.GetScaleY() + w.GetPosY()) - w.GetPosX()) * w.GetScaleX()), -ty);
+		}
+	}
+}
+
+IMPLEMENT_ABSTRACT_CLASS(mpFXY, mpLayer)
+
+mpFXY::mpFXY(wxString name, int flags)
+{
+    SetName(name);
+    m_flags = flags;
+    m_type = mpLAYER_PLOT;
+}
+
+void mpFXY::UpdateViewBoundary(wxCoord xnew, wxCoord ynew)
+{
+	// Keep track of how many points have been drawn and the bouding box
+	maxDrawX = (xnew > maxDrawX) ? xnew : maxDrawX;
+	minDrawX = (xnew < minDrawX) ? xnew : minDrawX;
+	maxDrawY = (maxDrawY > ynew) ? maxDrawY : ynew;
+	minDrawY = (minDrawY < ynew) ? minDrawY : ynew;
+	//drawnPoints++;
+}
+
+void mpFXY::Plot(wxDC & dc, mpWindow & w)
+{
+	if (m_visible) {
+		dc.SetPen( m_pen);
+
+		double x, y;
+		// Do this to reset the counters to evaluate bounding box for label positioning
+		Rewind(); GetNextXY(x, y);
+		maxDrawX = x; minDrawX = x; maxDrawY = y; minDrawY = y;
+		//drawnPoints = 0;
+		Rewind();
+
+		wxCoord startPx = m_drawOutsideMargins ? 0 : w.GetMarginLeft();
+		wxCoord endPx   = m_drawOutsideMargins ? w.GetScrX() : w.GetScrX() - w.GetMarginRight();
+		wxCoord minYpx  = m_drawOutsideMargins ? 0 : w.GetMarginTop();
+		wxCoord maxYpx  = m_drawOutsideMargins ? w.GetScrY() : w.GetScrY() - w.GetMarginBottom();
+
+		wxCoord ix = 0, iy = 0;
+
+		if (!m_continuous)
+		{
+			// for some reason DrawPoint does not use the current pen,
+			// so we use DrawLine for fat pens
+			if (m_pen.GetWidth() <= 1)
+			{
+				while (GetNextXY(x, y))
+				{
+					ix = w.x2p(x);
+					iy = w.y2p(y);
+					if (m_drawOutsideMargins || ((ix >= startPx) && (ix <= endPx) && (iy >= minYpx) && (iy <= maxYpx))) {
+						dc.DrawPoint(ix, iy);
+						UpdateViewBoundary(ix, iy);
+					};
+				}
+			}
+			else
+			{
+				while (GetNextXY(x, y))
+				{
+					ix = w.x2p(x);
+					iy = w.y2p(y);
+					if (m_drawOutsideMargins || ((ix >= startPx) && (ix <= endPx) && (iy >= minYpx) && (iy <= maxYpx))) {
+						dc.DrawLine(ix, iy, ix, iy);
+						UpdateViewBoundary(ix, iy);
+					}
+	//                dc.DrawLine(cx, cy, cx, cy);
+				}
+			}
+		}
+		else
+		{
+			// Old code
+			wxCoord x0=0,c0=0;
+			bool    first = TRUE;
+			while (GetNextXY(x, y))
+			{
+				wxCoord x1 = w.x2p(x); // (wxCoord) ((x - w.GetPosX()) * w.GetScaleX());
+				wxCoord c1 = w.y2p(y); // (wxCoord) ((w.GetPosY() - y) * w.GetScaleY());
+				if (first)
+				{
+					first=FALSE;
+					x0=x1;c0=c1;
+				}
+				bool outUp, outDown;
+				if((x1 >= startPx)&&(x0 <= endPx)) {
+					outDown = (c0 > maxYpx) && (c1 > maxYpx);
+					outUp = (c0 < minYpx) && (c1 < minYpx);
+					if (!outUp && !outDown) {
+						if (c1 != c0) {
+							if (c0 < minYpx) {
+								x0 = (int)(((float)(minYpx - c0))/((float)(c1 - c0))*(x1-x0)) + x0;
+								c0 = minYpx;
+							}
+							if (c0 > maxYpx) {
+								x0 = (int)(((float)(maxYpx - c0))/((float)(c1 - c0))*(x1-x0)) + x0;
+								//wxLogDebug(wxT("old x0 = %d, new x0 = %d"), x0, newX0);
+								//x0 = newX0;
+								c0 = maxYpx;
+							}
+							if (c1 < minYpx) {
+								x1 = (int)(((float)(minYpx - c0))/((float)(c1 - c0))*(x1-x0)) + x0;
+								c1 = minYpx;
+							}
+							if (c1 > maxYpx) {
+								x1 = (int)(((float)(maxYpx - c0))/((float)(c1 - c0))*(x1-x0)) + x0;
+								//wxLogDebug(wxT("old x0 = %d, old x1 = %d, new x1 = %d, c0 = %d, c1 = %d, maxYpx = %d"), x0, x1, newX1, c0, c1, maxYpx);
+								//x1 = newX1;
+								c1 = maxYpx;
+							}
+						}
+						if (x1 != x0) {
+							if (x0 < startPx) {
+								c0 = (int)(((float)(startPx - x0))/((float)(x1 -x0))*(c1 -c0)) + c0;
+								x0 = startPx;
+							}
+							if (x1 > endPx) {
+								c1 = (int)(((float)(endPx - x0))/((float)(x1 -x0))*(c1 -c0)) + c0;
+								x1 = endPx;
+							}
+						}
+						dc.DrawLine(x0, c0, x1, c1);
+						UpdateViewBoundary(x1, c1);
+					}
+				}
+				x0=x1; c0=c1;
+			}
+		}
+
+		if (!m_name.IsEmpty() && m_showName)
+		{
+			dc.SetFont(m_font);
+
+			wxCoord tx, ty;
+			dc.GetTextExtent(m_name, &tx, &ty);
+
+			// xxx implement else ... if (!HasBBox())
+			{
+				// const int sx = w.GetScrX();
+				// const int sy = w.GetScrY();
+
+				if ((m_flags & mpALIGNMASK) == mpALIGN_NW)
+				{
+					tx = minDrawX + 8;
+					ty = maxDrawY + 8;
+				}
+				else if ((m_flags & mpALIGNMASK) == mpALIGN_NE)
+				{
+					tx = maxDrawX - tx - 8;
+					ty = maxDrawY + 8;
+				}
+				else if ((m_flags & mpALIGNMASK) == mpALIGN_SE)
+				{
+					tx = maxDrawX - tx - 8;
+					ty = minDrawY - ty - 8;
+				}
+				else
+				{ // mpALIGN_SW
+					tx = minDrawX + 8;
+					ty = minDrawY - ty - 8;
+				}
+			}
+
+			dc.DrawText( m_name, tx, ty);
+		}
+	}
+}
+
+//-----------------------------------------------------------------------------
+// mpProfile implementation
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_ABSTRACT_CLASS(mpProfile, mpLayer)
+
+mpProfile::mpProfile(wxString name, int flags)
+{
+    SetName(name);
+    m_flags = flags;
+    m_type = mpLAYER_PLOT;
+}
+
+void mpProfile::Plot(wxDC & dc, mpWindow & w)
+{
+	if (m_visible) {
+	dc.SetPen( m_pen);
+
+		wxCoord startPx = m_drawOutsideMargins ? 0 : w.GetMarginLeft();
+		wxCoord endPx   = m_drawOutsideMargins ? w.GetScrX() : w.GetScrX() - w.GetMarginRight();
+		wxCoord minYpx  = m_drawOutsideMargins ? 0 : w.GetMarginTop();
+		wxCoord maxYpx  = m_drawOutsideMargins ? w.GetScrY() : w.GetScrY() - w.GetMarginBottom();
+
+	// Plot profile linking subsequent point of the profile, instead of mpFY, which plots simple points.
+	for (wxCoord i = startPx; i < endPx; ++i) {
+			wxCoord c0 = w.y2p( GetY(w.p2x(i)) ); // (wxCoord) ((w.GetYpos() - GetY( (double)i / w.GetXscl() + w.GetXpos()) ) * w.GetYscl());
+		wxCoord c1 = w.y2p( GetY(w.p2x(i+1)) );//(wxCoord) ((w.GetYpos() - GetY( (double)(i+1) / w.GetXscl() + (w.GetXpos() ) ) ) * w.GetYscl());
+			// c0 = (c0 <= maxYpx) ? ((c0 >= minYpx) ? c0 : minYpx) : maxYpx;
+			// c1 = (c1 <= maxYpx) ? ((c1 >= minYpx) ? c1 : minYpx) : maxYpx;
+			if (!m_drawOutsideMargins) {
+				c0 = (c0 <= maxYpx) ? ((c0 >= minYpx) ? c0 : minYpx) : maxYpx;
+				c1 = (c1 <= maxYpx) ? ((c1 >= minYpx) ? c1 : minYpx) : maxYpx;
+			}
+		dc.DrawLine(i, c0, i+1, c1);
+		};
+		if (!m_name.IsEmpty()) {
+			dc.SetFont(m_font);
+
+			wxCoord tx, ty;
+			dc.GetTextExtent(m_name, &tx, &ty);
+
+			if ((m_flags & mpALIGNMASK) == mpALIGN_RIGHT) 
+				tx = (w.GetScrX() - tx) - w.GetMarginRight() - 8; 
+			else if ((m_flags & mpALIGNMASK) == mpALIGN_CENTER) 
+				tx = ((w.GetScrX() - w.GetMarginRight() - w.GetMarginLeft() - tx) / 2) + w.GetMarginLeft(); 
+			else 
+				tx = w.GetMarginLeft() + 8;
+
+			dc.DrawText( m_name, tx, w.y2p( GetY( w.p2x(tx) ) ) );//(wxCoord) ((w.GetPosY() - GetY( (double)tx / w.GetScaleX() + w.GetPosX())) * w.GetScaleY()) );
+		}
+	}
+}
+
+//-----------------------------------------------------------------------------
+// mpLayer implementations - furniture (scales, ...)
+//-----------------------------------------------------------------------------
+
+#define mpLN10 2.3025850929940456840179914546844
+
+IMPLEMENT_DYNAMIC_CLASS(mpScaleX, mpLayer)
+
+mpScaleX::mpScaleX(wxString name, int flags, bool ticks, unsigned int type)
+{
+    SetName(name);
+    SetFont( (wxFont&) *wxSMALL_FONT);
+    SetPen( (wxPen&) *wxGREY_PEN);
+    m_flags = flags;
+    m_ticks = ticks;
+    m_labelType = type;
+    m_type = mpLAYER_AXIS;
+	m_labelFormat = wxT("");
+}
+
+void mpScaleX::Plot(wxDC & dc, mpWindow & w)
+{
+	if (m_visible) {
+		dc.SetPen( m_pen);
+		dc.SetFont( m_font);
+		int orgy=0;
+
+		const int extend = w.GetScrX(); //  /2;
+		if (m_flags == mpALIGN_CENTER)
+		orgy   = w.y2p(0); //(int)(w.GetPosY() * w.GetScaleY());
+		if (m_flags == mpALIGN_TOP) {
+			if (m_drawOutsideMargins) 
+				orgy = X_BORDER_SEPARATION;
+			else 
+				orgy = w.GetMarginTop();
+		}
+		if (m_flags == mpALIGN_BOTTOM) {
+			if (m_drawOutsideMargins)
+				orgy = X_BORDER_SEPARATION;
+			else
+				orgy = w.GetScrY() - w.GetMarginBottom();
+		}
+		if (m_flags == mpALIGN_BORDER_BOTTOM )
+		orgy = w.GetScrY() - 1;//dc.LogicalToDeviceY(0) - 1;
+		if (m_flags == mpALIGN_BORDER_TOP )
+		orgy = 1;//-dc.LogicalToDeviceY(0);
+
+		dc.DrawLine( 0, orgy, w.GetScrX(), orgy);
+		
+		// To cut the axis line when draw outside margin is false, use this code
+        /*if (m_drawOutsideMargins == true)
+            dc.DrawLine( 0, orgy, w.GetScrX(), orgy);
+        else
+            dc.DrawLine( w.GetMarginLeft(), orgy, w.GetScrX() - w.GetMarginRight(), orgy); */
+
+		const double dig  = floor( log( 128.0 / w.GetScaleX() ) / mpLN10 );
+		const double step = exp( mpLN10 * dig);
+		const double end  = w.GetPosX() + (double)extend / w.GetScaleX();
+
+		wxCoord tx, ty;
+		wxString s;
+		wxString fmt;
+		int tmp = (int)dig;
+		if (m_labelType == mpX_NORMAL) {
+			if (!m_labelFormat.IsEmpty()) {
+				fmt = m_labelFormat;
+			} else {
+				if (tmp>=1) {
+					fmt = wxT("%.f");
+				} else {
+					tmp=8-tmp;
+					fmt.Printf(wxT("%%.%df"), tmp >= -1 ? 2 : -tmp);
+				}
+			}
+		} else {
+			// Date and/or time axis representation
+			if (m_labelType == mpX_DATETIME) {
+				fmt = (wxT("%04.0f-%02.0f-%02.0fT%02.0f:%02.0f:%02.0f"));
+			} else if (m_labelType == mpX_DATE) {
+				fmt = (wxT("%04.0f-%02.0f-%02.0f"));
+			} else if ((m_labelType == mpX_TIME) && (end/60 < 2)) {
+				fmt = (wxT("%02.0f:%02.3f"));
+			} else {
+				fmt = (wxT("%02.0f:%02.0f:%02.0f"));
+			}
+		}
+
+		//double n = floor( (w.GetPosX() - (double)extend / w.GetScaleX()) / step ) * step ;
+		double n0 = floor( (w.GetPosX() /* - (double)(extend - w.GetMarginLeft() - w.GetMarginRight())/ w.GetScaleX() */) / step ) * step ;
+		double n = 0;
+#ifdef MATHPLOT_DO_LOGGING
+		wxLogMessage(wxT("mpScaleX::Plot: dig: %f , step: %f, end: %f, n: %f"), dig, step, end, n0);
+#endif
+		wxCoord startPx = m_drawOutsideMargins ? 0 : w.GetMarginLeft();
+		wxCoord endPx   = m_drawOutsideMargins ? w.GetScrX() : w.GetScrX() - w.GetMarginRight();
+		wxCoord minYpx  = m_drawOutsideMargins ? 0 : w.GetMarginTop();
+		wxCoord maxYpx  = m_drawOutsideMargins ? w.GetScrY() : w.GetScrY() - w.GetMarginBottom();
+		
+		tmp=-65535;
+		int labelH = 0; // Control labels heigth to decide where to put axis name (below labels or on top of axis)
+		int maxExtent = 0;
+		for (n = n0; n < end; n += step) {
+			const int p = (int)((n - w.GetPosX()) * w.GetScaleX());
+#ifdef MATHPLOT_DO_LOGGING
+		wxLogMessage(wxT("mpScaleX::Plot: n: %f -> p = %d"), n, p);
+#endif
+			if ((p >= startPx) && (p <= endPx)) {
+				if (m_ticks) { // draw axis ticks
+					if (m_flags == mpALIGN_BORDER_BOTTOM)
+						dc.DrawLine( p, orgy, p, orgy-4);
+					else
+						dc.DrawLine( p, orgy, p, orgy+4);
+				} else { // draw grid dotted lines
+					m_pen.SetStyle(wxDOT);
+					dc.SetPen(m_pen);
+					if ((m_flags == mpALIGN_BOTTOM) && !m_drawOutsideMargins) {
+						dc.DrawLine( p, orgy+4, p, minYpx );
+					} else {
+						if ((m_flags == mpALIGN_TOP) && !m_drawOutsideMargins) {
+							dc.DrawLine( p, orgy-4, p, maxYpx );
+						} else {
+							dc.DrawLine( p, 0/*-w.GetScrY()*/, p, w.GetScrY() );
+						}
+					}
+					m_pen.SetStyle(wxSOLID);
+					dc.SetPen(m_pen);
+				}
+				// Write ticks labels in s string
+				if (m_labelType == mpX_NORMAL)
+					s.Printf(fmt, n);
+				else if (m_labelType == mpX_DATETIME) {
+					time_t when = (time_t)n;
+					struct tm tm = *localtime(&when);
+					s.Printf(fmt, (double)tm.tm_year+1900, (double)tm.tm_mon+1, (double)tm.tm_mday, (double)tm.tm_hour, (double)tm.tm_min, (double)tm.tm_sec);
+				} else if (m_labelType == mpX_DATE) {
+					time_t when = (time_t)n;
+					struct tm tm = *localtime(&when);
+					s.Printf(fmt, (double)tm.tm_year+1900, (double)tm.tm_mon+1, (double)tm.tm_mday);
+				} else if ((m_labelType == mpX_TIME) || (m_labelType == mpX_HOURS)) {
+					double modulus = fabs(n);
+					double sign = n/modulus;
+					double hh = floor(modulus/3600);
+					double mm = floor((modulus - hh*3600)/60);
+					double ss = modulus - hh*3600 - mm*60;
+	#ifdef MATHPLOT_DO_LOGGING
+					wxLogMessage(wxT("%02.0f Hours, %02.0f minutes, %02.0f seconds"), sign*hh, mm, ss);
+	#endif // MATHPLOT_DO_LOGGING
+					if (fmt.Len() == 20) // Format with hours has 11 chars
+						s.Printf(fmt, sign*hh, mm, floor(ss));
+					else
+						s.Printf(fmt, sign*mm, ss);
+				}
+				dc.GetTextExtent(s, &tx, &ty);
+				labelH = (labelH <= ty) ? ty : labelH;
+/*				if ((p-tx/2-tmp) > 64) { // Problem about non-regular axis labels
+					if ((m_flags == mpALIGN_BORDER_BOTTOM) || (m_flags == mpALIGN_TOP)) {
+						dc.DrawText( s, p-tx/2, orgy-4-ty);
+					} else {
+						dc.DrawText( s, p-tx/2, orgy+4);
+					}
+					tmp=p+tx/2;
+				}
+				*/
+				maxExtent = (tx > maxExtent) ? tx : maxExtent; // Keep in mind max label width
+			}
+		}
+		// Actually draw labels, taking care of not overlapping them, and distributing them regularly
+		double labelStep = ceil((maxExtent + mpMIN_X_AXIS_LABEL_SEPARATION)/(w.GetScaleX()*step))*step;
+		for (n = n0; n < end; n += labelStep) {
+			const int p = (int)((n - w.GetPosX()) * w.GetScaleX());
+#ifdef MATHPLOT_DO_LOGGING
+		wxLogMessage(wxT("mpScaleX::Plot: n_label = %f -> p_label = %d"), n, p);
+#endif
+			if ((p >= startPx) && (p <= endPx)) {
+				// Write ticks labels in s string
+				if (m_labelType == mpX_NORMAL)
+					s.Printf(fmt, n);
+				else if (m_labelType == mpX_DATETIME) {
+					time_t when = (time_t)n;
+					struct tm tm = *localtime(&when);
+					s.Printf(fmt, (double)tm.tm_year+1900, (double)tm.tm_mon+1, (double)tm.tm_mday, (double)tm.tm_hour, (double)tm.tm_min, (double)tm.tm_sec);
+				} else if (m_labelType == mpX_DATE) {
+					time_t when = (time_t)n;
+					struct tm tm = *localtime(&when);
+					s.Printf(fmt, (double)tm.tm_year+1900, (double)tm.tm_mon+1, (double)tm.tm_mday);
+				} else if ((m_labelType == mpX_TIME) || (m_labelType == mpX_HOURS)) {
+					double modulus = fabs(n);
+					double sign = n/modulus;
+					double hh = floor(modulus/3600);
+					double mm = floor((modulus - hh*3600)/60);
+					double ss = modulus - hh*3600 - mm*60;
+	#ifdef MATHPLOT_DO_LOGGING
+					wxLogMessage(wxT("%02.0f Hours, %02.0f minutes, %02.0f seconds"), sign*hh, mm, ss);
+	#endif // MATHPLOT_DO_LOGGING
+					if (fmt.Len() == 20) // Format with hours has 11 chars
+						s.Printf(fmt, sign*hh, mm, floor(ss));
+					else
+						s.Printf(fmt, sign*mm, ss);
+				}
+				dc.GetTextExtent(s, &tx, &ty);
+				if ((m_flags == mpALIGN_BORDER_BOTTOM) || (m_flags == mpALIGN_TOP)) {
+					dc.DrawText( s, p-tx/2, orgy-4-ty);
+				} else {
+					dc.DrawText( s, p-tx/2, orgy+4);
+				}
+			}
+		}
+
+		// Draw axis name
+		dc.GetTextExtent(m_name, &tx, &ty);
+		switch (m_flags) {
+			case mpALIGN_BORDER_BOTTOM:
+				dc.DrawText( m_name, extend - tx - 4, orgy - 8 - ty - labelH);
+			break;
+			case mpALIGN_BOTTOM: {
+				if ((!m_drawOutsideMargins) && (w.GetMarginBottom() > (ty + labelH + 8))) {
+					dc.DrawText( m_name, (endPx - startPx - tx)>>1, orgy + 6 + labelH);
+				} else {
+					dc.DrawText( m_name, extend - tx - 4, orgy - 4 - ty);
+				}
+			} break;
+			case mpALIGN_CENTER:
+				dc.DrawText( m_name, extend - tx - 4, orgy - 4 - ty);
+			break;
+			case mpALIGN_TOP: {
+				if ((!m_drawOutsideMargins) && (w.GetMarginTop() > (ty + labelH + 8))) {
+					dc.DrawText( m_name, (endPx - startPx - tx)>>1, orgy - 6 - ty - labelH);
+				} else {
+					dc.DrawText( m_name, extend - tx - 4, orgy + 4);
+				}
+			} break;
+			case mpALIGN_BORDER_TOP:
+				dc.DrawText( m_name, extend - tx - 4, orgy + 6 + labelH);
+			break;
+			default:
+			break;
+		}
+	}
+/*    if (m_flags != mpALIGN_TOP) {
+        
+        if ((m_flags == mpALIGN_BORDER_BOTTOM) || (m_flags == mpALIGN_TOP)) {
+            dc.DrawText( m_name, extend - tx - 4, orgy - 4 - (ty*2));
+        } else {
+            dc.DrawText( m_name, extend - tx - 4, orgy - 4 - ty); //orgy + 4 + ty);
+        }
+    }; */
+}
+
+IMPLEMENT_DYNAMIC_CLASS(mpScaleY, mpLayer)
+
+mpScaleY::mpScaleY(wxString name, int flags, bool ticks)
+{
+    SetName(name);
+    SetFont( (wxFont&) *wxSMALL_FONT);
+    SetPen( (wxPen&) *wxGREY_PEN);
+    m_flags = flags;
+    m_ticks = ticks;
+    m_type = mpLAYER_AXIS;
+	m_labelFormat = wxT("");
+}
+
+void mpScaleY::Plot(wxDC & dc, mpWindow & w)
+{
+	if (m_visible) {
+		dc.SetPen( m_pen);
+		dc.SetFont( m_font);
+
+		int orgx=0;
+		const int extend = w.GetScrY(); // /2;
+		if (m_flags == mpALIGN_CENTER)
+			orgx   = w.x2p(0); //(int)(w.GetPosX() * w.GetScaleX());
+		if (m_flags == mpALIGN_LEFT) {
+			if (m_drawOutsideMargins)
+				orgx = Y_BORDER_SEPARATION;
+			else
+				orgx = w.GetMarginLeft();
+		}
+		if (m_flags == mpALIGN_RIGHT) {
+			if (m_drawOutsideMargins)
+				orgx = w.GetScrX() - Y_BORDER_SEPARATION;
+			else
+				orgx = w.GetScrX() - w.GetMarginRight();
+		}
+		if (m_flags == mpALIGN_BORDER_RIGHT )
+			orgx = w.GetScrX() - 1; //dc.LogicalToDeviceX(0) - 1;
+		if (m_flags == mpALIGN_BORDER_LEFT )
+			orgx = 1; //-dc.LogicalToDeviceX(0);
+
+
+        // Draw line
+		dc.DrawLine( orgx, 0, orgx, extend);
+		
+		// To cut the axis line when draw outside margin is false, use this code
+        /* if (m_drawOutsideMargins == true)
+		    dc.DrawLine( orgx, 0, orgx, extend);
+        else
+		    dc.DrawLine( orgx, w.GetMarginTop(), orgx, w.GetScrY() - w.GetMarginBottom()); */
+
+		const double dig  = floor( log( 128.0 / w.GetScaleY() ) / mpLN10 );
+		const double step = exp( mpLN10 * dig);
+		const double end  = w.GetPosY() + (double)extend / w.GetScaleY();
+
+		wxCoord tx, ty;
+		wxString s;
+		wxString fmt;
+		int tmp = (int)dig;
+		double maxScaleAbs = fabs(w.GetDesiredYmax());
+		double minScaleAbs = fabs(w.GetDesiredYmin()); 
+		double endscale = (maxScaleAbs > minScaleAbs) ? maxScaleAbs : minScaleAbs;
+		if (m_labelFormat.IsEmpty()) {
+			if ((endscale < 1e4) && (endscale > 1e-3))
+				fmt = wxT("%.2f");
+			else
+				fmt = wxT("%.1e");
+		} else {
+			fmt = m_labelFormat;
+		}
+	/*    if (tmp>=1)
+		{*/
+		//    fmt = wxT("%7.5g");
+	//     }
+	//     else
+	//     {
+	//         tmp=8-tmp;
+	//         fmt.Printf(wxT("%%.%dg"), (tmp >= -1) ? 2 : -tmp);
+	//     }
+
+		double n = floor( (w.GetPosY() - (double)(extend - w.GetMarginTop() - w.GetMarginBottom())/ w.GetScaleY()) / step ) * step ;
+
+		/* wxCoord startPx = m_drawOutsideMargins ? 0 : w.GetMarginLeft(); */
+		wxCoord endPx   = m_drawOutsideMargins ? w.GetScrX() : w.GetScrX() - w.GetMarginRight();
+		wxCoord minYpx  = m_drawOutsideMargins ? 0 : w.GetMarginTop();
+		wxCoord maxYpx  = m_drawOutsideMargins ? w.GetScrY() : w.GetScrY() - w.GetMarginBottom();
+
+		tmp=65536;
+		int labelW = 0;
+		// Before staring cycle, calculate label height
+		int labelHeigth = 0;
+		s.Printf(fmt,n);
+		dc.GetTextExtent(s, &tx, &labelHeigth);
+		for (;n < end; n += step) {
+			const int p = (int)((w.GetPosY() - n) * w.GetScaleY());
+		if ((p >= minYpx) && (p <= maxYpx)) {
+			if (m_ticks) { // Draw axis ticks
+				if (m_flags == mpALIGN_BORDER_LEFT) {
+					dc.DrawLine( orgx, p, orgx+4, p);
+				} else {
+					dc.DrawLine( orgx-4, p, orgx, p); //( orgx, p, orgx+4, p);
+				}
+			} else {
+				m_pen.SetStyle(wxDOT);
+				dc.SetPen( m_pen);
+				if ((m_flags == mpALIGN_LEFT) && !m_drawOutsideMargins) {
+					dc.DrawLine( orgx-4, p, endPx, p);
+				} else {
+					if ((m_flags == mpALIGN_RIGHT) && !m_drawOutsideMargins) {
+					dc.DrawLine( minYpx, p, orgx+4, p);
+								} else {
+					dc.DrawLine( 0/*-w.GetScrX()*/, p, w.GetScrX(), p);
+						}
+				}
+				m_pen.SetStyle(wxSOLID);
+				dc.SetPen( m_pen);
+			}
+			// Print ticks labels
+			s.Printf(fmt, n);
+			dc.GetTextExtent(s, &tx, &ty);
+#ifdef MATHPLOT_DO_LOGGING
+			if (ty != labelHeigth) wxLogMessage(wxT("mpScaleY::Plot: ty(%f) and labelHeigth(%f) differ!"), ty, labelHeigth);
+#endif
+			labelW = (labelW <= tx) ? tx : labelW;
+			if ((tmp-p+labelHeigth/2) > mpMIN_Y_AXIS_LABEL_SEPARATION) {
+				if ((m_flags == mpALIGN_BORDER_LEFT) || (m_flags == mpALIGN_RIGHT))
+					dc.DrawText( s, orgx+4, p-ty/2);
+				else
+					dc.DrawText( s, orgx-4-tx, p-ty/2); //( s, orgx+4, p-ty/2);
+				tmp=p-labelHeigth/2;
+			}
+		}
+		}
+		// Draw axis name
+
+		dc.GetTextExtent(m_name, &tx, &ty);
+		switch (m_flags) {
+			case mpALIGN_BORDER_LEFT:
+				dc.DrawText( m_name, labelW + 8, 4);
+			break;
+			case mpALIGN_LEFT: {
+				if ((!m_drawOutsideMargins) && (w.GetMarginLeft() > (ty + labelW + 8))) {
+					dc.DrawRotatedText( m_name, orgx - 6 - labelW - ty, (maxYpx - minYpx + tx)>>1, 90);
+				} else {
+					dc.DrawText( m_name, orgx + 4, 4);
+				}
+			} break;
+			case mpALIGN_CENTER:
+				dc.DrawText( m_name, orgx + 4, 4);
+			break;
+			case mpALIGN_RIGHT: {
+				if ((!m_drawOutsideMargins) && (w.GetMarginRight() > (ty + labelW + 8))) {
+					dc.DrawRotatedText( m_name, orgx + 6 + labelW, (maxYpx - minYpx + tx)>>1, 90);
+				} else {
+					dc.DrawText( m_name, orgx - tx - 4, 4);
+				}
+			} break;
+			case mpALIGN_BORDER_RIGHT:
+				dc.DrawText( m_name, orgx - 6 - tx -labelW, 4);
+			break;
+			default:
+			break;
+		}
+	}
+
+/*    if (m_flags != mpALIGN_RIGHT) {
+	dc.GetTextExtent(m_name, &tx, &ty);
+	if (m_flags == mpALIGN_BORDER_LEFT) {
+            dc.DrawText( m_name, orgx-tx-4, -extend + ty + 4);
+        } else {
+            if (m_flags == mpALIGN_BORDER_RIGHT )
+                dc.DrawText( m_name, orgx-(tx*2)-4, -extend + ty + 4);
+            else
+                dc.DrawText( m_name, orgx + 4, -extend + 4);
+        }
+    }; */
+}
+
+//-----------------------------------------------------------------------------
+// mpWindow
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(mpWindow, wxWindow)
+
+BEGIN_EVENT_TABLE(mpWindow, wxWindow)
+    EVT_PAINT    ( mpWindow::OnPaint)
+    EVT_SIZE     ( mpWindow::OnSize)
+    EVT_SCROLLWIN_THUMBTRACK(mpWindow::OnScrollThumbTrack)
+    EVT_SCROLLWIN_PAGEUP(mpWindow::OnScrollPageUp)
+    EVT_SCROLLWIN_PAGEDOWN(mpWindow::OnScrollPageDown)
+    EVT_SCROLLWIN_LINEUP(mpWindow::OnScrollLineUp)
+    EVT_SCROLLWIN_LINEDOWN(mpWindow::OnScrollLineDown)
+    EVT_SCROLLWIN_TOP(mpWindow::OnScrollTop)
+    EVT_SCROLLWIN_BOTTOM(mpWindow::OnScrollBottom)
+
+    EVT_MIDDLE_UP( mpWindow::OnShowPopupMenu)
+    EVT_RIGHT_DOWN( mpWindow::OnMouseRightDown) // JLB
+    EVT_RIGHT_UP ( mpWindow::OnShowPopupMenu)
+    EVT_MOUSEWHEEL( mpWindow::OnMouseWheel )   // JLB
+    EVT_MOTION( mpWindow::OnMouseMove )   // JLB
+    EVT_LEFT_DOWN( mpWindow::OnMouseLeftDown)
+    EVT_LEFT_UP( mpWindow::OnMouseLeftRelease)
+
+    EVT_MENU( mpID_CENTER,    mpWindow::OnCenter)
+    EVT_MENU( mpID_FIT,       mpWindow::OnFit)
+    EVT_MENU( mpID_ZOOM_IN,   mpWindow::OnZoomIn)
+    EVT_MENU( mpID_ZOOM_OUT,  mpWindow::OnZoomOut)
+    EVT_MENU( mpID_LOCKASPECT,mpWindow::OnLockAspect)
+    EVT_MENU( mpID_HELP_MOUSE,mpWindow::OnMouseHelp)
+END_EVENT_TABLE()
+
+mpWindow::mpWindow( wxWindow *parent, wxWindowID id, const wxPoint &pos, const wxSize &size, long flag )
+    : wxWindow( parent, id, pos, size, flag, wxT("mathplot") )
+{
+    m_scaleX = m_scaleY = 1.0;
+    m_posX   = m_posY   = 0;
+    m_desiredXmin=m_desiredYmin=0;
+    m_desiredXmax=m_desiredYmax=1;
+    m_scrX   = m_scrY   = 64; // Fixed from m_scrX = m_scrX = 64;
+    m_minX   = m_minY   = 0;
+    m_maxX   = m_maxY   = 0;
+    m_last_lx= m_last_ly= 0;
+    m_buff_bmp = NULL;
+    m_enableDoubleBuffer        = FALSE;
+    m_enableMouseNavigation     = TRUE;
+    m_mouseMovedAfterRightClick = FALSE;
+    m_movingInfoLayer = NULL;
+    // Set margins to 0
+    m_marginTop = 0; m_marginRight = 0; m_marginBottom = 0; m_marginLeft = 0;
+
+
+    m_lockaspect = FALSE;
+
+    m_popmenu.Append( mpID_CENTER,     _("Center"),      _("Center plot view to this position"));
+    m_popmenu.Append( mpID_FIT,        _("Fit"),         _("Set plot view to show all items"));
+    m_popmenu.Append( mpID_ZOOM_IN,    _("Zoom in"),     _("Zoom in plot view."));
+    m_popmenu.Append( mpID_ZOOM_OUT,   _("Zoom out"),    _("Zoom out plot view."));
+    m_popmenu.AppendCheckItem( mpID_LOCKASPECT, _("Lock aspect"), _("Lock horizontal and vertical zoom aspect."));
+    m_popmenu.Append( mpID_HELP_MOUSE,   _("Show mouse commands..."),    _("Show help about the mouse commands."));
+
+    m_layers.clear();
+    SetBackgroundColour( *wxWHITE );
+	 m_bgColour = *wxWHITE;
+	 m_fgColour = *wxBLACK;
+
+    m_enableScrollBars = false;
+    SetSizeHints(128, 128);
+
+    // J.L.Blanco: Eliminates the "flick" with the double buffer.
+    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
+
+    UpdateAll();
+}
+
+mpWindow::~mpWindow()
+{
+	// Free all the layers:
+	DelAllLayers( true, false );
+	
+    if (m_buff_bmp)
+    {
+        delete m_buff_bmp;
+        m_buff_bmp = NULL;
+    }
+}
+
+// Mouse handler, for detecting when the user drag with the right button or just "clicks" for the menu
+// JLB
+void mpWindow::OnMouseRightDown(wxMouseEvent     &event)
+{
+    m_mouseMovedAfterRightClick = FALSE;
+    m_mouseRClick_X = event.GetX();
+    m_mouseRClick_Y = event.GetY();
+    if (m_enableMouseNavigation)
+    {
+        SetCursor( *wxCROSS_CURSOR );
+    }
+}
+
+// Process mouse wheel events
+// JLB
+void mpWindow::OnMouseWheel( wxMouseEvent &event )
+{
+    if (!m_enableMouseNavigation)
+    {
+        event.Skip();
+        return;
+    }
+
+//     GetClientSize( &m_scrX,&m_scrY);
+
+    if (event.m_controlDown)
+    {
+	wxPoint clickPt( event.GetX(),event.GetY() );
+        // CTRL key hold: Zoom in/out:
+        if (event.GetWheelRotation()>0)
+                ZoomIn( clickPt );
+        else    ZoomOut( clickPt );
+    }
+    else
+    {
+        // Scroll vertically or horizontally (this is SHIFT is hold down).
+        int change = - event.GetWheelRotation(); // Opposite direction (More intuitive)!
+        double changeUnitsX = change / m_scaleX;
+        double changeUnitsY = change / m_scaleY;
+
+        if (event.m_shiftDown)
+	{
+                m_posX 		+= changeUnitsX;
+		m_desiredXmax 	+= changeUnitsX;
+		m_desiredXmin 	+= changeUnitsX;
+	}
+        else    
+	{
+		m_posY 		-= changeUnitsY;
+		m_desiredYmax	-= changeUnitsY;
+		m_desiredYmax	-= changeUnitsY;
+	}
+
+        UpdateAll();
+    }
+}
+
+// If the user "drags" with the right buttom pressed, do "pan"
+// JLB
+void mpWindow::OnMouseMove(wxMouseEvent     &event)
+{
+    if (!m_enableMouseNavigation)
+    {
+        event.Skip();
+        return;
+    }
+
+    if (event.m_rightDown)
+    {
+        m_mouseMovedAfterRightClick = TRUE;  // Hides the popup menu after releasing the button!
+
+        // The change:
+        int  Ax= m_mouseRClick_X - event.GetX();
+        int  Ay= m_mouseRClick_Y - event.GetY();
+
+        // For the next event, use relative to this coordinates.
+        m_mouseRClick_X = event.GetX();
+        m_mouseRClick_Y = event.GetY();
+
+        double   Ax_units = Ax / m_scaleX;
+        double   Ay_units = -Ay / m_scaleY;
+
+        m_posX += Ax_units;
+        m_posY += Ay_units;
+	m_desiredXmax 	+= Ax_units;
+	m_desiredXmin 	+= Ax_units;
+	m_desiredYmax 	+= Ay_units;
+	m_desiredYmin 	+= Ay_units;
+
+        UpdateAll();
+
+#ifdef MATHPLOT_DO_LOGGING
+        wxLogMessage(_("[mpWindow::OnMouseMove] Ax:%i Ay:%i m_posX:%f m_posY:%f"),Ax,Ay,m_posX,m_posY);
+#endif
+    } else {
+        if (event.m_leftDown) {
+            if (m_movingInfoLayer == NULL) {
+                wxClientDC dc(this);
+                wxPen pen(*wxBLACK, 1, wxDOT);
+                dc.SetPen(pen);
+                dc.SetBrush(*wxTRANSPARENT_BRUSH);
+                dc.DrawRectangle(m_mouseLClick_X, m_mouseLClick_Y, event.GetX() - m_mouseLClick_X, event.GetY() - m_mouseLClick_Y);
+            } else {
+                wxPoint moveVector(event.GetX() - m_mouseLClick_X, event.GetY() - m_mouseLClick_Y);
+                m_movingInfoLayer->Move(moveVector);
+            }
+            UpdateAll();
+        } else {
+            wxLayerList::iterator li;
+            for (li = m_layers.begin(); li != m_layers.end(); li++) {
+                if ((*li)->IsInfo() && (*li)->IsVisible()) {
+                    mpInfoLayer* tmpLyr = (mpInfoLayer*) (*li);
+                    tmpLyr->UpdateInfo(*this, event);
+                    // UpdateAll();
+					RefreshRect(tmpLyr->GetRectangle());
+                }
+            }
+            /* if (m_coordTooltip) {
+                wxString toolTipContent;
+                toolTipContent.Printf(_("X = %f\nY = %f"), p2x(event.GetX()), p2y(event.GetY()));
+                wxTipWindow** ptr = NULL;
+                wxRect rectBounds(event.GetX(), event.GetY(), 5, 5);
+                wxTipWindow* tip = new wxTipWindow(this, toolTipContent, 100, ptr, &rectBounds);
+                
+            } */
+        }
+    }
+    event.Skip();
+}
+
+void mpWindow::OnMouseLeftDown (wxMouseEvent &event)
+{
+    m_mouseLClick_X = event.GetX();
+    m_mouseLClick_Y = event.GetY();
+#ifdef MATHPLOT_DO_LOGGING
+    wxLogMessage(_("mpWindow::OnMouseLeftDown() X = %d , Y = %d"), event.GetX(), event.GetY());/*m_mouseLClick_X, m_mouseLClick_Y);*/
+#endif
+    wxPoint pointClicked = event.GetPosition(); 
+    m_movingInfoLayer = IsInsideInfoLayer(pointClicked);
+    if (m_movingInfoLayer != NULL) {
+#ifdef MATHPLOT_DO_LOGGING
+        wxLogMessage(_("mpWindow::OnMouseLeftDown() started moving layer %lx"), (long int) m_movingInfoLayer);/*m_mouseLClick_X, m_mouseLClick_Y);*/
+#endif
+    }
+    event.Skip();
+}
+
+void mpWindow::OnMouseLeftRelease (wxMouseEvent &event)
+{
+    wxPoint release(event.GetX(), event.GetY());
+    wxPoint press(m_mouseLClick_X, m_mouseLClick_Y);
+    if (m_movingInfoLayer != NULL) {
+        m_movingInfoLayer->UpdateReference();
+        m_movingInfoLayer = NULL;
+    } else {
+        if (release != press) {
+            ZoomRect(press, release);
+        } /*else {
+            if (m_coordTooltip) {
+                wxString toolTipContent;
+                toolTipContent.Printf(_("X = %f\nY = %f"), p2x(event.GetX()), p2y(event.GetY()));
+                SetToolTip(toolTipContent);
+            }
+        } */
+    }
+    event.Skip();
+}
+
+void mpWindow::Fit()
+{
+	if (UpdateBBox())
+		Fit(m_minX,m_maxX,m_minY,m_maxY );
+}
+
+
+// JL
+void mpWindow::Fit(double xMin, double xMax, double yMin, double yMax, wxCoord *printSizeX,wxCoord *printSizeY)
+{
+	// Save desired borders:
+	m_desiredXmin=xMin; m_desiredXmax=xMax;
+	m_desiredYmin=yMin; m_desiredYmax=yMax;
+
+	if (printSizeX!=NULL && printSizeY!=NULL)
+	{
+		// Printer:
+		m_scrX = *printSizeX;
+		m_scrY = *printSizeY;
+	}
+	else
+	{
+		// Normal case (screen):
+		GetClientSize( &m_scrX,&m_scrY);
+	}
+
+	double Ax,Ay;
+
+	Ax = xMax - xMin;
+	Ay = yMax - yMin;
+
+	m_scaleX = (Ax!=0) ? (m_scrX - m_marginLeft - m_marginRight)/Ax : 1; //m_scaleX = (Ax!=0) ? m_scrX/Ax : 1;
+	m_scaleY = (Ay!=0) ? (m_scrY - m_marginTop - m_marginBottom)/Ay : 1; //m_scaleY = (Ay!=0) ? m_scrY/Ay : 1;
+
+	if (m_lockaspect)
+	{
+#ifdef MATHPLOT_DO_LOGGING
+	wxLogMessage(_("mpWindow::Fit()(lock) m_scaleX=%f,m_scaleY=%f"), m_scaleX,m_scaleY);
+#endif
+		// Keep the lowest "scale" to fit the whole range required by that axis (to actually "fit"!):
+		double s = m_scaleX < m_scaleY ? m_scaleX : m_scaleY;
+		m_scaleX = s;
+		m_scaleY = s;
+	}
+
+	// Adjusts corner coordinates: This should be simply:
+	//   m_posX = m_minX;
+	//   m_posY = m_maxY;
+	// But account for centering if we have lock aspect:
+	m_posX = (xMin+xMax)/2 - ((m_scrX - m_marginLeft - m_marginRight)/2 + m_marginLeft)/m_scaleX ; // m_posX = (xMin+xMax)/2 - (m_scrX/2)/m_scaleX;
+//	m_posY = (yMin+yMax)/2 + ((m_scrY - m_marginTop - m_marginBottom)/2 - m_marginTop)/m_scaleY;  // m_posY = (yMin+yMax)/2 + (m_scrY/2)/m_scaleY;
+	m_posY = (yMin+yMax)/2 + ((m_scrY - m_marginTop - m_marginBottom)/2 + m_marginTop)/m_scaleY;  // m_posY = (yMin+yMax)/2 + (m_scrY/2)/m_scaleY;
+
+#ifdef MATHPLOT_DO_LOGGING
+	wxLogMessage(_("mpWindow::Fit() m_desiredXmin=%f m_desiredXmax=%f  m_desiredYmin=%f m_desiredYmax=%f"), xMin,xMax,yMin,yMax);
+	wxLogMessage(_("mpWindow::Fit() m_scaleX = %f , m_scrX = %d,m_scrY=%d, Ax=%f, Ay=%f, m_posX=%f, m_posY=%f"), m_scaleX, m_scrX,m_scrY, Ax,Ay,m_posX,m_posY);
+#endif
+
+	// It is VERY IMPORTANT to DO NOT call Refresh if we are drawing to the printer!!
+	// Otherwise, the DC dimensions will be those of the window instead of the printer device
+	if (printSizeX==NULL || printSizeY==NULL)
+		UpdateAll();
+}
+
+// Patch ngpaton
+void mpWindow::DoZoomInXCalc (const int staticXpixel)
+{
+	// Preserve the position of the clicked point:
+	double staticX = p2x( staticXpixel );
+	// Zoom in:
+	m_scaleX = m_scaleX * zoomIncrementalFactor;
+	// Adjust the new m_posx
+	m_posX = staticX - (staticXpixel / m_scaleX);
+    // Adjust desired
+	m_desiredXmin = m_posX;
+	m_desiredXmax = m_posX + (m_scrX - (m_marginLeft + m_marginRight)) / m_scaleX; 
+#ifdef MATHPLOT_DO_LOGGING
+	wxLogMessage(_("mpWindow::DoZoomInXCalc() prior X coord: (%f), new X coord: (%f) SHOULD BE EQUAL!!"), staticX, p2x(staticXpixel));
+#endif
+}
+
+void mpWindow::DoZoomInYCalc (const int staticYpixel)
+{
+	// Preserve the position of the clicked point:
+	double staticY = p2y( staticYpixel );
+	// Zoom in:
+	m_scaleY = m_scaleY * zoomIncrementalFactor;
+	// Adjust the new m_posy:
+	m_posY = staticY + (staticYpixel / m_scaleY);
+    // Adjust desired
+	m_desiredYmax = m_posY;
+	m_desiredYmin = m_posY - (m_scrY - (m_marginTop + m_marginBottom)) / m_scaleY; 
+#ifdef MATHPLOT_DO_LOGGING
+	wxLogMessage(_("mpWindow::DoZoomInYCalc() prior Y coord: (%f), new Y coord: (%f) SHOULD BE EQUAL!!"), staticY, p2y(staticYpixel));
+#endif
+}
+
+void mpWindow::DoZoomOutXCalc  (const int staticXpixel)
+{
+	// Preserve the position of the clicked point:
+	double staticX = p2x( staticXpixel );
+	// Zoom out:
+	m_scaleX = m_scaleX / zoomIncrementalFactor;
+	// Adjust the new m_posx/y:
+	m_posX = staticX - (staticXpixel / m_scaleX);
+    // Adjust desired
+	m_desiredXmin = m_posX;
+	m_desiredXmax = m_posX + (m_scrX - (m_marginLeft + m_marginRight)) / m_scaleX; 
+#ifdef MATHPLOT_DO_LOGGING
+	wxLogMessage(_("mpWindow::DoZoomOutXCalc() prior X coord: (%f), new X coord: (%f) SHOULD BE EQUAL!!"), staticX, p2x(staticXpixel));
+#endif
+}
+
+void mpWindow::DoZoomOutYCalc  (const int staticYpixel)
+{
+	// Preserve the position of the clicked point:
+	double staticY = p2y( staticYpixel );
+	// Zoom out:
+	m_scaleY = m_scaleY / zoomIncrementalFactor;
+	// Adjust the new m_posx/y:
+	m_posY = staticY + (staticYpixel / m_scaleY);
+    // Adjust desired
+	m_desiredYmax = m_posY;
+	m_desiredYmin = m_posY - (m_scrY - (m_marginTop + m_marginBottom)) / m_scaleY;
+#ifdef MATHPLOT_DO_LOGGING
+	wxLogMessage(_("mpWindow::DoZoomOutYCalc() prior Y coord: (%f), new Y coord: (%f) SHOULD BE EQUAL!!"), staticY, p2y(staticYpixel));
+#endif
+}
+
+
+void mpWindow::ZoomIn(const wxPoint& centerPoint )
+{
+	wxPoint	c(centerPoint);	
+	if (c == wxDefaultPosition)
+	{
+		GetClientSize(&m_scrX, &m_scrY);
+		c.x = (m_scrX - m_marginLeft - m_marginRight)/2 + m_marginLeft; // c.x = m_scrX/2;
+		c.y = (m_scrY - m_marginTop - m_marginBottom)/2 - m_marginTop; // c.y = m_scrY/2;
+}
+
+	// Preserve the position of the clicked point:
+	double prior_layer_x = p2x( c.x );
+	double prior_layer_y = p2y( c.y );
+
+	// Zoom in:
+	m_scaleX = m_scaleX * zoomIncrementalFactor;
+	m_scaleY = m_scaleY * zoomIncrementalFactor;
+
+	// Adjust the new m_posx/y:
+	m_posX = prior_layer_x - c.x / m_scaleX;
+	m_posY = prior_layer_y + c.y / m_scaleY;
+
+	m_desiredXmin = m_posX;
+	m_desiredXmax = m_posX + (m_scrX - m_marginLeft - m_marginRight) / m_scaleX; // m_desiredXmax = m_posX + m_scrX / m_scaleX;
+	m_desiredYmax = m_posY;
+	m_desiredYmin = m_posY - (m_scrY - m_marginTop - m_marginBottom) / m_scaleY; // m_desiredYmin = m_posY - m_scrY / m_scaleY;
+
+
+#ifdef MATHPLOT_DO_LOGGING
+	wxLogMessage(_("mpWindow::ZoomIn() prior coords: (%f,%f), new coords: (%f,%f) SHOULD BE EQUAL!!"), prior_layer_x,prior_layer_y, p2x(c.x),p2y(c.y));
+#endif
+
+	UpdateAll();
+}
+
+void mpWindow::ZoomOut(const wxPoint& centerPoint )
+{
+	wxPoint	c(centerPoint);	
+	if (c == wxDefaultPosition)
+	{
+		GetClientSize(&m_scrX, &m_scrY);
+		c.x = (m_scrX - m_marginLeft - m_marginRight)/2 + m_marginLeft; // c.x = m_scrX/2;
+		c.y = (m_scrY - m_marginTop - m_marginBottom)/2 - m_marginTop; // c.y = m_scrY/2;
+	}
+
+	// Preserve the position of the clicked point:
+	double prior_layer_x = p2x( c.x );
+	double prior_layer_y = p2y( c.y );
+
+	// Zoom out:
+	m_scaleX = m_scaleX / zoomIncrementalFactor;
+	m_scaleY = m_scaleY / zoomIncrementalFactor;
+
+	// Adjust the new m_posx/y:
+	m_posX = prior_layer_x - c.x / m_scaleX;
+	m_posY = prior_layer_y + c.y / m_scaleY;
+
+	m_desiredXmin = m_posX;
+	m_desiredXmax = m_posX + (m_scrX - m_marginLeft - m_marginRight) / m_scaleX; // m_desiredXmax = m_posX + m_scrX / m_scaleX;
+	m_desiredYmax = m_posY;
+	m_desiredYmin = m_posY - (m_scrY - m_marginTop - m_marginBottom) / m_scaleY; // m_desiredYmin = m_posY - m_scrY / m_scaleY;
+
+#ifdef MATHPLOT_DO_LOGGING
+	wxLogMessage(_("mpWindow::ZoomOut() prior coords: (%f,%f), new coords: (%f,%f) SHOULD BE EQUAL!!"), prior_layer_x,prior_layer_y, p2x(c.x),p2y(c.y));
+#endif
+    UpdateAll();
+}
+
+void mpWindow::ZoomInX()
+{
+    m_scaleX = m_scaleX * zoomIncrementalFactor;
+    UpdateAll();
+}
+
+void mpWindow::ZoomOutX()
+{
+    m_scaleX = m_scaleX / zoomIncrementalFactor;
+    UpdateAll();
+}
+
+void mpWindow::ZoomInY()
+{
+    m_scaleY = m_scaleY * zoomIncrementalFactor;
+    UpdateAll();
+}
+
+void mpWindow::ZoomOutY()
+{
+    m_scaleY = m_scaleY / zoomIncrementalFactor;
+    UpdateAll();
+}
+
+void mpWindow::ZoomRect(wxPoint p0, wxPoint p1)
+{
+	// Compute the 2 corners in graph coordinates:
+	double p0x = p2x(p0.x);
+	double p0y = p2y(p0.y);
+	double p1x = p2x(p1.x);
+	double p1y = p2y(p1.y);
+
+	// Order them:
+	double zoom_x_min = p0x<p1x ? p0x:p1x;
+	double zoom_x_max = p0x>p1x ? p0x:p1x;
+	double zoom_y_min = p0y<p1y ? p0y:p1y;
+	double zoom_y_max = p0y>p1y ? p0y:p1y;
+
+#ifdef MATHPLOT_DO_LOGGING
+	wxLogMessage(_("Zoom: (%f,%f)-(%f,%f)"),zoom_x_min,zoom_y_min,zoom_x_max,zoom_y_max);
+#endif
+
+	Fit(zoom_x_min,zoom_x_max,zoom_y_min,zoom_y_max);
+}
+
+void mpWindow::LockAspect(bool enable)
+{
+	m_lockaspect = enable;
+	m_popmenu.Check(mpID_LOCKASPECT, enable);
+
+	// Try to fit again with the new config:
+	Fit( m_desiredXmin, m_desiredXmax, m_desiredYmin, m_desiredYmax );
+}
+
+void mpWindow::OnShowPopupMenu(wxMouseEvent &event)
+{
+    // Only display menu if the user has not "dragged" the figure
+    if (m_enableMouseNavigation)
+    {
+        SetCursor( *wxSTANDARD_CURSOR );
+    }
+
+    if (!m_mouseMovedAfterRightClick)   // JLB
+    {
+        m_clickedX = event.GetX();
+        m_clickedY = event.GetY();
+        PopupMenu( &m_popmenu, event.GetX(), event.GetY());
+    }
+}
+
+void mpWindow::OnLockAspect(wxCommandEvent& WXUNUSED(event))
+{
+    LockAspect( !m_lockaspect );
+}
+
+void mpWindow::OnMouseHelp(wxCommandEvent& WXUNUSED(event))
+{
+    wxMessageBox(_("Supported Mouse commands:\n \
+        - Left button down + Mark area: Rectangular zoom\n \
+        - Right button down + Move: Pan (Move)\n \
+        - Wheel: Vertical scroll\n \
+        - Wheel + SHIFT: Horizontal scroll\n \
+        - Wheel + CTRL: Zoom in/out"),_("wxMathPlot help"),wxOK,this);
+}
+
+void mpWindow::OnFit(wxCommandEvent& WXUNUSED(event))
+{
+    Fit();
+}
+
+void mpWindow::OnCenter(wxCommandEvent& WXUNUSED(event))
+{
+	GetClientSize(&m_scrX, &m_scrY);
+        int centerX = (m_scrX - m_marginLeft - m_marginRight)/2; // + m_marginLeft; // c.x = m_scrX/2;
+	int centerY = (m_scrY - m_marginTop - m_marginBottom)/2; // - m_marginTop; // c.y = m_scrY/2;
+        SetPos( p2x(m_clickedX - centerX), p2y(m_clickedY - centerY) );
+	//SetPos( p2x(m_clickedX-m_scrX/2), p2y(m_clickedY-m_scrY/2) );  //SetPos( (double)(m_clickedX-m_scrX/2) / m_scaleX + m_posX, (double)(m_scrY/2-m_clickedY) / m_scaleY + m_posY);
+}
+
+void mpWindow::OnZoomIn(wxCommandEvent& WXUNUSED(event))
+{
+	ZoomIn( wxPoint(m_mouseRClick_X,m_mouseRClick_Y) );
+}
+
+void mpWindow::OnZoomOut(wxCommandEvent& WXUNUSED(event))
+{
+    ZoomOut();
+}
+
+void mpWindow::OnSize( wxSizeEvent& WXUNUSED(event) )
+{
+    // Try to fit again with the new window size:
+    Fit( m_desiredXmin, m_desiredXmax, m_desiredYmin, m_desiredYmax );
+#ifdef MATHPLOT_DO_LOGGING
+    wxLogMessage(_("mpWindow::OnSize() m_scrX = %d, m_scrY = %d"), m_scrX, m_scrY);
+#endif // MATHPLOT_DO_LOGGING
+}
+
+bool mpWindow::AddLayer( mpLayer* layer, bool refreshDisplay )
+{
+    if (layer != NULL) {
+	m_layers.push_back( layer );
+    	if (refreshDisplay) UpdateAll();
+    	return true;
+    	};
+    return false;
+}
+
+bool mpWindow::DelLayer(
+    mpLayer*    layer,
+    bool        alsoDeleteObject,
+    bool        refreshDisplay )
+{
+    wxLayerList::iterator layIt;
+    for (layIt = m_layers.begin(); layIt != m_layers.end(); layIt++) 
+    {
+    	if (*layIt == layer)
+	{
+	        // Also delete the object?
+        	if (alsoDeleteObject) 
+			delete *layIt;
+	    	m_layers.erase(layIt); // this deleted the reference only
+	    	if (refreshDisplay) 
+			UpdateAll();
+	    	return true;
+	}
+    }
+    return false;
+}
+
+void mpWindow::DelAllLayers( bool alsoDeleteObject, bool refreshDisplay)
+{
+	while ( m_layers.size()>0 )
+    {
+		// Also delete the object?
+		if (alsoDeleteObject) delete m_layers[0];
+		m_layers.erase( m_layers.begin() ); // this deleted the reference only
+    }
+	if (refreshDisplay)  UpdateAll();
+}
+
+// void mpWindow::DoPrepareDC(wxDC& dc)
+// {
+//     dc.SetDeviceOrigin(x2p(m_minX), y2p(m_maxY));
+// }
+
+void mpWindow::OnPaint( wxPaintEvent& WXUNUSED(event) )
+{
+    wxPaintDC dc(this);
+    dc.GetSize(&m_scrX, &m_scrY);   // This is the size of the visible area only!
+//     DoPrepareDC(dc);
+
+#ifdef MATHPLOT_DO_LOGGING
+    {
+        int px, py;
+        GetViewStart( &px, &py );
+        wxLogMessage(_("[mpWindow::OnPaint] vis.area:%ix%i px=%i py=%i"),m_scrX,m_scrY,px,py);
+    }
+#endif
+
+    // Selects direct or buffered draw:
+    wxDC    *trgDc;
+
+    // J.L.Blanco @ Aug 2007: Added double buffer support
+    if (m_enableDoubleBuffer)
+    {
+        if (m_last_lx!=m_scrX || m_last_ly!=m_scrY)
+        {
+            if (m_buff_bmp) delete m_buff_bmp;
+            m_buff_bmp = new wxBitmap(m_scrX,m_scrY);
+            m_buff_dc.SelectObject(*m_buff_bmp);
+            m_last_lx=m_scrX;
+            m_last_ly=m_scrY;
+        }
+        trgDc = &m_buff_dc;
+    }
+    else
+    {
+        trgDc = &dc;
+    }
+
+    // Draw background:
+    //trgDc->SetDeviceOrigin(0,0);
+    trgDc->SetPen( *wxTRANSPARENT_PEN );
+    wxBrush brush( GetBackgroundColour() );
+    trgDc->SetBrush( brush );
+	trgDc->SetTextForeground(m_fgColour);
+    trgDc->DrawRectangle(0,0,m_scrX,m_scrY);
+
+    // Draw all the layers:
+    //trgDc->SetDeviceOrigin( m_scrX>>1, m_scrY>>1);  // Origin at the center
+    wxLayerList::iterator li;
+    for (li = m_layers.begin(); li != m_layers.end(); li++)
+    {
+    	(*li)->Plot(*trgDc, *this);
+    };
+
+    // If doublebuffer, draw now to the window:
+    if (m_enableDoubleBuffer)
+    {
+        //trgDc->SetDeviceOrigin(0,0);
+        //dc.SetDeviceOrigin(0,0);  // Origin at the center
+        dc.Blit(0,0,m_scrX,m_scrY,trgDc,0,0);
+    }
+    
+/*    if (m_coordTooltip) {
+        wxString toolTipContent;
+        wxPoint mousePoint =  wxGetMousePosition();
+        toolTipContent.Printf(_("X = %f\nY = %f"), p2x(mousePoint.x), p2y(mousePoint.y));
+        SetToolTip(toolTipContent);
+    }*/
+    // If scrollbars are enabled, refresh them
+    if (m_enableScrollBars) {
+/*       m_scrollX = (int) floor((m_posX - m_minX)*m_scaleX);
+       m_scrollY = (int) floor((m_maxY - m_posY )*m_scaleY);
+       Scroll(m_scrollX, m_scrollY);*/
+       // Scroll(x2p(m_posX), y2p(m_posY));
+//             SetVirtualSize((int) ((m_maxX - m_minX)*m_scaleX), (int) ((m_maxY - m_minY)*m_scaleY));
+//         int centerX = (m_scrX - m_marginLeft - m_marginRight)/2; // + m_marginLeft; // c.x = m_scrX/2;
+// 	int centerY = (m_scrY - m_marginTop - m_marginBottom)/2; // - m_marginTop; // c.y = m_scrY/2;
+        /*SetScrollbars(1, 1, (int) ((m_maxX - m_minX)*m_scaleX), (int) ((m_maxY - m_minY)*m_scaleY));*/ //, x2p(m_posX + centerX/m_scaleX), y2p(m_posY - centerY/m_scaleY), true);
+}
+
+}
+
+// void mpWindow::OnScroll2(wxScrollWinEvent &event)
+// {
+// #ifdef MATHPLOT_DO_LOGGING
+//     wxLogMessage(_("[mpWindow::OnScroll2] Init: m_posX=%f m_posY=%f, sc_pos = %d"),m_posX,m_posY, event.GetPosition());
+// #endif
+//     // If scrollbars are not enabled, Skip operation
+//     if (!m_enableScrollBars) {
+//         event.Skip();
+//         return;
+//     }
+// //     m_scrollX = (int) floor((m_posX - m_minX)*m_scaleX);
+// //     m_scrollY = (int) floor((m_maxY - m_posY /*- m_minY*/)*m_scaleY);
+// //     Scroll(m_scrollX, m_scrollY);
+// 
+// //     GetClientSize( &m_scrX, &m_scrY);
+//     //Scroll(x2p(m_desiredXmin), y2p(m_desiredYmin));
+//     int pixelStep = 1;
+//     if (event.GetOrientation() == wxHORIZONTAL) {
+//         //m_desiredXmin -= (m_scrollX - event.GetPosition())/m_scaleX;
+//         //m_desiredXmax -= (m_scrollX - event.GetPosition())/m_scaleX;
+//         m_posX -= (m_scrollX - event.GetPosition())/m_scaleX;
+//         m_scrollX = event.GetPosition();
+//     }
+//     Fit(m_desiredXmin, m_desiredXmax, m_desiredYmin, m_desiredYmax);
+// // /*    int pixelStep = 1;
+// //     if (event.GetOrientation() == wxHORIZONTAL) {
+// //         m_posX 		-= (px - event.GetPosition())/m_scaleX;//(pixelStep/m_scaleX);
+// // 	m_desiredXmax 	-= (px - event.GetPosition())/m_scaleX;//(pixelStep/m_scaleX);
+// // 	m_desiredXmin 	-= (px - event.GetPosition())/m_scaleX;//(pixelStep/m_scaleX);
+// //         //SetPosX( (double)px / GetScaleX() + m_minX + (double)(width>>1)/GetScaleX());
+// // //         m_posX = p2x(px); //m_minX + (double)(px /*+ (m_scrX)*/)/GetScaleX();
+// //     } else {
+// //         m_posY 		+= (py - event.GetPosition())/m_scaleY;//(pixelStep/m_scaleY);
+// // 	m_desiredYmax	+= (py - event.GetPosition())/m_scaleY;//(pixelStep/m_scaleY);
+// // 	m_desiredYmax	+= (py - event.GetPosition())/m_scaleY;//(pixelStep/m_scaleY);
+// //         //SetPosY( m_maxY - (double)py / GetScaleY() - (double)(height>>1)/GetScaleY());
+// //         //m_posY = m_maxY - (double)py / GetScaleY() - (double)(height>>1)/GetScaleY();
+// // //         m_posY = p2y(py);//m_maxY - (double)(py /*+ (m_scrY)*/)/GetScaleY();
+// //     }*/
+// #ifdef MATHPLOT_DO_LOGGING
+//     int px, py;
+//     GetViewStart( &px, &py);
+//     wxLogMessage(_("[mpWindow::OnScroll2] End:  m_posX = %f, m_posY = %f, px = %f, py = %f"),m_posX, m_posY, px, py);
+// #endif
+// 
+//     UpdateAll();
+// //     event.Skip();
+// }
+
+void mpWindow::SetMPScrollbars(bool status)
+{
+    // Temporary behaviour: always disable scrollbars
+    m_enableScrollBars = status; //false;
+    if (status == false)
+    {
+        SetScrollbar(wxHORIZONTAL, 0, 0, 0);
+        SetScrollbar(wxVERTICAL, 0, 0, 0);
+    }
+    // else the scroll bars will be updated in UpdateAll();
+    UpdateAll();
+
+//     EnableScrolling(false, false);
+//     m_enableScrollBars = status;
+//     EnableScrolling(status, status);
+/*    m_scrollX = (int) floor((m_posX - m_minX)*m_scaleX);
+    m_scrollY = (int) floor((m_posY - m_minY)*m_scaleY);*/
+//     int scrollWidth = (int) floor((m_maxX - m_minX)*m_scaleX) - m_scrX;
+//     int scrollHeight = (int) floor((m_minY - m_maxY)*m_scaleY) - m_scrY;
+    
+// /*    m_scrollX = (int) floor((m_posX - m_minX)*m_scaleX);
+//     m_scrollY = (int) floor((m_maxY - m_posY /*- m_minY*/)*m_scaleY);
+//     int scrollWidth = (int) floor(((m_maxX - m_minX) - (m_desiredXmax - m_desiredXmin))*m_scaleX);
+//     int scrollHeight = (int) floor(((m_maxY - m_minY) - (m_desiredYmax - m_desiredYmin))*m_scaleY);
+// #ifdef MATHPLOT_DO_LOGGING
+//     wxLogMessage(_("mpWindow::SetMPScrollbars() scrollWidth = %d, scrollHeight = %d"), scrollWidth, scrollHeight);
+// #endif
+//     if(status) {
+//         SetScrollbars(1,
+//                       1,
+//                       scrollWidth,
+//                       scrollHeight,
+//                       m_scrollX,
+//                       m_scrollY); 
+// //         SetVirtualSize((int) (m_maxX - m_minX), (int) (m_maxY - m_minY));
+//     }
+//     Refresh(false);*/
+};
+
+bool mpWindow::UpdateBBox()
+{
+    bool first = TRUE;
+
+    for (wxLayerList::iterator li = m_layers.begin(); li != m_layers.end(); li++)
+    {
+        mpLayer* f = *li;
+
+        if (f->HasBBox())
+        {
+            if (first)
+            {
+                first = FALSE;
+                m_minX = f->GetMinX(); m_maxX=f->GetMaxX();
+                m_minY = f->GetMinY(); m_maxY=f->GetMaxY();
+            }
+            else
+            {
+                if (f->GetMinX()<m_minX) m_minX=f->GetMinX(); if (f->GetMaxX()>m_maxX) m_maxX=f->GetMaxX();
+                if (f->GetMinY()<m_minY) m_minY=f->GetMinY(); if (f->GetMaxY()>m_maxY) m_maxY=f->GetMaxY();
+            }
+        }
+        //node = node->GetNext();
+    }
+#ifdef MATHPLOT_DO_LOGGING
+	wxLogDebug(wxT("[mpWindow::UpdateBBox] Bounding box: Xmin = %f, Xmax = %f, Ymin = %f, YMax = %f"), m_minX, m_maxX, m_minY, m_maxY);
+#endif // MATHPLOT_DO_LOGGING
+    return first == FALSE;
+}
+
+// void mpWindow::UpdateAll()
+// {
+    // GetClientSize( &m_scrX,&m_scrY);
+/*    if (m_enableScrollBars) {
+        // The "virtual size" of the scrolled window:
+        const int sx = (int)((m_maxX - m_minX) * GetScaleX());
+        const int sy = (int)((m_maxY - m_minY) * GetScaleY());
+	SetVirtualSize(sx, sy);
+	SetScrollRate(1, 1);*/
+//         const int px = (int)((GetPosX() - m_minX) * GetScaleX());// - m_scrX); //(cx>>1));
+
+        // J.L.Blanco, Aug 2007: Formula fixed:
+//         const int py = (int)((m_maxY - GetPosY()) * GetScaleY());// - m_scrY); //(cy>>1));
+//         int px, py;
+//         GetViewStart(&px0, &py0);
+// 	px = (int)((m_posX - m_minX)*m_scaleX);
+// 	py = (int)((m_maxY - m_posY)*m_scaleY);
+
+//         SetScrollbars( 1, 1, sx - m_scrX, sy - m_scrY, px, py, TRUE);
+//     }
+
+// Working code
+// 	UpdateBBox();
+//    Refresh( FALSE );
+// end working code
+
+// Old version
+/*   bool box = UpdateBBox();
+    if (box)
+{
+        int cx, cy;
+        GetClientSize( &cx, &cy);
+
+        // The "virtual size" of the scrolled window:
+        const int sx = (int)((m_maxX - m_minX) * GetScaleX());
+        const int sy = (int)((m_maxY - m_minY) * GetScaleY());
+
+        const int px = (int)((GetPosX() - m_minX) * GetScaleX() - (cx>>1));
+
+        // J.L.Blanco, Aug 2007: Formula fixed:
+        const int py = (int)((m_maxY - GetPosY()) * GetScaleY() - (cy>>1));
+
+        SetScrollbars( 1, 1, sx, sy, px, py, TRUE);
+
+#ifdef MATHPLOT_DO_LOGGING
+        wxLogMessage(_("[mpWindow::UpdateAll] Size:%ix%i ScrollBars:%i,%i"),sx,sy,px,py);
+#endif
+}
+
+    FitInside();
+    Refresh( FALSE );
+*/
+// }
+
+void mpWindow::UpdateAll()
+{
+	if (UpdateBBox())
+    {
+        if (m_enableScrollBars)
+        {
+            int cx, cy;
+            GetClientSize( &cx, &cy);
+            // Do x scroll bar 
+            {
+                // Convert margin sizes from pixels to coordinates
+                double leftMargin  = m_marginLeft / m_scaleX;
+                // Calculate the range in coords that we want to scroll over
+                double maxX = (m_desiredXmax > m_maxX) ? m_desiredXmax : m_maxX;
+                double minX = (m_desiredXmin < m_minX) ? m_desiredXmin : m_minX;
+                if ((m_posX + leftMargin) < minX) 
+                    minX = m_posX + leftMargin;
+                // Calculate scroll bar size and thumb position
+                int sizeX = (int) ((maxX - minX) * m_scaleX);
+                int thumbX = (int)(((m_posX + leftMargin) - minX) * m_scaleX);
+                SetScrollbar(wxHORIZONTAL, thumbX, cx - (m_marginRight + m_marginLeft), sizeX);
+            }
+            // Do y scroll bar 
+            {
+                // Convert margin sizes from pixels to coordinates
+                double topMargin = m_marginTop / m_scaleY;
+                // Calculate the range in coords that we want to scroll over
+                double maxY = (m_desiredYmax > m_maxY) ? m_desiredYmax : m_maxY;
+                if ((m_posY - topMargin) > maxY) 
+                    maxY = m_posY - topMargin;
+                double minY = (m_desiredYmin < m_minY) ? m_desiredYmin : m_minY;
+                // Calculate scroll bar size and thumb position
+                int sizeY = (int)((maxY - minY) * m_scaleY);
+                int thumbY = (int)((maxY - (m_posY - topMargin)) * m_scaleY);
+                SetScrollbar(wxVERTICAL, thumbY, cy - (m_marginTop + m_marginBottom), sizeY);
+            }
+        }
+    }
+
+    Refresh( FALSE );
+}
+
+void mpWindow::DoScrollCalc    (const int position, const int orientation)
+{
+    if (orientation == wxVERTICAL)
+    {
+        // Y axis
+        // Get top margin in coord units
+        double topMargin = m_marginTop / m_scaleY;
+        // Calculate maximum Y coord to be shown in the graph
+        double maxY = m_desiredYmax > m_maxY ? m_desiredYmax  : m_maxY;
+        // Set new position
+        SetPosY((maxY - (position / m_scaleY)) + topMargin);
+    }
+    else
+    {
+        // X Axis
+        // Get left margin in coord units
+        double leftMargin  = m_marginLeft / m_scaleX;
+        // Calculate minimum X coord to be shown in the graph
+        double minX = (m_desiredXmin < m_minX) ? m_desiredXmin : m_minX;
+        // Set new position
+        SetPosX((minX + (position / m_scaleX)) - leftMargin);
+    }
+}
+
+void mpWindow::OnScrollThumbTrack (wxScrollWinEvent &event)
+{
+    DoScrollCalc(event.GetPosition(), event.GetOrientation());
+}
+
+void mpWindow::OnScrollPageUp (wxScrollWinEvent &event)
+{
+    int scrollOrientation = event.GetOrientation();
+    // Get position before page up
+    int position = GetScrollPos(scrollOrientation);
+    // Get thumb size
+    int thumbSize = GetScrollThumb(scrollOrientation);
+    // Need to adjust position by a page
+    position -= thumbSize;
+    if (position < 0)
+        position = 0;
+   
+    DoScrollCalc(position, scrollOrientation);
+}
+void mpWindow::OnScrollPageDown (wxScrollWinEvent &event)
+{
+    int scrollOrientation = event.GetOrientation();
+    // Get position before page up
+    int position = GetScrollPos(scrollOrientation);
+    // Get thumb size
+    int thumbSize = GetScrollThumb(scrollOrientation);
+    // Get scroll range
+    int scrollRange = GetScrollRange(scrollOrientation);
+    // Need to adjust position by a page
+    position += thumbSize;
+    if (position > (scrollRange - thumbSize))
+        position = scrollRange - thumbSize;
+
+    DoScrollCalc(position, scrollOrientation);
+}
+
+void mpWindow::OnScrollLineUp     (wxScrollWinEvent &event)
+{
+    int scrollOrientation = event.GetOrientation();
+    // Get position before page up
+    int position = GetScrollPos(scrollOrientation);
+    // Need to adjust position by a line
+    position -= mpSCROLL_NUM_PIXELS_PER_LINE;
+    if (position < 0)
+        position = 0;
+
+    DoScrollCalc(position, scrollOrientation);
+}
+
+void mpWindow::OnScrollLineDown   (wxScrollWinEvent &event)
+{
+    int scrollOrientation = event.GetOrientation();
+    // Get position before page up
+    int position = GetScrollPos(scrollOrientation);
+    // Get thumb size
+    int thumbSize = GetScrollThumb(scrollOrientation);
+    // Get scroll range
+    int scrollRange = GetScrollRange(scrollOrientation);
+    // Need to adjust position by a page
+    position += mpSCROLL_NUM_PIXELS_PER_LINE;
+    if (position > (scrollRange - thumbSize))
+        position = scrollRange - thumbSize;
+
+    DoScrollCalc(position, scrollOrientation);
+}
+
+void mpWindow::OnScrollTop(wxScrollWinEvent &event) 
+{
+    DoScrollCalc(0, event.GetOrientation());
+}
+
+void mpWindow::OnScrollBottom(wxScrollWinEvent &event)
+{
+    int scrollOrientation = event.GetOrientation();
+    // Get thumb size
+    int thumbSize = GetScrollThumb(scrollOrientation);
+    // Get scroll range
+    int scrollRange = GetScrollRange(scrollOrientation);
+
+    DoScrollCalc(scrollRange - thumbSize, scrollOrientation);
+}
+// End patch ngpaton
+
+void mpWindow::SetScaleX(double scaleX)
+{
+    if (scaleX!=0) m_scaleX=scaleX;
+    UpdateAll();
+}
+
+// New methods implemented by Davide Rondini
+
+unsigned int mpWindow::CountLayers()
+{
+    //wxNode *node = m_layers.GetFirst();
+    unsigned int layerNo = 0;
+    for(wxLayerList::iterator li = m_layers.begin(); li != m_layers.end(); li++)//while(node)
+    	{
+        if ((*li)->HasBBox()) layerNo++;
+	// node = node->GetNext();
+    	};
+    return layerNo;
+}
+
+mpLayer* mpWindow::GetLayer(int position)
+{
+    if ((position >= (int) m_layers.size()) || position < 0) return NULL;
+    return m_layers[position];
+}
+
+mpLayer* mpWindow::GetLayerByName( const wxString &name)
+{
+    for (wxLayerList::iterator it=m_layers.begin();it!=m_layers.end();it++)
+        if (! (*it)->GetName().Cmp( name ) )
+            return *it;
+    return NULL;    // Not found
+}
+
+void mpWindow::GetBoundingBox(double* bbox)
+{
+	bbox[0] = m_minX;
+	bbox[1] = m_maxX;
+	bbox[2] = m_minY;
+	bbox[3] = m_maxY;
+}
+
+bool mpWindow::SaveScreenshot(const wxString& filename, int type, wxSize imageSize, bool fit)
+{
+	int sizeX, sizeY;
+	int bk_scrX, bk_scrY;
+	if (imageSize == wxDefaultSize) {
+		sizeX = m_scrX;
+		sizeY = m_scrY;
+	} else {
+		sizeX = imageSize.x;
+		sizeY = imageSize.y;
+		bk_scrX = m_scrX;
+		bk_scrY = m_scrY;
+		SetScr(sizeX, sizeY);
+	}
+
+    wxBitmap screenBuffer(sizeX,sizeY);
+    wxMemoryDC screenDC;
+    screenDC.SelectObject(screenBuffer);
+    screenDC.SetPen( *wxTRANSPARENT_PEN );
+    wxBrush brush( GetBackgroundColour() );
+    screenDC.SetBrush( brush );
+    screenDC.DrawRectangle(0,0,sizeX,sizeY);
+
+	if (fit) {
+		Fit(m_minX, m_maxX, m_minY, m_maxY, &sizeX, &sizeY);
+	} else {
+		Fit(m_desiredXmin, m_desiredXmax, m_desiredYmin, m_desiredYmax, &sizeX, &sizeY);
+	}
+    // Draw all the layers:
+    wxLayerList::iterator li;
+    for (li = m_layers.begin(); li != m_layers.end(); li++)
+    	(*li)->Plot(screenDC, *this);
+
+	if (imageSize != wxDefaultSize) {
+		// Restore dimensions
+		SetScr(bk_scrX, bk_scrY);
+                Fit(m_desiredXmin, m_desiredXmax, m_desiredYmin, m_desiredYmax, &bk_scrX, &bk_scrY);
+		UpdateAll();
+	}
+    // Once drawing is complete, actually save screen shot
+    wxImage screenImage = screenBuffer.ConvertToImage();
+    return screenImage.SaveFile(filename, (wxBitmapType) type);
+}
+
+void mpWindow::SetMargins(int top, int right, int bottom, int left)
+{
+    m_marginTop = top;
+    m_marginRight = right;
+    m_marginBottom = bottom;
+    m_marginLeft = left;
+}
+
+mpInfoLayer* mpWindow::IsInsideInfoLayer(wxPoint& point)
+{
+    wxLayerList::iterator li;
+    for (li = m_layers.begin(); li != m_layers.end(); li++) {
+#ifdef MATHPLOT_DO_LOGGING
+        wxLogMessage(_("mpWindow::IsInsideInfoLayer() examinining layer = %p"), (*li));
+#endif // MATHPLOT_DO_LOGGING
+        if ((*li)->IsInfo()) {
+            mpInfoLayer* tmpLyr = (mpInfoLayer*) (*li);
+#ifdef MATHPLOT_DO_LOGGING
+            wxLogMessage(_("mpWindow::IsInsideInfoLayer() layer = %p"), (*li));
+#endif // MATHPLOT_DO_LOGGING
+            if (tmpLyr->Inside(point)) {
+                return tmpLyr;
+            }
+        }
+    }
+    return NULL;
+}
+
+void mpWindow::SetLayerVisible(const wxString &name, bool viewable)
+{
+	mpLayer* lx = GetLayerByName(name);
+	if ( lx ) {
+		lx->SetVisible(viewable);
+		UpdateAll();
+	}
+}
+
+bool mpWindow::IsLayerVisible(const wxString &name )
+{
+	mpLayer* lx = GetLayerByName(name);
+	return (lx) ? lx->IsVisible() : false;
+}
+
+void mpWindow::SetLayerVisible(const unsigned int position, bool viewable)
+{
+	mpLayer* lx = GetLayer(position);
+	if ( lx ) {
+		lx->SetVisible(viewable);
+		UpdateAll();
+	}
+}
+
+bool mpWindow::IsLayerVisible(const unsigned int position )
+{
+	mpLayer* lx = GetLayer(position);
+	return (lx) ? lx->IsVisible() : false;
+}
+
+void mpWindow::SetColourTheme(const wxColour& bgColour, const wxColour& drawColour, const wxColour& axesColour)
+{
+	 SetBackgroundColour(bgColour);
+	 SetForegroundColour(drawColour);
+	 m_bgColour = bgColour;
+	 m_fgColour = drawColour;
+	 m_axColour = axesColour;
+	// cycle between layers to set colours and properties to them
+    wxLayerList::iterator li;
+    for (li = m_layers.begin(); li != m_layers.end(); li++) {
+		if ((*li)->GetLayerType() == mpLAYER_AXIS) {
+			wxPen axisPen = (*li)->GetPen(); // Get the old pen to modify only colour, not style or width
+			axisPen.SetColour(axesColour);
+			(*li)->SetPen(axisPen);
+		}
+		if ((*li)->GetLayerType() == mpLAYER_INFO) {
+			wxPen infoPen = (*li)->GetPen(); // Get the old pen to modify only colour, not style or width
+			infoPen.SetColour(drawColour);
+			(*li)->SetPen(infoPen);
+		}
+	}
+}
+
+// void mpWindow::EnableCoordTooltip(bool value)
+// {
+//      m_coordTooltip = value;
+// //      if (value) GetToolTip()->SetDelay(100);
+// }
+
+/*
+double mpWindow::p2x(wxCoord pixelCoordX, bool drawOutside )
+{
+    if (drawOutside) {
+        return m_posX + pixelCoordX/m_scaleX;
+    }
+    // Draw inside margins
+    double marginScaleX = ((double)(m_scrX - m_marginLeft - m_marginRight))/m_scrX;
+    return m_marginLeft + (m_posX + pixelCoordX/m_scaleX)/marginScaleX;
+}
+
+double mpWindow::p2y(wxCoord pixelCoordY, bool drawOutside )
+{
+    if (drawOutside) {
+        return m_posY - pixelCoordY/m_scaleY;
+    }
+    // Draw inside margins
+    double marginScaleY = ((double)(m_scrY - m_marginTop - m_marginBottom))/m_scrY;
+    return m_marginTop + (m_posY - pixelCoordY/m_scaleY)/marginScaleY;
+}
+
+wxCoord mpWindow::x2p(double x, bool drawOutside)
+{
+    if (drawOutside) {
+        return (wxCoord) ((x-m_posX) * m_scaleX);
+    }
+    // Draw inside margins
+    double marginScaleX = ((double)(m_scrX - m_marginLeft - m_marginRight))/m_scrX;
+#ifdef MATHPLOT_DO_LOGGING
+    wxLogMessage(wxT("x2p ScrX = %d, marginRight = %d, marginLeft = %d, marginScaleX = %f"), m_scrX, m_marginRight, m_marginLeft,  marginScaleX);
+#endif // MATHPLOT_DO_LOGGING
+    return (wxCoord) (int)(((x-m_posX) * m_scaleX)*marginScaleX) - m_marginLeft;
+}
+
+wxCoord mpWindow::y2p(double y, bool drawOutside)
+{
+    if (drawOutside) {
+        return (wxCoord) ( (m_posY-y) * m_scaleY);
+    }
+    // Draw inside margins
+    double marginScaleY = ((double)(m_scrY - m_marginTop - m_marginBottom))/m_scrY;
+#ifdef MATHPLOT_DO_LOGGING
+    wxLogMessage(wxT("y2p ScrY = %d, marginTop = %d, marginBottom = %d, marginScaleY = %f"), m_scrY, m_marginTop, m_marginBottom, marginScaleY);
+#endif // MATHPLOT_DO_LOGGING
+    return (wxCoord) ((int)((m_posY-y) * m_scaleY)*marginScaleY) - m_marginTop;
+}
+*/
+
+
+//-----------------------------------------------------------------------------
+// mpFXYVector implementation - by Jose Luis Blanco (AGO-2007)
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(mpFXYVector, mpFXY)
+
+// Constructor
+mpFXYVector::mpFXYVector(wxString name, int flags ) : mpFXY(name,flags)
+{
+    m_index = 0;
+    m_minX  = -1;
+    m_maxX  = 1;
+    m_minY  = -1;
+    m_maxY  = 1;
+    m_type = mpLAYER_PLOT;
+}
+
+void mpFXYVector::Rewind()
+{
+    m_index = 0;
+}
+
+bool mpFXYVector::GetNextXY(double & x, double & y)
+{
+    if (m_index>=m_xs.size())
+        return FALSE;
+    else
+    {
+        x = m_xs[m_index];
+        y = m_ys[m_index++];
+        return m_index<=m_xs.size();
+    }
+}
+
+void mpFXYVector::Clear()
+{
+    m_xs.clear();
+    m_ys.clear();
+}
+
+void mpFXYVector::SetData( const std::vector<double> &xs,const std::vector<double> &ys)
+{
+	// Check if the data vectora are of the same size
+	if (xs.size() != ys.size()) {
+		wxLogError(_("wxMathPlot error: X and Y vector are not of the same length!"));
+		return;
+	}
+    // Copy the data:
+    m_xs = xs;
+    m_ys = ys;
+
+
+    // Update internal variables for the bounding box.
+    if (xs.size()>0)
+    {
+        m_minX  = xs[0];
+        m_maxX  = xs[0];
+        m_minY  = ys[0];
+        m_maxY  = ys[0];
+
+        std::vector<double>::const_iterator  it;
+
+        for (it=xs.begin();it!=xs.end();it++)
+        {
+            if (*it<m_minX) m_minX=*it;
+            if (*it>m_maxX) m_maxX=*it;
+        }
+        for (it=ys.begin();it!=ys.end();it++)
+        {
+            if (*it<m_minY) m_minY=*it;
+            if (*it>m_maxY) m_maxY=*it;
+        }
+        m_minX-=0.5f;
+        m_minY-=0.5f;
+        m_maxX+=0.5f;
+        m_maxY+=0.5f;
+    }
+    else
+    {
+        m_minX  = -1;
+        m_maxX  = 1;
+        m_minY  = -1;
+        m_maxY  = 1;
+    }
+}
+
+//-----------------------------------------------------------------------------
+// mpText - provided by Val Greene
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(mpText, mpLayer)
+
+
+/** @param name text to be displayed
+@param offsetx x position in percentage (0-100)
+@param offsetx y position in percentage (0-100)
+*/
+mpText::mpText( wxString name, int offsetx, int offsety )
+{
+    SetName(name);
+
+    if (offsetx >= 0 && offsetx <= 100)
+        m_offsetx = offsetx;
+    else
+        m_offsetx = 5;
+
+    if (offsety >= 0 && offsety <= 100)
+        m_offsety = offsety;
+    else
+        m_offsetx = 50;
+    m_type = mpLAYER_INFO;
+}
+
+/** mpText Layer plot handler.
+This implementation will plot the text adjusted to the visible area.
+*/
+
+void mpText::Plot(wxDC & dc, mpWindow & w)
+{
+	if (m_visible) {
+		dc.SetPen(m_pen);
+		dc.SetFont(m_font);
+
+		wxCoord tw=0, th=0;
+		dc.GetTextExtent( GetName(), &tw, &th);
+
+	//     int left = -dc.LogicalToDeviceX(0);
+	//     int width = dc.LogicalToDeviceX(0) - left;
+	//     int bottom = dc.LogicalToDeviceY(0);
+	//     int height = bottom - -dc.LogicalToDeviceY(0);
+
+	/*    dc.DrawText( GetName(),
+		(int)((((float)width/100.0) * m_offsety) + left - (tw/2)),
+		(int)((((float)height/100.0) * m_offsetx) - bottom) );*/
+		int px = m_offsetx*(w.GetScrX() - w.GetMarginLeft() - w.GetMarginRight())/100;
+		int py = m_offsety*(w.GetScrY() - w.GetMarginTop() - w.GetMarginBottom())/100;
+		dc.DrawText( GetName(), px, py);
+	}
+}
+
+//-----------------------------------------------------------------------------
+// mpMarker - provided by R1kk3r
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(mpMarker, mpLayer)
+
+
+/** @param name text to be displayed
+@param atX x absolute position
+@param atY y absolute position
+*/
+mpMarker::mpMarker( wxString name, double atX, double atY )
+{
+    SetName(name);
+
+    mX = atX;
+    mY = atY;
+}
+
+
+void mpMarker::Plot(wxDC & dc, mpWindow & w)
+{
+    wxCoord     cx, cy, tw, th;
+    wxColour    cc;
+    wxString    ss;
+
+    // setup
+
+    dc.SetPen(m_pen);
+    dc.SetFont(m_font);
+
+    // part of setup is setting the text color
+
+    cc = m_pen.GetColour();
+    dc.SetTextForeground(cc);
+
+    // what to draw
+
+    ss = GetName();
+
+    // where to draw
+
+    dc.GetTextExtent(ss, &tw, &th);
+    cx = (wxCoord) ((mX - w.GetPosX()) * w.GetScaleX()) - (tw / 2);
+    cy = (wxCoord) ((w.GetPosY() - mY) * w.GetScaleY()) - (th / 2);
+
+    // do it
+
+    dc.DrawText( ss, cx, cy);
+}
+
+//-----------------------------------------------------------------------------
+// mpPrintout - provided by Davide Rondini
+//-----------------------------------------------------------------------------
+
+mpPrintout::mpPrintout(mpWindow *drawWindow, const wxChar *title) : wxPrintout(title)
+{
+    drawn = false;
+    plotWindow = drawWindow;
+}
+
+bool mpPrintout::OnPrintPage(int page)
+{
+    
+    wxDC *trgDc = GetDC();
+    if ((trgDc) && (page == 1)) {
+        wxCoord m_prnX, m_prnY;
+        int marginX = 50;
+        int marginY = 50;
+        trgDc->GetSize(&m_prnX, &m_prnY);
+        
+        m_prnX -= (2*marginX);
+        m_prnY -= (2*marginY);
+        trgDc->SetDeviceOrigin(marginX, marginY);
+        
+#ifdef MATHPLOT_DO_LOGGING
+        wxLogMessage(wxT("Print Size: %d x %d\n"), m_prnX, m_prnY);
+        wxLogMessage(wxT("Screen Size: %d x %d\n"), plotWindow->GetScrX(), plotWindow->GetScrY());
+#endif
+
+	// Set the scale according to the page:
+        plotWindow->Fit(
+                        plotWindow->GetDesiredXmin(),
+                        plotWindow->GetDesiredXmax(),
+                        plotWindow->GetDesiredYmin(),
+                        plotWindow->GetDesiredYmax(),
+                        &m_prnX, 
+                        &m_prnY );
+
+		// Get the colours of the plotWindow to restore them ath the end
+		wxColour oldBgColour = plotWindow->GetBackgroundColour();
+		wxColour oldFgColour = plotWindow->GetForegroundColour();
+		wxColour oldAxColour = plotWindow->GetAxesColour();
+		
+        // Draw background, ensuring to use white background for printing.
+        trgDc->SetPen( *wxTRANSPARENT_PEN );
+        // wxBrush brush( plotWindow->GetBackgroundColour() );
+		wxBrush brush = *wxWHITE_BRUSH;
+        trgDc->SetBrush( brush );
+        trgDc->DrawRectangle(0,0,m_prnX,m_prnY);
+
+        // Draw all the layers:
+        //trgDc->SetDeviceOrigin( m_prnX>>1, m_prnY>>1);  // Origin at the center
+        mpLayer *layer;
+        for (unsigned int li = 0; li < plotWindow->CountAllLayers(); li++) {
+            layer = plotWindow->GetLayer(li);
+            layer->Plot(*trgDc, *plotWindow);
+        };
+        // Restore device origin
+        // trgDc->SetDeviceOrigin(0, 0);
+		// Restore colours
+		plotWindow->SetColourTheme(oldBgColour, oldFgColour, oldAxColour);
+        // Restore drawing
+        plotWindow->Fit(plotWindow->GetDesiredXmin(), plotWindow->GetDesiredXmax(), plotWindow->GetDesiredYmin(), plotWindow->GetDesiredYmax(), NULL, NULL);
+        plotWindow->UpdateAll();
+    }
+    return true;
+}
+
+bool mpPrintout::HasPage(int page)
+{
+    return (page == 1);
+}
+
+
+//-----------------------------------------------------------------------------
+// mpMovableObject - provided by Jose Luis Blanco
+//-----------------------------------------------------------------------------
+void mpMovableObject::TranslatePoint( double x,double y, double &out_x, double &out_y )
+{
+    double ccos = cos( m_reference_phi );  // Avoid computing cos/sin twice.
+    double csin = sin( m_reference_phi );
+
+    out_x = m_reference_x + ccos * x - csin * y;
+    out_y = m_reference_y + csin * x + ccos * y;
+}
+
+// This method updates the buffers m_trans_shape_xs/ys, and the precomputed bounding box.
+void mpMovableObject::ShapeUpdated()
+{
+    // Just in case...
+    if (m_shape_xs.size()!=m_shape_ys.size())
+    {
+        wxLogError(wxT("[mpMovableObject::ShapeUpdated] Error, m_shape_xs and m_shape_ys have different lengths!"));
+    }
+    else
+    {
+        double ccos = cos( m_reference_phi );  // Avoid computing cos/sin twice.
+        double csin = sin( m_reference_phi );
+
+        m_trans_shape_xs.resize(m_shape_xs.size());
+        m_trans_shape_ys.resize(m_shape_xs.size());
+
+        std::vector<double>::iterator itXi, itXo;
+        std::vector<double>::iterator itYi, itYo;
+
+        m_bbox_min_x=1e300;
+        m_bbox_max_x=-1e300;
+        m_bbox_min_y=1e300;
+        m_bbox_max_y=-1e300;
+
+        for (itXo=m_trans_shape_xs.begin(),itYo=m_trans_shape_ys.begin(),itXi=m_shape_xs.begin(),itYi=m_shape_ys.begin();
+              itXo!=m_trans_shape_xs.end(); itXo++,itYo++,itXi++,itYi++)
+        {
+            *itXo = m_reference_x + ccos * (*itXi) - csin * (*itYi);
+            *itYo = m_reference_y + csin * (*itXi) + ccos * (*itYi);
+
+            // Keep BBox:
+            if (*itXo < m_bbox_min_x) m_bbox_min_x = *itXo;
+            if (*itXo > m_bbox_max_x) m_bbox_max_x = *itXo;
+            if (*itYo < m_bbox_min_y) m_bbox_min_y = *itYo;
+            if (*itYo > m_bbox_max_y) m_bbox_max_y = *itYo;
+        }
+    }
+}
+
+void mpMovableObject::Plot(wxDC & dc, mpWindow & w)
+{
+	if (m_visible) {
+		dc.SetPen( m_pen);
+
+
+		std::vector<double>::iterator  itX=m_trans_shape_xs.begin();
+		std::vector<double>::iterator  itY=m_trans_shape_ys.begin();
+
+		if (!m_continuous)
+		{
+			// for some reason DrawPoint does not use the current pen,
+			// so we use DrawLine for fat pens
+			if (m_pen.GetWidth() <= 1)
+			{
+				while (itX!=m_trans_shape_xs.end())
+				{
+					dc.DrawPoint( w.x2p(*(itX++)), w.y2p( *(itY++) ) );
+				}
+			}
+			else
+			{
+				while (itX!=m_trans_shape_xs.end())
+				{
+					wxCoord cx = w.x2p(*(itX++));
+					wxCoord cy = w.y2p(*(itY++));
+					dc.DrawLine(cx, cy, cx, cy);
+				}
+			}
+		}
+		else
+		{
+			wxCoord cx0=0,cy0=0;
+			bool    first = TRUE;
+			while (itX!=m_trans_shape_xs.end())
+			{
+				wxCoord cx = w.x2p(*(itX++));
+				wxCoord cy = w.y2p(*(itY++));
+				if (first)
+				{
+					first=FALSE;
+					cx0=cx;cy0=cy;
+				}
+				dc.DrawLine(cx0, cy0, cx, cy);
+				cx0=cx; cy0=cy;
+			}
+		}
+
+		if (!m_name.IsEmpty() && m_showName)
+		{
+			dc.SetFont(m_font);
+
+			wxCoord tx, ty;
+			dc.GetTextExtent(m_name, &tx, &ty);
+
+			if (HasBBox())
+			{
+				wxCoord sx = (wxCoord) (( m_bbox_max_x - w.GetPosX()) * w.GetScaleX());
+				wxCoord sy = (wxCoord) ((w.GetPosY() - m_bbox_max_y ) * w.GetScaleY());
+
+				tx = sx - tx - 8;
+				ty = sy - 8 - ty;
+			}
+			else
+			{
+				const int sx = w.GetScrX()>>1;
+				const int sy = w.GetScrY()>>1;
+
+				if ((m_flags & mpALIGNMASK) == mpALIGN_NE)
+				{
+					tx = sx - tx - 8;
+					ty = -sy + 8;
+				}
+				else if ((m_flags & mpALIGNMASK) == mpALIGN_NW)
+				{
+					tx = -sx + 8;
+					ty = -sy + 8;
+				}
+				else if ((m_flags & mpALIGNMASK) == mpALIGN_SW)
+				{
+					tx = -sx + 8;
+					ty = sy - 8 - ty;
+				}
+				else
+				{
+					tx = sx - tx - 8;
+					ty = sy - 8 - ty;
+				}
+			}
+
+			dc.DrawText( m_name, tx, ty);
+		}
+	}
+}
+
+//-----------------------------------------------------------------------------
+// mpCovarianceEllipse - provided by Jose Luis Blanco
+//-----------------------------------------------------------------------------
+
+// Called to update the m_shape_xs, m_shape_ys vectors, whenever a parameter changes.
+void mpCovarianceEllipse::RecalculateShape()
+{
+    m_shape_xs.clear();
+    m_shape_ys.clear();
+
+    // Preliminar checks:
+    if (m_quantiles<0)  { wxLogError(wxT("[mpCovarianceEllipse] Error: quantiles must be non-negative")); return; }
+    if (m_cov_00<0)     { wxLogError(wxT("[mpCovarianceEllipse] Error: cov(0,0) must be non-negative")); return; }
+    if (m_cov_11<0)     { wxLogError(wxT("[mpCovarianceEllipse] Error: cov(1,1) must be non-negative")); return; }
+
+    m_shape_xs.resize( m_segments,0 );
+    m_shape_ys.resize( m_segments,0 );
+
+    // Compute the two eigenvalues of the covariance:
+    // -------------------------------------------------
+    double b = -m_cov_00 - m_cov_11;
+    double c = m_cov_00*m_cov_11 - m_cov_01*m_cov_01;
+
+    double D = b*b - 4*c;
+
+    if (D<0)     { wxLogError(wxT("[mpCovarianceEllipse] Error: cov is not positive definite")); return; }
+
+    double eigenVal0 =0.5*( -b + sqrt(D) );
+    double eigenVal1 =0.5*( -b - sqrt(D) );
+
+    // Compute the two corresponding eigenvectors:
+    // -------------------------------------------------
+    double  eigenVec0_x,eigenVec0_y;
+    double  eigenVec1_x,eigenVec1_y;
+
+    if (fabs(eigenVal0 - m_cov_00)>1e-6)
+    {
+        double k1x = m_cov_01 / ( eigenVal0 - m_cov_00 );
+        eigenVec0_y = 1;
+        eigenVec0_x = eigenVec0_y * k1x;
+    }
+    else
+    {
+        double k1y = m_cov_01 / ( eigenVal0 - m_cov_11 );
+        eigenVec0_x = 1;
+        eigenVec0_y = eigenVec0_x * k1y;
+    }
+
+    if (fabs(eigenVal1 - m_cov_00)>1e-6)
+    {
+        double k2x = m_cov_01 / ( eigenVal1 - m_cov_00 );
+        eigenVec1_y = 1;
+        eigenVec1_x = eigenVec1_y * k2x;
+    }
+    else
+    {
+        double k2y = m_cov_01 / ( eigenVal1 - m_cov_11 );
+        eigenVec1_x = 1;
+        eigenVec1_y = eigenVec1_x * k2y;
+    }
+
+    // Normalize the eigenvectors:
+    double len = sqrt( eigenVec0_x*eigenVec0_x + eigenVec0_y*eigenVec0_y );
+    eigenVec0_x /= len;  // It *CANNOT* be zero
+    eigenVec0_y /= len;
+
+    len = sqrt( eigenVec1_x*eigenVec1_x + eigenVec1_y*eigenVec1_y );
+    eigenVec1_x /= len;  // It *CANNOT* be zero
+    eigenVec1_y /= len;
+
+
+    // Take the sqrt of the eigenvalues (required for the ellipse scale):
+    eigenVal0 = sqrt(eigenVal0);
+    eigenVal1 = sqrt(eigenVal1);
+
+    // Compute the 2x2 matrix M = diag(eigVal) * (~eigVec)  (each eigen vector is a row):
+    double M_00 = eigenVec0_x * eigenVal0;
+    double M_01 = eigenVec0_y * eigenVal0;
+
+    double M_10 = eigenVec1_x * eigenVal1;
+    double M_11 = eigenVec1_y * eigenVal1;
+
+    // The points of the 2D ellipse:
+    double ang;
+    double Aang = 6.283185308/(m_segments-1);
+    int    i;
+    for (i=0,ang=0;i<m_segments;i++,ang+= Aang )
+    {
+        double ccos = cos(ang);
+        double csin = sin(ang);
+
+        m_shape_xs[i] = m_quantiles * (ccos * M_00 + csin * M_10 );
+        m_shape_ys[i] = m_quantiles * (ccos * M_01 + csin * M_11 );
+    } // end for points on ellipse
+
+
+    ShapeUpdated();
+}
+
+//-----------------------------------------------------------------------------
+// mpPolygon - provided by Jose Luis Blanco
+//-----------------------------------------------------------------------------
+void mpPolygon::setPoints(
+    const std::vector<double>&  points_xs,
+    const std::vector<double>&  points_ys,
+    bool                        closedShape )
+{
+    if ( points_xs.size()!=points_ys.size() )
+    {
+        wxLogError(wxT("[mpPolygon] Error: points_xs and points_ys must have the same number of elements"));
+    }
+    else
+    {
+        m_shape_xs = points_xs;
+        m_shape_ys = points_ys;
+
+        if ( closedShape && points_xs.size())
+        {
+            m_shape_xs.push_back( points_xs[0] );
+            m_shape_ys.push_back( points_ys[0] );
+        }
+
+        ShapeUpdated();
+    }
+}
+
+//-----------------------------------------------------------------------------
+// mpBitmapLayer - provided by Jose Luis Blanco
+//-----------------------------------------------------------------------------
+void mpBitmapLayer::GetBitmapCopy( wxImage &outBmp ) const
+{
+    if (m_validImg)
+        outBmp = m_bitmap;
+}
+
+void mpBitmapLayer::SetBitmap( const wxImage &inBmp, double x, double y, double lx, double ly )
+{
+    if (!inBmp.Ok())
+    {
+        wxLogError(wxT("[mpBitmapLayer] Assigned bitmap is not Ok()!"));
+    }
+    else
+    {
+        m_bitmap = inBmp; //.GetSubBitmap( wxRect(0, 0, inBmp.GetWidth(), inBmp.GetHeight()));
+        m_min_x = x;
+        m_min_y = y;
+        m_max_x = x+lx;
+        m_max_y = y+ly;
+        m_validImg = true;
+    }
+}
+
+
+void mpBitmapLayer::Plot(wxDC & dc, mpWindow & w)
+{
+    if (m_visible && m_validImg)
+    {
+	/*	1st: We compute (x0,y0)-(x1,y1), the pixel coordinates of the real outer limits
+		     of the image rectangle within the (screen) mpWindow. Note that these coordinates 
+		     might fall well far away from the real view limits when the user zoom in.
+
+		2nd: We compute (dx0,dy0)-(dx1,dy1), the pixel coordinates the rectangle that will 
+		     be actually drawn into the mpWindow, i.e. the clipped real rectangle that 
+		     avoids the non-visible parts. (offset_x,offset_y) are the pixel coordinates
+		     that correspond to the window point (dx0,dy0) within the image "m_bitmap", and
+		     (b_width,b_height) is the size of the bitmap patch that will be drawn.
+
+	(x0,y0) .................  (x1,y0)
+	    .                          .
+	    .                          .
+	(x0,y1) ................   (x1,y1)
+                  (In pixels!!)
+	*/
+
+	// 1st step -------------------------------
+        wxCoord x0 = w.x2p(m_min_x);
+        wxCoord y0 = w.y2p(m_max_y);
+        wxCoord x1 = w.x2p(m_max_x);
+        wxCoord y1 = w.y2p(m_min_y);
+
+	// 2nd step -------------------------------
+	// Precompute the size of the actual bitmap pixel on the screen (e.g. will be >1 if zoomed in)
+	double screenPixelX = ( x1-x0 ) / (double)m_bitmap.GetWidth();
+	double screenPixelY = ( y1-y0 ) / (double)m_bitmap.GetHeight();
+
+	// The minimum number of pixels that the streched image will overpass the actual mpWindow borders:
+	wxCoord borderMarginX = (wxCoord)(screenPixelX+1); // ceil
+	wxCoord borderMarginY = (wxCoord)(screenPixelY+1); // ceil
+
+	// The actual drawn rectangle (dx0,dy0)-(dx1,dy1) is (x0,y0)-(x1,y1) clipped:
+	wxCoord dx0=x0,dx1=x1,dy0=y0,dy1=y1;
+	if (dx0<0) dx0=-borderMarginX;
+	if (dy0<0) dy0=-borderMarginY;
+	if (dx1>w.GetScrX()) dx1=w.GetScrX()+borderMarginX;
+	if (dy1>w.GetScrY()) dy1=w.GetScrY()+borderMarginY;
+
+	// For convenience, compute the width/height of the rectangle to be actually drawn:
+	wxCoord d_width = dx1-dx0+1;
+	wxCoord d_height = dy1-dy0+1;
+
+	// Compute the pixel offsets in the internally stored bitmap:
+	wxCoord offset_x= (wxCoord) ( (dx0-x0)/screenPixelX );
+	wxCoord offset_y= (wxCoord) ( (dy0-y0)/screenPixelY );
+
+	// and the size in pixel of the area to be actually drawn from the internally stored bitmap:
+	wxCoord b_width  = (wxCoord) ( (dx1-dx0+1)/screenPixelX );
+	wxCoord b_height = (wxCoord) ( (dy1-dy0+1)/screenPixelY );
+
+	#ifdef MATHPLOT_DO_LOGGING
+		wxLogMessage(_("[mpBitmapLayer::Plot] screenPixel: x=%f y=%f  d_width=%ix%i"),screenPixelX,screenPixelY,d_width,d_height);
+		wxLogMessage(_("[mpBitmapLayer::Plot] offset: x=%i y=%i  bmpWidth=%ix%i"),offset_x,offset_y,b_width,b_height);
+	#endif
+
+	// Is there any visible region?
+	if (d_width>0 && d_height>0) 
+	{
+		// Build the scaled bitmap from the image, only if it has changed:
+		if (m_scaledBitmap.GetWidth()!=d_width || 
+		    m_scaledBitmap.GetHeight()!=d_height || 
+		    m_scaledBitmap_offset_x != offset_x ||
+		    m_scaledBitmap_offset_y != offset_y  )
+		{
+			wxRect r(wxRect(offset_x,offset_y,b_width,b_height));
+			// Just for the case....
+			if (r.x<0) r.x=0;
+			if (r.y<0) r.y=0;
+			if (r.width>m_bitmap.GetWidth()) r.width=m_bitmap.GetWidth();
+			if (r.height>m_bitmap.GetHeight()) r.height=m_bitmap.GetHeight();
+
+			m_scaledBitmap = wxBitmap( 
+				wxBitmap(m_bitmap).GetSubBitmap( r ).ConvertToImage()
+				.Scale(d_width,d_height) );
+			m_scaledBitmap_offset_x = offset_x;
+			m_scaledBitmap_offset_y = offset_y;
+		}
+
+		// Draw it:
+		dc.DrawBitmap( m_scaledBitmap, dx0,dy0, true );
+	}
+    }
+
+    // Draw the name label
+    if (!m_name.IsEmpty() && m_showName)
+    {
+        dc.SetFont(m_font);
+
+        wxCoord tx, ty;
+        dc.GetTextExtent(m_name, &tx, &ty);
+
+        if (HasBBox())
+        {
+            wxCoord sx = (wxCoord) (( m_max_x - w.GetPosX()) * w.GetScaleX());
+            wxCoord sy = (wxCoord) ((w.GetPosY() - m_max_y ) * w.GetScaleY());
+
+            tx = sx - tx - 8;
+            ty = sy - 8 - ty;
+        }
+        else
+        {
+            const int sx = w.GetScrX()>>1;
+            const int sy = w.GetScrY()>>1;
+
+            if ((m_flags & mpALIGNMASK) == mpALIGN_NE)
+            {
+                tx = sx - tx - 8;
+                ty = -sy + 8;
+            }
+            else if ((m_flags & mpALIGNMASK) == mpALIGN_NW)
+            {
+                tx = -sx + 8;
+                ty = -sy + 8;
+            }
+            else if ((m_flags & mpALIGNMASK) == mpALIGN_SW)
+            {
+                tx = -sx + 8;
+                ty = sy - 8 - ty;
+            }
+            else
+            {
+                tx = sx - tx - 8;
+                ty = sy - 8 - ty;
+            }
+        }
+
+        dc.DrawText( m_name, tx, ty);
+    }
+}
Index: src/plugins/contrib/wxSmithPlot/wxmathplot/mathplot.h
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/mathplot.h b/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/mathplot.h
new file mode 10644
--- /dev/null	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxmathplot/mathplot.h	(copie de travail)
@@ -0,0 +1,1728 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:            mathplot.cpp
+// Purpose:         Framework for plotting in wxWindows
+// Original Author: David Schalig
+// Maintainer:      Davide Rondini
+// Contributors:    Jose Luis Blanco, Val Greene
+// Created:         21/07/2003
+// Last edit:       22/02/2009
+// Copyright:       (c) David Schalig, Davide Rondini
+// Licence:         wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _MP_MATHPLOT_H_
+#define _MP_MATHPLOT_H_
+
+/** @file mathplot.h */
+/** @mainpage wxMathPlot
+    wxMathPlot is a framework for mathematical graph plotting in wxWindows.
+
+    The framework is designed for convenience and ease of use.
+
+    @section screenshots Screenshots
+    <a href="http://wxmathplot.sourceforge.net/screenshot.shtml">Go to the screenshots page.</a>
+
+    @section overview Overview
+    The heart of wxMathPlot is mpWindow, which is a 2D canvas for plot layers.
+    mpWindow can be embedded as subwindow in a wxPane, a wxFrame, or any other wxWindow.
+    mpWindow provides a zoomable and moveable view of the layers. The current view can
+    be controlled with the mouse, the scrollbars, and a context menu.
+
+    Plot layers are implementations of the abstract base class mpLayer. Those can
+    be function plots, scale rulers, or any other vector data visualisation. wxMathPlot provides two mpLayer implementations for plotting horizontal and vertical rulers: mpScaleX and mpScaleY.
+    For convenient function plotting a series of classes derived from mpLayer are provided, like mpFX, mpProfile, mpLegend and so on. These base classes already come with plot code, user's own functions can be implemented by overriding just one member for retrieving a function value.
+
+    mpWindow has built-in support for mouse-based pan and zoom through intuitive combinations of buttons and the mouse wheel. It also incorporates an optional double buffering mechanism to avoid flicker. Plots can be easily sent to printer evices or exported in bitmap formats like PNG, BMP or JPEG.
+
+    @section coding Coding conventions
+    wxMathPlot sticks to wxWindow's coding conventions. All entities defined by wxMathPlot have the prefix <i>mp</i>.
+
+    @section author Author and license
+    wxMathPlot is published under the terms of the wxWindow license.<br>
+    The original author is David Schalig <mrhill@users.sourceforge.net>.<br>
+    From June 2007 the project is maintained by Davide Rondini <cdron77@users.sourceforge.net>.<br>
+    Authors can be contacted via the wxMathPlot's homepage at
+    https://sourceforge.net/projects/wxmathplot<br>
+    Contributors:<br>
+    Jose Luis Blanco, Val Greene.<br>
+*/
+
+//this definition uses windows dll to export function. 
+//WXDLLIMPEXP_MATHPLOT definition definition changed to WXDLLIMPEXP_MATHPLOT  
+//mathplot_EXPORTS will be defined by cmake 
+#ifdef mathplot_EXPORTS 
+ #define WXDLLIMPEXP_MATHPLOT WXEXPORT 
+ #define WXDLLIMPEXP_DATA_MATHPLOT(type) WXEXPORT type 
+#else // not making DLL 
+ #define WXDLLIMPEXP_MATHPLOT 
+ #define WXDLLIMPEXP_DATA_MATHPLOT(type) type 
+#endif
+
+#if defined(__GNUG__) && !defined(__APPLE__)
+#pragma interface "mathplot.h"
+#endif
+
+#include <vector>
+
+// #include <wx/wx.h>
+#include <wx/defs.h>
+#include <wx/menu.h>
+#include <wx/scrolwin.h>
+#include <wx/event.h>
+#include <wx/dynarray.h>
+#include <wx/pen.h>
+#include <wx/dcmemory.h>
+#include <wx/string.h>
+#include <wx/print.h>
+#include <wx/image.h>
+
+
+#include <deque>
+
+// For memory leak debug
+#ifdef _WINDOWS
+#ifdef _DEBUG
+#include <crtdbg.h>
+#define DEBUG_NEW new(_NORMAL_BLOCK ,__FILE__, __LINE__)
+#else
+#define DEBUG_NEW new
+#endif // _DEBUG
+#endif // _WINDOWS
+
+// Separation for axes when set close to border
+#define X_BORDER_SEPARATION 40
+#define Y_BORDER_SEPARATION 60
+
+//-----------------------------------------------------------------------------
+// classes
+//-----------------------------------------------------------------------------
+
+class WXDLLIMPEXP_MATHPLOT mpLayer;
+class WXDLLIMPEXP_MATHPLOT mpFX;
+class WXDLLIMPEXP_MATHPLOT mpFY;
+class WXDLLIMPEXP_MATHPLOT mpFXY;
+class WXDLLIMPEXP_MATHPLOT mpFXYVector;
+class WXDLLIMPEXP_MATHPLOT mpScaleX;
+class WXDLLIMPEXP_MATHPLOT mpScaleY;
+class WXDLLIMPEXP_MATHPLOT mpWindow;
+class WXDLLIMPEXP_MATHPLOT mpText;
+class WXDLLIMPEXP_MATHPLOT mpPrintout;
+
+/** Command IDs used by mpWindow */
+enum
+{
+    mpID_FIT = 2000,    //!< Fit view to match bounding box of all layers
+    mpID_ZOOM_IN,       //!< Zoom into view at clickposition / window center
+    mpID_ZOOM_OUT,      //!< Zoom out
+    mpID_CENTER,        //!< Center view on click position
+    mpID_LOCKASPECT,    //!< Lock x/y scaling aspect
+    mpID_HELP_MOUSE     //!< Shows information about the mouse commands
+};
+
+//-----------------------------------------------------------------------------
+// mpLayer
+//-----------------------------------------------------------------------------
+
+typedef enum __mp_Layer_Type {
+    mpLAYER_UNDEF,  //!< Layer type undefined
+    mpLAYER_AXIS,  //!< Axis type layer
+    mpLAYER_PLOT,  //!< Plot type layer
+    mpLAYER_INFO,   //!< Info box type layer
+    mpLAYER_BITMAP //!< Bitmap type layer
+} mpLayerType;
+
+/** Plot layer, abstract base class.
+    Any number of mpLayer implementations can be attached to mpWindow.
+    Examples for mpLayer implementations are function graphs, or scale rulers.
+
+    For convenience mpLayer defines a name, a font (wxFont), a pen (wxPen),
+    and a continuity property (bool) as class members.
+    The default values at constructor are the default font, a black pen, and
+     continuity set to false (draw separate points).
+    These may or may not be used by implementations.
+*/
+class WXDLLIMPEXP_MATHPLOT mpLayer : public wxObject
+{
+public:
+    mpLayer();
+
+    virtual ~mpLayer() {};
+
+    /** Check whether this layer has a bounding box.
+        The default implementation returns \a TRUE. Override and return
+        FALSE if your mpLayer implementation should be ignored by the calculation
+        of the global bounding box for all layers in a mpWindow.
+        @retval TRUE Has bounding box
+        @retval FALSE Has not bounding box
+    */
+    virtual bool   HasBBox() { return TRUE; }
+
+    /** Check whether the layer is an info box.
+        The default implementation returns \a FALSE. It is overrided to \a TRUE for mpInfoLayer
+        class and its derivative. It is necessary to define mouse actions behaviour over
+        info boxes.
+        @return whether the layer is an info boxes
+        @sa mpInfoLayer::IsInfo */
+    virtual bool IsInfo() { return false; };
+
+    /** Get inclusive left border of bounding box.
+        @return Value
+    */
+    virtual double GetMinX() { return -1.0; }
+
+    /** Get inclusive right border of bounding box.
+        @return Value
+    */
+    virtual double GetMaxX() { return  1.0; }
+
+    /** Get inclusive bottom border of bounding box.
+        @return Value
+    */
+    virtual double GetMinY() { return -1.0; }
+
+    /** Get inclusive top border of bounding box.
+        @return Value
+    */
+    virtual double GetMaxY() { return  1.0; }
+
+    /** Plot given view of layer to the given device context.
+        An implementation of this function has to transform layer coordinates to
+        wxDC coordinates based on the view parameters retrievable from the mpWindow
+        passed in \a w. 
+	Note that the public methods of mpWindow: x2p,y2p and p2x,p2y are already provided 
+	which transform layer coordinates to DC pixel coordinates, and <b>user code should rely 
+	on them</b> for portability and future changes to be applied transparently, instead of
+	implementing the following formulas manually.
+	
+	The passed device context \a dc has its coordinate origin set to the top-left corner 
+	of the visible area (the default). The coordinate orientation is as shown in the
+        following picture:
+        <pre>
+        (wxDC origin 0,0)
+               x-------------> ascending X ----------------+
+               |                                           |
+               |                                           |
+               V ascending Y                               |
+	           |                                           |
+	           |                                           |
+	           |                                           |
+	           +-------------------------------------------+  <-- right-bottom corner of the mpWindow visible area.
+        </pre>
+        Note that Y ascends in downward direction, whereas the usual vertical orientation
+        for mathematical plots is vice versa. Thus Y-orientation will be swapped usually,
+        when transforming between wxDC and mpLayer coordinates. This change of coordinates 
+	is taken into account in the methods p2x,p2y,x2p,y2p.
+
+        <b> Rules for transformation between mpLayer and wxDC coordinates </b>
+        @code
+        dc_X = (layer_X - mpWindow::GetPosX()) * mpWindow::GetScaleX()
+        dc_Y = (mpWindow::GetPosY() - layer_Y) * mpWindow::GetScaleY() // swapping Y-orientation
+
+        layer_X = (dc_X / mpWindow::GetScaleX()) + mpWindow::GetPosX() // scale guaranteed to be not 0
+        layer_Y = mpWindow::GetPosY() - (dc_Y / mpWindow::GetScaleY()) // swapping Y-orientation
+        @endcode
+
+        @param dc Device context to plot to.
+        @param w  View to plot. The visible area can be retrieved from this object.
+	@sa mpWindow::p2x,mpWindow::p2y,mpWindow::x2p,mpWindow::y2p
+    */
+    virtual void   Plot(wxDC & dc, mpWindow & w) = 0;
+
+    /** Get layer name.
+        @return Name
+    */
+    wxString       GetName() const { return m_name; }
+
+    /** Get font set for this layer.
+        @return Font
+    */
+    const wxFont&  GetFont() const { return m_font; }
+
+    /** Get pen set for this layer.
+        @return Pen
+    */
+    const wxPen&   GetPen()  const { return m_pen;  }
+
+    /** Set the 'continuity' property of the layer (true:draws a continuous line, false:draws separate points).
+      * @sa GetContinuity
+      */
+    void SetContinuity(bool continuity) {m_continuous = continuity;}
+
+    /** Gets the 'continuity' property of the layer.
+      * @sa SetContinuity
+      */
+    bool GetContinuity() const {return m_continuous;}
+
+    /** Shows or hides the text label with the name of the layer (default is visible).
+      */
+    void ShowName(bool show) { m_showName = show; };
+
+    /** Set layer name
+        @param name Name, will be copied to internal class member
+    */
+    void SetName(wxString name) { m_name = name; }
+
+    /** Set layer font
+        @param font Font, will be copied to internal class member
+    */
+    void SetFont(wxFont& font)  { m_font = font; }
+
+    /** Set layer pen
+        @param pen Pen, will be copied to internal class member
+    */
+    void SetPen(wxPen pen)     { m_pen  = pen;  }
+
+    /** Set Draw mode: inside or outside margins. Default is outside, which allows the layer to draw up to the mpWindow border.
+        @param drawModeOutside The draw mode to be set */
+    void SetDrawOutsideMargins(bool drawModeOutside) { m_drawOutsideMargins = drawModeOutside; };
+
+    /** Get Draw mode: inside or outside margins.
+        @return The draw mode */
+    bool GetDrawOutsideMargins() { return m_drawOutsideMargins; };
+
+    /** Get a small square bitmap filled with the colour of the pen used in the layer. Useful to create legends or similar reference to the layers.
+        @param side side length in pixels
+        @return a wxBitmap filled with layer's colour */
+    wxBitmap GetColourSquare(int side = 16);
+
+    /** Get layer type: a Layer can be of different types: plot lines, axis, info boxes, etc, this method returns the right value.
+        @return An integer indicating layer type */
+    mpLayerType GetLayerType() { return m_type; };
+	
+    /** Checks whether the layer is visible or not.
+        @return \a true if visible */
+    bool IsVisible() {return m_visible; };
+
+    /** Sets layer visibility.
+        @param show visibility bool. */
+    void SetVisible(bool show) { m_visible = show; };
+	
+	/** Get brush set for this layer.
+		@return brush. */
+	const wxBrush&   GetBrush() const { return m_brush; };
+	
+	/** Set layer brush
+		@param brush brush, will be copied to internal class member	*/
+	void SetBrush(wxBrush brush) { m_brush = brush; };
+
+protected:
+    wxFont   m_font;    //!< Layer's font
+    wxPen    m_pen;     //!< Layer's pen
+	wxBrush  m_brush;       //!< Layer's brush
+    wxString m_name;    //!< Layer's name
+    bool     m_continuous; //!< Specify if the layer will be plotted as a continuous line or a set of points.
+    bool     m_showName;  //!< States whether the name of the layer must be shown (default is true).
+    bool     m_drawOutsideMargins; //!< select if the layer should draw only inside margins or over all DC
+    mpLayerType m_type; //!< Define layer type, which is assigned by constructor
+	bool 	m_visible;	//!< Toggles layer visibility
+    DECLARE_DYNAMIC_CLASS(mpLayer)
+};
+
+
+//-----------------------------------------------------------------------------
+// mpInfoLayer
+//-----------------------------------------------------------------------------
+
+/** @class mpInfoLayer
+    @brief Base class to create small rectangular info boxes
+    mpInfoLayer is the base class to create a small rectangular info box in transparent overlay over plot layers. It is used to implement objects like legends.
+*/
+class WXDLLIMPEXP_MATHPLOT mpInfoLayer : public mpLayer
+{
+public:
+    /** Default constructor. */
+    mpInfoLayer();
+
+    /** Complete constructor.
+        @param rect Sets the initial size rectangle of the layer.
+        @param brush pointer to a fill brush. Default is transparent */
+    mpInfoLayer(wxRect rect, const wxBrush* brush = wxTRANSPARENT_BRUSH);
+
+    /** Destructor */
+    virtual ~mpInfoLayer();
+
+    /** Updates the content of the info box. Should be overidden by derived classes.
+        Update may behave in different ways according to the type of event which called it.
+        @param w parent mpWindow from which to obtain informations
+        @param event The event which called the update. */
+    virtual void UpdateInfo(mpWindow& w, wxEvent& event);
+
+    /** mpInfoLayer has not bounding box. @sa mpLayer::HasBBox
+        @return always \a FALSE */
+    virtual bool HasBBox() { return false; };
+
+    /** Plot method. Can be overidden by derived classes.
+        @param dc the device content where to plot
+        @param w the window to plot
+        @sa mpLayer::Plot */
+    virtual void   Plot(wxDC & dc, mpWindow & w);
+
+    /** Specifies that this is an Info box layer.
+        @return always \a TRUE
+        @sa mpLayer::IsInfo */
+    virtual bool IsInfo() { return true; };
+
+    /** Checks whether a point is inside the info box rectangle.
+        @param point The point to be checked
+        @return \a true if the point is inside the bounding box */
+    virtual bool Inside(wxPoint& point);
+
+    /** Moves the layer rectangle of given pixel deltas.
+        @param delta The wxPoint container for delta coordinates along x and y. Units are in pixels. */
+    virtual void Move(wxPoint delta);
+
+    /** Updates the rectangle reference point. Used by internal methods of mpWindow to correctly move mpInfoLayers. */
+    virtual void UpdateReference();
+
+    /** Returns the position of the upper left corner of the box (in pixels)
+        @return The rectangle position */
+    wxPoint GetPosition();
+
+    /** Returns the size of the box (in pixels)
+        @return The rectangle size */
+    wxSize GetSize();
+	
+	/** Returns the current rectangle coordinates.
+	    @return The info layer rectangle */
+	const wxRect& GetRectangle() { return m_dim; };
+
+protected:
+    wxRect m_dim;           //!< The bounding rectangle of the box. It may be resized dynamically by the Plot method.
+    wxPoint m_reference;    //!< Holds the reference point for movements
+    wxBrush m_brush;        //!< The brush to be used for the background
+    int m_winX, m_winY;     //!< Holds the mpWindow size. Used to rescale position when window is resized.
+    
+    DECLARE_DYNAMIC_CLASS(mpInfoLayer)
+};
+
+/** @class mpInfoCoords
+    @brief Implements an overlay box which shows the mouse coordinates in plot units.
+    When an mpInfoCoords layer is activated, when mouse is moved over the mpWindow, its coordinates (in mpWindow units, not pixels) are continuously reported inside the layer box. */
+class WXDLLIMPEXP_MATHPLOT mpInfoCoords : public mpInfoLayer
+{
+public:
+    /** Default constructor */
+    mpInfoCoords();
+    /** Complete constructor, setting initial rectangle and background brush.
+        @param rect The initial bounding rectangle.
+        @param brush The wxBrush to be used for box background: default is transparent */
+    mpInfoCoords(wxRect rect, const wxBrush* brush = wxTRANSPARENT_BRUSH);
+
+    /** Default destructor */
+    ~mpInfoCoords();
+
+    /** Updates the content of the info box. It is used to update coordinates.
+        @param w parent mpWindow from which to obtain information
+        @param event The event which called the update. */
+    virtual void UpdateInfo(mpWindow& w, wxEvent& event);
+
+    /** Plot method.
+        @param dc the device content where to plot
+        @param w the window to plot
+        @sa mpLayer::Plot */
+    virtual void   Plot(wxDC & dc, mpWindow & w);
+
+protected:
+    wxString m_content; //!< string holding the coordinates to be drawn.
+};
+
+/** @class mpInfoLegend
+    @brief Implements the legend to be added to the plot
+    This layer allows you to add a legend to describe the plots in the window. The legend uses the layer name as a label, and displays only layers of type mpLAYER_PLOT. */
+class WXDLLIMPEXP_MATHPLOT mpInfoLegend : public mpInfoLayer
+{
+public:
+    /** Default constructor */
+    mpInfoLegend();
+
+    /** Complete constructor, setting initial rectangle and background brush.
+        @param rect The initial bounding rectangle.
+        @param brush The wxBrush to be used for box background: default is transparent
+        @sa mpInfoLayer::mpInfoLayer */
+    mpInfoLegend(wxRect rect, const wxBrush* brush = wxTRANSPARENT_BRUSH);
+
+    /**  Default destructor */
+    ~mpInfoLegend();
+
+    /** Updates the content of the info box. Unused in this class.
+        @param w parent mpWindow from which to obtain information
+        @param event The event which called the update. */
+    virtual void UpdateInfo(mpWindow& w, wxEvent& event);
+
+    /** Plot method.
+        @param dc the device content where to plot
+        @param w the window to plot
+        @sa mpLayer::Plot */
+    virtual void   Plot(wxDC & dc, mpWindow & w);
+
+protected:
+    
+};
+
+
+//-----------------------------------------------------------------------------
+// mpLayer implementations - functions
+//-----------------------------------------------------------------------------
+
+/** @name Label alignment constants
+@{*/
+
+/** @internal */
+#define mpALIGNMASK    0x03
+/** Aligns label to the right. For use with mpFX. */
+#define mpALIGN_RIGHT  0x00
+/** Aligns label to the center. For use with mpFX and mpFY. */
+#define mpALIGN_CENTER 0x01
+/** Aligns label to the left. For use with mpFX. */
+#define mpALIGN_LEFT   0x02
+/** Aligns label to the top. For use with mpFY. */
+#define mpALIGN_TOP    mpALIGN_RIGHT
+/** Aligns label to the bottom. For use with mpFY. */
+#define mpALIGN_BOTTOM mpALIGN_LEFT
+/** Aligns X axis to bottom border. For mpScaleX */
+#define mpALIGN_BORDER_BOTTOM  0x04
+/** Aligns X axis to top border. For mpScaleX */
+#define mpALIGN_BORDER_TOP  0x05
+/** Set label for X axis in normal mode */
+#define mpX_NORMAL  0x00
+/** Set label for X axis in time mode: the value is represented as minutes:seconds.milliseconds if time is less than 2 minutes, hours:minutes:seconds otherwise. */
+#define mpX_TIME  0x01
+/** Set label for X axis in hours mode: the value is always represented as hours:minutes:seconds. */
+#define mpX_HOURS 0x02
+/** Set label for X axis in date mode: the value is always represented as yyyy-mm-dd. */
+#define mpX_DATE 0x03
+/** Set label for X axis in datetime mode: the value is always represented as yyyy-mm-ddThh:mm:ss. */
+#define mpX_DATETIME 0x04
+/** Aligns Y axis to left border. For mpScaleY */
+#define mpALIGN_BORDER_LEFT mpALIGN_BORDER_BOTTOM
+/** Aligns Y axis to right border. For mpScaleY */
+#define mpALIGN_BORDER_RIGHT mpALIGN_BORDER_TOP
+/** Aligns label to north-east. For use with mpFXY. */
+#define mpALIGN_NE     0x00
+/** Aligns label to north-west. For use with mpFXY. */
+#define mpALIGN_NW     0x01
+/** Aligns label to south-west. For use with mpFXY. */
+#define mpALIGN_SW     0x02
+/** Aligns label to south-east. For use with mpFXY. */
+#define mpALIGN_SE     0x03
+
+/*@}*/
+
+/** @name mpLayer implementations - functions
+@{*/
+
+/** Abstract base class providing plot and labeling functionality for functions F:X->Y.
+    Override mpFX::GetY to implement a function.
+    Optionally implement a constructor and pass a name (label) and a label alignment
+    to the constructor mpFX::mpFX. If the layer name is empty, no label will be plotted.
+*/
+class WXDLLIMPEXP_MATHPLOT mpFX : public mpLayer
+{
+public:
+    /** @param name  Label
+        @param flags Label alignment, pass one of #mpALIGN_RIGHT, #mpALIGN_CENTER, #mpALIGN_LEFT.
+    */
+    mpFX(wxString name = wxEmptyString, int flags = mpALIGN_RIGHT);
+
+    /** Get function value for argument.
+        Override this function in your implementation.
+        @param x Argument
+        @return Function value
+    */
+    virtual double GetY( double x ) = 0;
+
+    /** Layer plot handler.
+        This implementation will plot the function in the visible area and
+        put a label according to the aligment specified.
+    */
+    virtual void Plot(wxDC & dc, mpWindow & w);
+
+protected:
+    int m_flags; //!< Holds label alignment
+
+    DECLARE_DYNAMIC_CLASS(mpFX)
+};
+
+/** Abstract base class providing plot and labeling functionality for functions F:Y->X.
+    Override mpFY::GetX to implement a function.
+    Optionally implement a constructor and pass a name (label) and a label alignment
+    to the constructor mpFY::mpFY. If the layer name is empty, no label will be plotted.
+*/
+class WXDLLIMPEXP_MATHPLOT mpFY : public mpLayer
+{
+public:
+    /** @param name  Label
+        @param flags Label alignment, pass one of #mpALIGN_BOTTOM, #mpALIGN_CENTER, #mpALIGN_TOP.
+    */
+    mpFY(wxString name = wxEmptyString, int flags = mpALIGN_TOP);
+
+    /** Get function value for argument.
+        Override this function in your implementation.
+        @param y Argument
+        @return Function value
+    */
+    virtual double GetX( double y ) = 0;
+
+    /** Layer plot handler.
+        This implementation will plot the function in the visible area and
+        put a label according to the aligment specified.
+    */
+    virtual void Plot(wxDC & dc, mpWindow & w);
+
+protected:
+    int m_flags; //!< Holds label alignment
+
+    DECLARE_DYNAMIC_CLASS(mpFY)
+};
+
+/** Abstract base class providing plot and labeling functionality for a locus plot F:N->X,Y.
+    Locus argument N is assumed to be in range 0 .. MAX_N, and implicitly derived by enumerating
+    all locus values. Override mpFXY::Rewind and mpFXY::GetNextXY to implement a locus.
+    Optionally implement a constructor and pass a name (label) and a label alignment
+    to the constructor mpFXY::mpFXY. If the layer name is empty, no label will be plotted.
+*/
+class WXDLLIMPEXP_MATHPLOT mpFXY : public mpLayer
+{
+public:
+    /** @param name  Label
+        @param flags Label alignment, pass one of #mpALIGN_NE, #mpALIGN_NW, #mpALIGN_SW, #mpALIGN_SE.
+    */
+    mpFXY(wxString name = wxEmptyString, int flags = mpALIGN_NE);
+
+    /** Rewind value enumeration with mpFXY::GetNextXY.
+        Override this function in your implementation.
+    */
+    virtual void Rewind() = 0;
+
+    /** Get locus value for next N.
+        Override this function in your implementation.
+        @param x Returns X value
+        @param y Returns Y value
+    */
+    virtual bool GetNextXY(double & x, double & y) = 0;
+
+    /** Layer plot handler.
+        This implementation will plot the locus in the visible area and
+        put a label according to the alignment specified.
+    */
+    virtual void Plot(wxDC & dc, mpWindow & w);
+
+
+protected:
+    int m_flags; //!< Holds label alignment
+
+	// Data to calculate label positioning
+	wxCoord maxDrawX, minDrawX, maxDrawY, minDrawY;
+	//int drawnPoints;
+
+    /** Update label positioning data
+	    @param xnew New x coordinate
+		@param ynew New y coordinate
+	*/
+	void UpdateViewBoundary(wxCoord xnew, wxCoord ynew);
+
+    DECLARE_DYNAMIC_CLASS(mpFXY)
+};
+
+/** Abstract base class providing plot and labeling functionality for functions F:Y->X.
+    Override mpProfile::GetX to implement a function.
+    This class is similar to mpFY, but the Plot method is different. The plot is in fact represented by lines instead of points, which gives best rendering of rapidly-varying functions, and in general, data which are not so close one to another.
+    Optionally implement a constructor and pass a name (label) and a label alignment
+    to the constructor mpProfile::mpProfile. If the layer name is empty, no label will be plotted.
+*/
+class WXDLLIMPEXP_MATHPLOT mpProfile : public mpLayer
+{
+public:
+    /** @param name  Label
+        @param flags Label alignment, pass one of #mpALIGN_BOTTOM, #mpALIGN_CENTER, #mpALIGN_TOP.
+    */
+    mpProfile(wxString name = wxEmptyString, int flags = mpALIGN_TOP);
+
+    /** Get function value for argument.
+        Override this function in your implementation.
+        @param x Argument
+        @return Function value
+    */
+    virtual double GetY( double x ) = 0;
+
+    /** Layer plot handler.
+        This implementation will plot the function in the visible area and
+        put a label according to the aligment specified.
+    */
+    virtual void Plot(wxDC & dc, mpWindow & w);
+
+protected:
+    int m_flags; //!< Holds label alignment
+
+    DECLARE_DYNAMIC_CLASS(mpProfile)
+};
+
+/*@}*/
+
+//-----------------------------------------------------------------------------
+// mpLayer implementations - furniture (scales, ...)
+//-----------------------------------------------------------------------------
+
+/** @name mpLayer implementations - furniture (scales, ...)
+@{*/
+
+/** Plot layer implementing a x-scale ruler.
+    The ruler is fixed at Y=0 in the coordinate system. A label is plotted at
+    the bottom-right hand of the ruler. The scale numbering automatically
+    adjusts to view and zoom factor.
+*/
+class WXDLLIMPEXP_MATHPLOT mpScaleX : public mpLayer
+{
+public:
+    /** Full constructor.
+		@param name Label to plot by the ruler
+		@param flags Set the position of the scale with respect to the window.
+		@param ticks Select ticks or grid. Give TRUE (default) for drawing axis ticks, FALSE for drawing the grid.
+		@param type mpX_NORMAL for normal labels, mpX_TIME for time axis in hours, minutes, seconds. */
+    mpScaleX(wxString name = wxT("X"), int flags = mpALIGN_CENTER, bool ticks = true, unsigned int type = mpX_NORMAL);
+
+    /** Layer plot handler.
+        This implementation will plot the ruler adjusted to the visible area. */
+    virtual void Plot(wxDC & dc, mpWindow & w);
+
+    /** Check whether this layer has a bounding box.
+        This implementation returns \a FALSE thus making the ruler invisible
+        to the plot layer bounding box calculation by mpWindow. */
+    virtual bool HasBBox() { return FALSE; }
+
+    /** Set X axis alignment.
+        @param align alignment (choose between mpALIGN_BORDER_BOTTOM, mpALIGN_BOTTOM, mpALIGN_CENTER, mpALIGN_TOP, mpALIGN_BORDER_TOP */
+    void SetAlign(int align) { m_flags = align; };
+
+    /** Set X axis ticks or grid
+        @param ticks TRUE to plot axis ticks, FALSE to plot grid. */
+    void SetTicks(bool ticks) { m_ticks = ticks; };
+
+    /** Get X axis ticks or grid
+        @return TRUE if plot is drawing axis ticks, FALSE if the grid is active. */
+    bool GetTicks() { return m_ticks; };
+
+    /** Get X axis label view mode.
+        @return mpX_NORMAL for normal labels, mpX_TIME for time axis in hours, minutes, seconds. */
+    unsigned int GetLabelMode() { return m_labelType; };
+
+    /** Set X axis label view mode.
+        @param mode mpX_NORMAL for normal labels, mpX_TIME for time axis in hours, minutes, seconds. */
+    void SetLabelMode(unsigned int mode) { m_labelType = mode; };
+	
+	/** Set X axis Label format (used for mpX_NORMAL draw mode).
+	    @param format The format string */
+	void SetLabelFormat(const wxString& format) { m_labelFormat = format; };
+
+	/** Get X axis Label format (used for mpX_NORMAL draw mode).
+	@return The format string */
+	const wxString& SetLabelFormat() { return m_labelFormat; };
+	
+protected:
+    int m_flags; //!< Flag for axis alignment
+    bool m_ticks; //!< Flag to toggle between ticks or grid
+    unsigned int m_labelType; //!< Select labels mode: mpX_NORMAL for normal labels, mpX_TIME for time axis in hours, minutes, seconds
+	wxString m_labelFormat; //!< Format string used to print labels
+
+    DECLARE_DYNAMIC_CLASS(mpScaleX)
+};
+
+/** Plot layer implementing a y-scale ruler.
+    If align is set to mpALIGN_CENTER, the ruler is fixed at X=0 in the coordinate system. If the align is set to mpALIGN_TOP or mpALIGN_BOTTOM, the axis is always drawn respectively at top or bottom of the window. A label is plotted at
+    the top-right hand of the ruler. The scale numbering automatically
+    adjusts to view and zoom factor.
+*/
+class WXDLLIMPEXP_MATHPLOT mpScaleY : public mpLayer
+{
+public:
+    /** @param name Label to plot by the ruler
+        @param flags Set position of the scale respect to the window.
+        @param ticks Select ticks or grid. Give TRUE (default) for drawing axis ticks, FALSE for drawing the grid */
+    mpScaleY(wxString name = wxT("Y"), int flags = mpALIGN_CENTER, bool ticks = true);
+
+    /** Layer plot handler.
+        This implementation will plot the ruler adjusted to the visible area.
+    */
+    virtual void Plot(wxDC & dc, mpWindow & w);
+
+    /** Check whether this layer has a bounding box.
+        This implementation returns \a FALSE thus making the ruler invisible
+        to the plot layer bounding box calculation by mpWindow.
+    */
+    virtual bool HasBBox() { return FALSE; }
+
+    /** Set Y axis alignment.
+        @param align alignment (choose between mpALIGN_BORDER_LEFT, mpALIGN_LEFT, mpALIGN_CENTER, mpALIGN_RIGHT, mpALIGN_BORDER_RIGHT) */
+    void SetAlign(int align) { m_flags = align; };
+
+    /** Set Y axis ticks or grid
+        @param ticks TRUE to plot axis ticks, FALSE to plot grid. */
+    void SetTicks(bool ticks) { m_ticks = ticks; };
+
+    /** Get Y axis ticks or grid
+        @return TRUE if plot is drawing axis ticks, FALSE if the grid is active. */
+    bool GetTicks() { return m_ticks; };
+	
+	/** Set Y axis Label format.
+	@param format The format string */
+	void SetLabelFormat(const wxString& format) { m_labelFormat = format; };
+	
+	/** Get Y axis Label format.
+	@return The format string */
+	const wxString& SetLabelFormat() { return m_labelFormat; };
+
+protected:
+    int m_flags; //!< Flag for axis alignment
+    bool m_ticks; //!< Flag to toggle between ticks or grid
+	wxString m_labelFormat; //!< Format string used to print labels
+
+    DECLARE_DYNAMIC_CLASS(mpScaleY)
+};
+
+//-----------------------------------------------------------------------------
+// mpWindow
+//-----------------------------------------------------------------------------
+
+/** @name Constants defining mouse modes for mpWindow
+@{*/
+
+/** Mouse panning drags the view. Mouse mode for mpWindow. */
+#define mpMOUSEMODE_DRAG    0
+/** Mouse panning creates a zoom box. Mouse mode for mpWindow. */
+#define mpMOUSEMODE_ZOOMBOX 1
+
+/*@}*/
+/** Define the type for the list of layers inside mpWindow */
+//WX_DECLARE_HASH_MAP( int, mpLayer*, wxIntegerHash, wxIntegerEqual, wxLayerList );
+typedef std::deque<mpLayer*> wxLayerList;
+
+/** Canvas for plotting mpLayer implementations.
+
+    This class defines a zoomable and moveable 2D plot canvas. Any number
+    of mpLayer implementations (scale rulers, function plots, ...) can be
+    attached using mpWindow::AddLayer.
+
+    The canvas window provides a context menu with actions for navigating the view.
+    The context menu can be retrieved with mpWindow::GetPopupMenu, e.g. for extending it
+    externally.
+
+    Since wxMathPlot version 0.03, the mpWindow incorporates the following features:
+        - DoubleBuffering (Default=disabled): Can be set with EnableDoubleBuffer
+        - Mouse based pan/zoom (Default=enabled): Can be set with EnableMousePanZoom.
+
+    The mouse commands can be visualized by the user through the popup menu, and are:
+        - Mouse Move+CTRL: Pan (Move)
+        - Mouse Wheel: Vertical scroll
+        - Mouse Wheel+SHIFT: Horizontal scroll
+        - Mouse Wheel UP+CTRL: Zoom in
+        - Mouse Wheel DOWN+CTRL: Zoom out
+
+*/
+class WXDLLIMPEXP_MATHPLOT mpWindow : public wxWindow
+{
+public:
+    mpWindow() {}
+    mpWindow( wxWindow *parent, wxWindowID id,
+                     const wxPoint &pos = wxDefaultPosition,
+                     const wxSize &size = wxDefaultSize,
+                     long flags = 0);
+    ~mpWindow();
+
+    /** Get reference to context menu of the plot canvas.
+        @return Pointer to menu. The menu can be modified.
+    */
+    wxMenu* GetPopupMenu() { return &m_popmenu; }
+
+    /** Add a plot layer to the canvas.
+        @param layer Pointer to layer. The mpLayer object will get under control of mpWindow,
+                     i.e. it will be delete'd on mpWindow destruction
+        @param refreshDisplay States whether to refresh the display (UpdateAll) after adding the layer.
+        @retval TRUE Success
+        @retval FALSE Failure due to out of memory.
+    */
+    bool AddLayer( mpLayer* layer, bool refreshDisplay = true);
+
+    /** Remove a plot layer from the canvas.
+        @param layer Pointer to layer. The mpLayer object will be destructed using delete.
+        @param alsoDeleteObject If set to true, the mpLayer object will be also "deleted", not just removed from the internal list.
+        @param refreshDisplay States whether to refresh the display (UpdateAll) after removing the layer.
+        @return true if layer is deleted correctly
+
+        N.B. Only the layer reference in the mpWindow is deleted, the layer object still exists!
+    */
+    bool DelLayer( mpLayer* layer, bool alsoDeleteObject = false, bool refreshDisplay = true);
+
+    /** Remove all layers from the plot.
+        @param alsoDeleteObject If set to true, the mpLayer objects will be also "deleted", not just removed from the internal list.
+        @param refreshDisplay States whether to refresh the display (UpdateAll) after removing the layers.
+    */
+    void DelAllLayers( bool alsoDeleteObject, bool refreshDisplay = true);
+	
+	
+    /*! Get the layer in list position indicated.
+        N.B. You <i>must</i> know the index of the layer inside the list!
+        @param position position of the layer in the layers list
+        @return pointer to mpLayer
+    */
+    mpLayer* GetLayer(int position);
+
+    /*! Get the layer by its name (case sensitive).
+        @param name The name of the layer to retrieve
+        @return A pointer to the mpLayer object, or NULL if not found.
+    */
+    mpLayer* GetLayerByName( const wxString &name);
+
+    /** Get current view's X scale.
+        See @ref mpLayer::Plot "rules for coordinate transformation"
+        @return Scale
+    */
+    double GetXscl() { return m_scaleX; }
+    double GetScaleX(void) const{ return m_scaleX; }; // Schaling's method: maybe another method esists with the same name
+
+    /** Get current view's Y scale.
+        See @ref mpLayer::Plot "rules for coordinate transformation"
+        @return Scale
+    */
+    double GetYscl() const { return m_scaleY; }
+    double GetScaleY(void) const { return m_scaleY; } // Schaling's method: maybe another method exists with the same name
+
+    /** Get current view's X position.
+        See @ref mpLayer::Plot "rules for coordinate transformation"
+        @return X Position in layer coordinate system, that corresponds to the center point of the view.
+    */
+    double GetXpos() const { return m_posX; }
+    double GetPosX(void) const { return m_posX; }
+
+    /** Get current view's Y position.
+        See @ref mpLayer::Plot "rules for coordinate transformation"
+        @return Y Position in layer coordinate system, that corresponds to the center point of the view.
+    */
+    double GetYpos() const { return m_posY; }
+    double GetPosY(void) const { return m_posY; }
+
+    /** Get current view's X dimension in device context units.
+        Usually this is equal to wxDC::GetSize, but it might differ thus mpLayer
+        implementations should rely on the value returned by the function.
+        See @ref mpLayer::Plot "rules for coordinate transformation"
+        @return X dimension.
+    */
+    int GetScrX(void) const { return m_scrX; }
+    int GetXScreen(void) const { return m_scrX; }
+
+    /** Get current view's Y dimension in device context units.
+        Usually this is equal to wxDC::GetSize, but it might differ thus mpLayer
+        implementations should rely on the value returned by the function.
+        See @ref mpLayer::Plot "rules for coordinate transformation"
+        @return Y dimension.
+    */
+    int GetScrY(void) const { return m_scrY; }
+    int GetYScreen(void) const { return m_scrY; }
+
+    /** Set current view's X scale and refresh display.
+        @param scaleX New scale, must not be 0.
+    */
+    void SetScaleX(double scaleX);
+
+    /** Set current view's Y scale and refresh display.
+        @param scaleY New scale, must not be 0.
+    */
+    void SetScaleY(double scaleY) { if (scaleY!=0) m_scaleY=scaleY; UpdateAll(); }
+
+    /** Set current view's X position and refresh display.
+        @param posX New position that corresponds to the center point of the view.
+    */
+    void SetPosX(double posX) { m_posX=posX; UpdateAll(); }
+
+    /** Set current view's Y position and refresh display.
+        @param posY New position that corresponds to the center point of the view.
+    */
+    void SetPosY(double posY) { m_posY=posY; UpdateAll(); }
+
+    /** Set current view's X and Y position and refresh display.
+        @param posX New position that corresponds to the center point of the view.
+        @param posY New position that corresponds to the center point of the view.
+    */
+    void SetPos( double posX, double posY) { m_posX=posX; m_posY=posY; UpdateAll(); }
+
+    /** Set current view's dimensions in device context units.
+        Needed by plotting functions. It doesn't refresh display.
+        @param scrX New position that corresponds to the center point of the view.
+        @param scrY New position that corresponds to the center point of the view.
+    */
+    void SetScr( int scrX, int scrY) { m_scrX=scrX; m_scrY=scrY; }
+    
+    /** Converts mpWindow (screen) pixel coordinates into graph (floating point) coordinates, using current mpWindow position and scale.
+      * @sa p2y,x2p,y2p */
+//     double p2x(wxCoord pixelCoordX, bool drawOutside = true ); // { return m_posX + pixelCoordX/m_scaleX; }
+    inline double p2x(wxCoord pixelCoordX ) { return m_posX + pixelCoordX/m_scaleX; }
+
+    /** Converts mpWindow (screen) pixel coordinates into graph (floating point) coordinates, using current mpWindow position and scale.
+      * @sa p2x,x2p,y2p */
+//     double p2y(wxCoord pixelCoordY, bool drawOutside = true ); //{ return m_posY - pixelCoordY/m_scaleY; }
+    inline double p2y(wxCoord pixelCoordY ) { return m_posY - pixelCoordY/m_scaleY; }
+
+    /** Converts graph (floating point) coordinates into mpWindow (screen) pixel coordinates, using current mpWindow position and scale.
+      * @sa p2x,p2y,y2p */
+//     wxCoord x2p(double x, bool drawOutside = true); // { return (wxCoord) ( (x-m_posX) * m_scaleX); }
+    inline wxCoord x2p(double x) { return (wxCoord) ( (x-m_posX) * m_scaleX); }
+
+    /** Converts graph (floating point) coordinates into mpWindow (screen) pixel coordinates, using current mpWindow position and scale.
+      * @sa p2x,p2y,x2p */
+//     wxCoord y2p(double y, bool drawOutside = true); // { return (wxCoord) ( (m_posY-y) * m_scaleY); }
+    inline wxCoord y2p(double y) { return (wxCoord) ( (m_posY-y) * m_scaleY); }
+
+
+    /** Enable/disable the double-buffering of the window, eliminating the flicker (default=disabled).
+     */
+    void EnableDoubleBuffer( bool enabled ) { m_enableDoubleBuffer = enabled; }
+
+    /** Enable/disable the feature of pan/zoom with the mouse (default=enabled)
+     */
+    void EnableMousePanZoom( bool enabled ) { m_enableMouseNavigation = enabled; }
+
+    /** Enable or disable X/Y scale aspect locking for the view.
+        @note Explicit calls to mpWindow::SetScaleX and mpWindow::SetScaleY will set
+              an unlocked aspect, but any other action changing the view scale will
+              lock the aspect again.
+    */
+    void LockAspect(bool enable = TRUE);
+
+    /** Checks whether the X/Y scale aspect is locked.
+        @retval TRUE Locked
+        @retval FALSE Unlocked
+    */
+    inline bool IsAspectLocked() { return m_lockaspect; }
+
+    /** Set view to fit global bounding box of all plot layers and refresh display.
+        Scale and position will be set to show all attached mpLayers.
+        The X/Y scale aspect lock is taken into account.
+    */
+    void Fit();
+
+    /** Set view to fit a given bounding box and refresh display.
+        The X/Y scale aspect lock is taken into account.
+	If provided, the parameters printSizeX and printSizeY are taken as the DC size, and the 
+        pixel scales are computed accordingly. Also, in this case the passed borders are not saved 
+        as the "desired borders", since this use will be invoked only when printing.
+    */
+    void Fit(double xMin, double xMax, double yMin, double yMax,wxCoord *printSizeX=NULL,wxCoord *printSizeY=NULL);
+
+    /** Zoom into current view and refresh display 
+      * @param centerPoint The point (pixel coordinates) that will stay in the same position on the screen after the zoom (by default, the center of the mpWindow).
+      */
+    void ZoomIn( const wxPoint& centerPoint = wxDefaultPosition );
+
+    /** Zoom out current view and refresh display
+      * @param centerPoint The point (pixel coordinates) that will stay in the same position on the screen after the zoom (by default, the center of the mpWindow).
+      */
+    void ZoomOut( const wxPoint& centerPoint = wxDefaultPosition );
+
+    /** Zoom in current view along X and refresh display */
+    void ZoomInX();
+    /** Zoom out current view along X and refresh display */
+    void ZoomOutX();
+    /** Zoom in current view along Y and refresh display */
+    void ZoomInY();
+    /** Zoom out current view along Y and refresh display */
+    void ZoomOutY();
+
+    /** Zoom view fitting given coordinates to the window (p0 and p1 do not need to be in any specific order) */
+    void ZoomRect(wxPoint p0, wxPoint p1);
+
+    /** Refresh display */
+    void UpdateAll();
+
+    // Added methods by Davide Rondini
+
+    /** Counts the number of plot layers, excluding axes or text: this is to count only the layers which have a bounding box.
+    	\return The number of profiles plotted.
+    */
+    unsigned int CountLayers();
+    
+    /** Counts the number of plot layers, whether or not they have a bounding box.
+    	\return The number of layers in the mpWindow. */
+    unsigned int CountAllLayers() { return m_layers.size(); };
+
+    /** Draws the mpWindow on a page for printing
+        \param print the mpPrintout where to print the graph */
+    //void PrintGraph(mpPrintout *print);
+
+
+	/** Returns the left-border layer coordinate that the user wants the mpWindow to show (it may be not exactly the actual shown coordinate in the case of locked aspect ratio).
+	  * @sa Fit
+   	  */
+	double GetDesiredXmin() {return m_desiredXmin; }
+
+	/** Returns the right-border layer coordinate that the user wants the mpWindow to show (it may be not exactly the actual shown coordinate in the case of locked aspect ratio).
+	  * @sa Fit
+   	  */
+	double GetDesiredXmax() {return m_desiredXmax; }
+
+	/** Returns the bottom-border layer coordinate that the user wants the mpWindow to show (it may be not exactly the actual shown coordinate in the case of locked aspect ratio).
+	  * @sa Fit
+   	  */
+	double GetDesiredYmin() {return m_desiredYmin; }
+
+	/** Returns the top layer-border coordinate that the user wants the mpWindow to show (it may be not exactly the actual shown coordinate in the case of locked aspect ratio).
+	  * @sa Fit
+   	  */
+	double GetDesiredYmax() {return m_desiredYmax; }
+
+	/** Returns the bounding box coordinates
+		@param bbox Pointer to a 6-element double array where to store bounding box coordinates. */
+	void GetBoundingBox(double* bbox);
+	
+    /** Enable/disable scrollbars
+      @param status Set to true to show scrollbars */
+    void SetMPScrollbars(bool status);
+
+    /** Get scrollbars status.
+      @return true if scrollbars are visible */
+    bool GetMPScrollbars() {return m_enableScrollBars; };
+
+    /** Draw the window on a wxBitmap, then save it to a file.
+      @param filename File name where to save the screenshot
+      @param type image type to be saved: see wxImage output file types for flags
+	  @param imageSize Set a size for the output image. Default is the same as the screen size
+	  @param fit Decide whether to fit the plot into the size*/
+    bool SaveScreenshot(const wxString& filename, int type = wxBITMAP_TYPE_BMP, wxSize imageSize = wxDefaultSize, bool fit = false);
+
+    /** This value sets the zoom steps whenever the user clicks "Zoom in/out" or performs zoom with the mouse wheel.
+      *  It must be a number above unity. This number is used for zoom in, and its inverse for zoom out. Set to 1.5 by default. */
+    static double zoomIncrementalFactor;
+
+    /** Set window margins, creating a blank area where some kinds of layers cannot draw. This is useful for example to draw axes outside the area where the plots are drawn.
+        @param top Top border
+        @param right Right border
+        @param bottom Bottom border
+        @param left Left border */
+    void SetMargins(int top, int right, int bottom, int left);
+
+    /** Set the top margin. @param top Top Margin */
+    void SetMarginTop(int top) { m_marginTop = top; };
+    /** Set the right margin. @param right Right Margin */
+    void SetMarginRight(int right) { m_marginRight = right; };
+    /** Set the bottom margin. @param bottom Bottom Margin */
+    void SetMarginBottom(int bottom) { m_marginBottom = bottom; };
+    /** Set the left margin. @param left Left Margin */
+    void SetMarginLeft(int left) { m_marginLeft = left; };
+
+    /** Get the top margin. @param top Top Margin */
+    int GetMarginTop() { return m_marginTop; };
+    /** Get the right margin. @param right Right Margin */
+    int GetMarginRight() { return m_marginRight; };
+    /** Get the bottom margin. @param bottom Bottom Margin */
+    int GetMarginBottom() { return m_marginBottom; };
+    /** Get the left margin. @param left Left Margin */
+    int GetMarginLeft() { return m_marginLeft; };
+
+    /** Sets whether to show coordinate tooltip when mouse passes over the plot. \param value true for enable, false for disable */
+    // void EnableCoordTooltip(bool value = true);
+    /** Gets coordinate tooltip status. \return true for enable, false for disable */
+    // bool GetCoordTooltip() { return m_coordTooltip; };
+
+    /** Check if a given point is inside the area of a mpInfoLayer and eventually returns its pointer.
+        @param point The position to be checked 
+        @return If an info layer is found, returns its pointer, NULL otherwise */
+    mpInfoLayer* IsInsideInfoLayer(wxPoint& point);
+	
+	/** Sets the visibility of a layer by its name.
+		@param name The layer name to set visibility
+		@param viewable the view status to be set */
+	void SetLayerVisible(const wxString &name, bool viewable);
+	
+	/** Check whether a layer with given name is visible
+		@param name The layer name
+		@return layer visibility status */
+	bool IsLayerVisible(const wxString &name );
+	
+	/** Sets the visibility of a layer by its position in layer list.
+		@param position The layer position in layer list
+		@param viewable the view status to be set */
+	void SetLayerVisible(const unsigned int position, bool viewable);
+	
+	/** Check whether the layer at given position is visible
+		@param position The layer position in layer list
+		@return layer visibility status */
+	bool IsLayerVisible(const unsigned int position );
+
+	/** Set Color theme. Provide colours to set a new colour theme.
+	    @param bgColour Background colour
+		@param drawColour The colour used to draw all elements in foreground, axes excluded
+		@param axesColour The colour used to draw axes (but not their labels) */
+	void SetColourTheme(const wxColour& bgColour, const wxColour& drawColour, const wxColour& axesColour);
+	
+	/** Get axes draw colour
+		@return reference to axis colour used in theme */
+	const wxColour& GetAxesColour() { return m_axColour; };
+
+protected:
+    void OnPaint         (wxPaintEvent     &event); //!< Paint handler, will plot all attached layers
+    void OnSize          (wxSizeEvent      &event); //!< Size handler, will update scroll bar sizes
+    // void OnScroll2       (wxScrollWinEvent &event); //!< Scroll handler, will move canvas
+    void OnShowPopupMenu (wxMouseEvent     &event); //!< Mouse handler, will show context menu
+    void OnMouseRightDown(wxMouseEvent     &event); //!< Mouse handler, for detecting when the user drags with the right button or just "clicks" for the menu
+    void OnCenter        (wxCommandEvent   &event); //!< Context menu handler
+    void OnFit           (wxCommandEvent   &event); //!< Context menu handler
+    void OnZoomIn        (wxCommandEvent   &event); //!< Context menu handler
+    void OnZoomOut       (wxCommandEvent   &event); //!< Context menu handler
+    void OnLockAspect    (wxCommandEvent   &event); //!< Context menu handler
+    void OnMouseHelp     (wxCommandEvent   &event); //!< Context menu handler
+    void OnMouseWheel    (wxMouseEvent     &event); //!< Mouse handler for the wheel
+    void OnMouseMove     (wxMouseEvent     &event); //!< Mouse handler for mouse motion (for pan)
+    void OnMouseLeftDown (wxMouseEvent     &event); //!< Mouse left click (for rect zoom)
+    void OnMouseLeftRelease (wxMouseEvent  &event); //!< Mouse left click (for rect zoom)
+    void OnScrollThumbTrack (wxScrollWinEvent &event); //!< Scroll thumb on scroll bar moving
+    void OnScrollPageUp     (wxScrollWinEvent &event); //!< Scroll page up 
+    void OnScrollPageDown   (wxScrollWinEvent &event); //!< Scroll page down 
+    void OnScrollLineUp     (wxScrollWinEvent &event); //!< Scroll line up 
+    void OnScrollLineDown   (wxScrollWinEvent &event); //!< Scroll line down
+    void OnScrollTop        (wxScrollWinEvent &event); //!< Scroll to top 
+    void OnScrollBottom     (wxScrollWinEvent &event); //!< Scroll to bottom
+
+    void DoScrollCalc    (const int position, const int orientation);
+
+    void DoZoomInXCalc   (const int         staticXpixel);
+    void DoZoomInYCalc   (const int         staticYpixel);
+    void DoZoomOutXCalc  (const int         staticXpixel);
+    void DoZoomOutYCalc  (const int         staticYpixel);
+
+    /** Recalculate global layer bounding box, and save it in m_minX,...
+      * \return true if there is any valid BBox information.
+      */
+    virtual bool UpdateBBox();
+
+    //wxList m_layers;    //!< List of attached plot layers
+    wxLayerList m_layers; //!< List of attached plot layers
+    wxMenu m_popmenu;   //!< Canvas' context menu
+    bool   m_lockaspect;//!< Scale aspect is locked or not
+    // bool   m_coordTooltip; //!< Selects whether to show coordinate tooltip
+	wxColour m_bgColour;	//!< Background Colour
+	wxColour m_fgColour;	//!< Foreground Colour
+	wxColour m_axColour;	//!< Axes Colour
+
+    double m_minX;      //!< Global layer bounding box, left border incl.
+    double m_maxX;      //!< Global layer bounding box, right border incl.
+    double m_minY;      //!< Global layer bounding box, bottom border incl.
+    double m_maxY;      //!< Global layer bounding box, top border incl.
+    double m_scaleX;    //!< Current view's X scale
+    double m_scaleY;    //!< Current view's Y scale
+    double m_posX;      //!< Current view's X position
+    double m_posY;      //!< Current view's Y position
+    int    m_scrX;      //!< Current view's X dimension
+    int    m_scrY;      //!< Current view's Y dimension
+    int    m_clickedX;  //!< Last mouse click X position, for centering and zooming the view
+    int    m_clickedY;  //!< Last mouse click Y position, for centering and zooming the view
+
+    /** These are updated in Fit() only, and may be different from the real borders (layer coordinates) only if lock aspect ratio is true.
+      */
+    double m_desiredXmin,m_desiredXmax,m_desiredYmin,m_desiredYmax;
+
+    int m_marginTop, m_marginRight, m_marginBottom, m_marginLeft;
+
+    int         m_last_lx,m_last_ly;   //!< For double buffering
+    wxMemoryDC  m_buff_dc;             //!< For double buffering
+    wxBitmap    *m_buff_bmp;            //!< For double buffering
+    bool        m_enableDoubleBuffer;  //!< For double buffering
+    bool        m_enableMouseNavigation;  //!< For pan/zoom with the mouse.
+    bool        m_mouseMovedAfterRightClick;
+    long        m_mouseRClick_X,m_mouseRClick_Y; //!< For the right button "drag" feature
+    int         m_mouseLClick_X, m_mouseLClick_Y; //!< Starting coords for rectangular zoom selection
+    bool        m_enableScrollBars;
+    int         m_scrollX, m_scrollY;
+    mpInfoLayer* m_movingInfoLayer;      //!< For moving info layers over the window area
+
+    DECLARE_DYNAMIC_CLASS(mpWindow)
+    DECLARE_EVENT_TABLE()
+};
+
+//-----------------------------------------------------------------------------
+// mpFXYVector - provided by Jose Luis Blanco
+//-----------------------------------------------------------------------------
+
+/** A class providing graphs functionality for a 2D plot (either continuous or a set of points), from vectors of data.
+     This class can be used directly, the user does not need to derive any new class. Simply pass the data as two vectors
+     with the same length containing the X and Y coordinates to the method SetData.
+
+     To generate a graph with a set of points, call
+     \code
+     layerVar->SetContinuity(false)
+     \endcode
+
+     or
+
+     \code
+     layerVar->SetContinuity(true)
+     \endcode
+
+     to render the sequence of coordinates as a continuous line.
+
+     (Added: Jose Luis Blanco, AGO-2007)
+*/
+class WXDLLIMPEXP_MATHPLOT mpFXYVector : public mpFXY
+{
+public:
+    /** @param name  Label
+        @param flags Label alignment, pass one of #mpALIGN_NE, #mpALIGN_NW, #mpALIGN_SW, #mpALIGN_SE.
+    */
+    mpFXYVector(wxString name = wxEmptyString, int flags = mpALIGN_NE);
+
+    /** Changes the internal data: the set of points to draw.
+        Both vectors MUST be of the same length. This method DOES NOT refresh the mpWindow; do it manually.
+      * @sa Clear
+    */
+    void SetData( const std::vector<double> &xs,const std::vector<double> &ys);
+
+    /** Clears all the data, leaving the layer empty.
+      * @sa SetData
+      */
+    void Clear();
+
+protected:
+    /** The internal copy of the set of data to draw.
+      */
+    std::vector<double>  m_xs,m_ys;
+
+    /** The internal counter for the "GetNextXY" interface
+      */
+    size_t              m_index;
+
+    /** Loaded at SetData
+      */
+    double              m_minX,m_maxX,m_minY,m_maxY;
+
+    /** Rewind value enumeration with mpFXY::GetNextXY.
+        Overridden in this implementation.
+    */
+    void Rewind();
+
+    /** Get locus value for next N.
+        Overridden in this implementation.
+        @param x Returns X value
+        @param y Returns Y value
+    */
+    bool GetNextXY(double & x, double & y);
+
+    /** Returns the actual minimum X data (loaded in SetData).
+      */
+    double GetMinX() { return m_minX; }
+
+    /** Returns the actual minimum Y data (loaded in SetData).
+      */
+    double GetMinY() { return m_minY; }
+
+    /** Returns the actual maximum X data (loaded in SetData).
+      */
+    double GetMaxX() { return m_maxX; }
+
+    /** Returns the actual maximum Y data (loaded in SetData).
+      */
+    double GetMaxY() { return m_maxY; }
+
+    int     m_flags; //!< Holds label alignment
+
+    DECLARE_DYNAMIC_CLASS(mpFXYVector)
+};
+
+//-----------------------------------------------------------------------------
+// mpText - provided by Val Greene
+//-----------------------------------------------------------------------------
+
+/** Plot layer implementing a text string.
+The text is plotted using a percentage system 0-100%, so the actual
+coordinates for the location are not required, and the text stays
+on the plot reguardless of the other layers location and scaling
+factors.
+*/
+class WXDLLIMPEXP_MATHPLOT mpText : public mpLayer
+{
+public:
+    /** @param name text to be drawn in the plot
+        @param offsetx holds offset for the X location in percentage (0-100)
+        @param offsety holds offset for the Y location in percentage (0-100) */
+    mpText(wxString name = wxT("Title"), int offsetx = 5, int offsety = 50);
+
+    /** Text Layer plot handler.
+        This implementation will plot text adjusted to the visible area. */
+    virtual void Plot(wxDC & dc, mpWindow & w);
+
+    /** mpText should not be used for scaling decisions. */
+    virtual bool HasBBox() { return FALSE; }
+
+protected:
+    int m_offsetx; //!< Holds offset for X in percentage
+    int m_offsety; //!< Holds offset for Y in percentage
+
+    DECLARE_DYNAMIC_CLASS(mpText)
+};
+
+
+//-----------------------------------------------------------------------------
+// mpMarker - provided by R1kk3r
+//-----------------------------------------------------------------------------
+
+/** Plot layer implementing a text string.
+The text is plotted using an absolute x,y position.
+*/
+class WXDLLIMPEXP_MATHPLOT mpMarker : public mpLayer
+{
+public:
+    /** @param name text to be drawn in the plot
+        @param atX absolute X location
+        @param atY absolute Y location */
+    mpMarker(wxString name = wxT("[M]"), double atX = 0.0, double atY = 0.0);
+    
+    /** Set the position of the marker.
+        @param atX absolute X location
+        @param atY absolute Y location */
+    void SetPos(double atX, double atY) {mX = atX, mY = atY; };
+
+    /** Marker Layer plot handler.
+        This implementation will plot text at the given x,y position. */
+    virtual void Plot(wxDC & dc, mpWindow & w);
+
+    /** mpMarker should not be used for scaling decisions. */
+    virtual bool HasBBox() { return FALSE; }
+
+protected:
+
+    double  mX, mY;
+
+    DECLARE_DYNAMIC_CLASS(mpText)
+};
+
+
+//-----------------------------------------------------------------------------
+// mpPrintout - provided by Davide Rondini
+//-----------------------------------------------------------------------------
+
+/** Printout class used by mpWindow to draw in the objects to be printed.
+    The object itself can then used by the default wxWidgets printing system
+    to print mppWindow objects.
+*/
+class WXDLLIMPEXP_MATHPLOT mpPrintout : public wxPrintout
+{
+public:
+    mpPrintout(mpWindow* drawWindow, const wxChar *title = _T("wxMathPlot print output"));
+    virtual ~mpPrintout() {};
+
+    void SetDrawState(bool drawState) {drawn = drawState;};
+    bool OnPrintPage(int page);
+    bool HasPage(int page);
+
+private:
+    bool drawn;
+    mpWindow *plotWindow;
+};
+
+
+//-----------------------------------------------------------------------------
+// mpMovableObject  - provided by Jose Luis Blanco
+//-----------------------------------------------------------------------------
+/** This virtual class represents objects that can be moved to an arbitrary 2D location+rotation.
+  *  The current transformation is set through SetCoordinateBase.
+  *  To ease the implementation of descendent classes, mpMovableObject will
+  *  be in charge of Bounding Box computation and layer rendering, assuming that
+  *  the object updates its shape in m_shape_xs & m_shape_ys.
+  */
+class WXDLLIMPEXP_MATHPLOT mpMovableObject : public mpLayer
+{
+public:
+    /** Default constructor (sets location and rotation to (0,0,0))
+      */
+    mpMovableObject( ) :
+        m_reference_x(0),
+        m_reference_y(0),
+        m_reference_phi(0),
+        m_shape_xs(0),
+        m_shape_ys(0)
+    {
+        m_type = mpLAYER_PLOT;
+    }
+
+    virtual ~mpMovableObject() {};
+
+    /** Get the current coordinate transformation.
+      */
+    void GetCoordinateBase( double &x, double &y, double &phi ) const
+    {
+        x = m_reference_x;
+        y = m_reference_y;
+        phi = m_reference_phi;
+    }
+
+    /** Set the coordinate transformation (phi in radians, 0 means no rotation).
+      */
+    void SetCoordinateBase( double x, double y, double phi = 0 )
+    {
+        m_reference_x = x;
+        m_reference_y = y;
+        m_reference_phi = phi;
+        m_flags  = mpALIGN_NE;
+        ShapeUpdated();
+    }
+
+    virtual bool HasBBox() { return m_trans_shape_xs.size()!=0; }
+
+    /** Get inclusive left border of bounding box.
+    */
+    virtual double GetMinX() { return m_bbox_min_x; }
+
+    /** Get inclusive right border of bounding box.
+    */
+    virtual double GetMaxX() { return  m_bbox_max_x; }
+
+    /** Get inclusive bottom border of bounding box.
+    */
+    virtual double GetMinY() { return m_bbox_min_y; }
+
+    /** Get inclusive top border of bounding box.
+    */
+    virtual double GetMaxY() { return m_bbox_max_y; }
+
+    virtual void   Plot(wxDC & dc, mpWindow & w);
+
+    /** Set label axis alignment.
+      *  @param align alignment (choose between mpALIGN_NE, mpALIGN_NW, mpALIGN_SW, mpALIGN_SE
+      */
+    void SetAlign(int align) { m_flags = align; };
+
+protected:
+    int m_flags; //!< Holds label alignment
+
+    /** The coordinates of the object (orientation "phi" is in radians).
+      */
+    double m_reference_x,m_reference_y,m_reference_phi;
+
+    /** A method for 2D translation and rotation, using the current transformation stored in m_reference_x,m_reference_y,m_reference_phi.
+      */
+    void TranslatePoint( double x,double y, double &out_x, double &out_y );
+
+    /** This contains the object points, in local coordinates (to be transformed by the current transformation).
+      */
+    std::vector<double>  m_shape_xs,m_shape_ys;
+
+    /** The buffer for the translated & rotated points (to avoid recomputing them with each mpWindow refresh).
+      *
+      */
+    std::vector<double>  m_trans_shape_xs,m_trans_shape_ys;
+
+    /** The precomputed bounding box:
+      * @sa ShapeUpdated
+      */
+    double  m_bbox_min_x,m_bbox_max_x,m_bbox_min_y,m_bbox_max_y;
+
+    /** Must be called by the descendent class after updating the shape (m_shape_xs/ys), or when the transformation changes.
+      *  This method updates the buffers m_trans_shape_xs/ys, and the precomputed bounding box.
+      */
+    void ShapeUpdated();
+
+};
+
+//-----------------------------------------------------------------------------
+// mpCovarianceEllipse  - provided by Jose Luis Blanco
+//-----------------------------------------------------------------------------
+/** A 2D ellipse, described by a 2x2 covariance matrix.
+  *  The relation between the multivariate Gaussian confidence interval and
+  *   the "quantiles" in this class is:
+  *     - 1 : 68.27% confidence interval
+  *     - 2 : 95.45%
+  *     - 3 : 99.73%
+  *     - 4 : 99.994%
+  * For example, see http://en.wikipedia.org/wiki/Normal_distribution#Standard_deviation_and_confidence_intervals
+  *
+  * The ellipse will be always centered at the origin. Use mpMovableObject::SetCoordinateBase to move it.
+  */
+class WXDLLIMPEXP_MATHPLOT mpCovarianceEllipse : public mpMovableObject
+{
+public:
+    /** Default constructor.
+      * Initializes to a unity diagonal covariance matrix, a 95% confidence interval (2 sigmas), 32 segments, and a continuous plot (m_continuous=true).
+      */
+    mpCovarianceEllipse(
+        double cov_00 = 1,
+        double cov_11 = 1,
+        double cov_01 = 0,
+        double quantiles = 2,
+        int    segments = 32,
+        const wxString & layerName = wxT("") ) :
+            m_cov_00(cov_00),
+            m_cov_11(cov_11),
+            m_cov_01(cov_01),
+            m_quantiles(quantiles),
+            m_segments(segments)
+    {
+        m_continuous = true;
+        m_name = layerName;
+        RecalculateShape();
+        m_type = mpLAYER_PLOT;
+    }
+
+    virtual ~mpCovarianceEllipse() {}
+
+    double GetQuantiles() const { return m_quantiles; }
+
+    /** Set how many "quantiles" to draw, that is, the confidence interval of the ellipse (see above).
+      */
+    void SetQuantiles(double q)
+    {
+        m_quantiles=q;
+        RecalculateShape();
+    }
+
+    void SetSegments( int segments ) { m_segments = segments; }
+    int GetSegments( ) const { return m_segments; }
+
+    /** Returns the elements of the current covariance matrix:
+      */
+    void GetCovarianceMatrix( double &cov_00,double &cov_01,double &cov_11 ) const
+    {
+        cov_00 = m_cov_00;
+        cov_01 = m_cov_01;
+        cov_11 = m_cov_11;
+    }
+
+    /** Changes the covariance matrix:
+      */
+    void SetCovarianceMatrix( double cov_00,double cov_01,double cov_11 )
+    {
+        m_cov_00 = cov_00;
+        m_cov_01 = cov_01;
+        m_cov_11 = cov_11;
+        RecalculateShape();
+    }
+
+protected:
+    /** The elements of the matrix (only 3 since cov(0,1)=cov(1,0) in any positive definite matrix).
+      */
+    double m_cov_00,m_cov_11,m_cov_01;
+    double m_quantiles;
+
+    /** The number of line segments that build up the ellipse.
+      */
+    int m_segments;
+
+    /** Called to update the m_shape_xs, m_shape_ys vectors, whenever a parameter changes.
+      */
+    void RecalculateShape();
+};
+
+//-----------------------------------------------------------------------------
+// mpPolygon - provided by Jose Luis Blanco
+//-----------------------------------------------------------------------------
+/** An arbitrary polygon, descendant of mpMovableObject.
+  *  Use "setPoints" to set the list of N points. This class also can draw non-closed polygons by
+  *   passing the appropriate parameters to "setPoints". To draw a point-cloud, call "SetContinuity(false)".
+  */
+class WXDLLIMPEXP_MATHPLOT mpPolygon : public mpMovableObject
+{
+public:
+    /** Default constructor.
+      */
+    mpPolygon( const wxString & layerName = wxT("") )
+    {
+        m_continuous = true;
+        m_name = layerName;
+    }
+
+    virtual ~mpPolygon() {}
+
+    /** Set the points in the polygon.
+      * @param points_xs  The X coordinates of the points.
+      * @param points_ys  The Y coordinates of the points.
+      * @param closedShape If set to true, an additional segment will be added from the last to the first point.
+      */
+    void setPoints(
+        const std::vector<double>&  points_xs,
+        const std::vector<double>&  points_ys,
+        bool                   closedShape=true );
+
+
+
+};
+
+//-----------------------------------------------------------------------------
+// mpBitmapLayer - provided by Jose Luis Blanco
+//-----------------------------------------------------------------------------
+/** A layer that allows you to have a bitmap image printed in the mpWindow.
+    Use SetBitmap() to load the image in the right place.
+    You can retrieve the image from the layer at anytime you want with getBitmapCopy()
+  */
+class WXDLLIMPEXP_MATHPLOT mpBitmapLayer : public mpLayer
+{
+public:
+    /** Default constructor.
+      */
+    mpBitmapLayer( )
+    {
+        m_min_x = m_max_x =
+        m_min_y = m_max_y = 0;
+        m_validImg = false;
+        m_type = mpLAYER_BITMAP;
+    }
+
+    virtual ~mpBitmapLayer() {};
+
+    /** Returns a copy of the current bitmap assigned to the layer.
+      */
+    void GetBitmapCopy( wxImage &outBmp ) const;
+
+    /** Change the bitmap associated with the layer (to update the screen, refresh the mpWindow).
+      *  @param inBmp The bitmap to associate. A copy is made, thus it can be released after calling this.
+      *  @param x The left corner X coordinate (in plot units).
+      *  @param y The top corner Y coordinate (in plot units).
+      *  @param lx The width in plot units.
+      *  @param ly The height in plot units.
+      */
+    void SetBitmap( const wxImage &inBmp, double x, double y, double lx, double ly );
+
+    virtual bool HasBBox() { return true; }
+
+    /** Get inclusive left border of bounding box.
+    */
+    virtual double GetMinX() { return m_min_x; }
+
+    /** Get inclusive right border of bounding box.
+    */
+    virtual double GetMaxX() { return  m_max_x; }
+
+    /** Get inclusive bottom border of bounding box.
+    */
+    virtual double GetMinY() { return m_min_y; }
+
+    /** Get inclusive top border of bounding box.
+    */
+    virtual double GetMaxY() { return m_max_y; }
+
+    virtual void   Plot(wxDC & dc, mpWindow & w);
+
+    /** Set label axis alignment.
+      *  @param align alignment (choose between mpALIGN_NE, mpALIGN_NW, mpALIGN_SW, mpALIGN_SE
+      */
+    void SetAlign(int align) { m_flags = align; };
+
+protected:
+    int m_flags; //!< Holds label alignment
+
+    /** The internal copy of the Bitmap:
+      */
+    wxImage      m_bitmap;
+    wxBitmap     m_scaledBitmap;
+    wxCoord      m_scaledBitmap_offset_x,m_scaledBitmap_offset_y;
+
+
+    bool            m_validImg;
+
+
+    /** The shape of the bitmap:
+      */
+    double  m_min_x,m_max_x,m_min_y,m_max_y;
+
+
+};
+
+
+
+/*@}*/
+
+#endif // _MP_MATHPLOT_H_
Index: src/plugins/contrib/wxSmithPlot/wxsAxis.cpp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsAxis.cpp b/trunk/src/plugins/contrib/wxSmithPlot/wxsAxis.cpp
--- a/trunk/src/plugins/contrib/wxSmithPlot/wxsAxis.cpp	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsAxis.cpp	(copie de travail)
@@ -21,9 +21,8 @@
 */
 
 #include "wxsAxis.h"
-#include "../wxsitemresdata.h"
+#include <wxwidgets/wxsitemresdata.h>
 
-
 //------------------------------------------------------------------------------
 
 namespace
@@ -30,8 +29,8 @@
 {
 //    wxsRegisterItem<wxsStaticText> Reg(_T("StaticText"),wxsTWidget,_T("Standard"),80);
 
-    #include "axis16.xpm"
-    #include "axis32.xpm"
+    #include "images/axis16.xpm"
+    #include "images/axis32.xpm"
 
     wxsRegisterItem<wxsAxis> Reg(
         _T("mpAxis"),                   // Class name
@@ -105,8 +104,8 @@
 
 // create the axis -- but not the setup code
 
-    if (mType == 0) Codef(_T("%s = new mpScaleX(_(\"%s\"), %d, %b);\n"), vname.c_str(), mLabel.c_str(), mAlign, mTics);
-    else            Codef(_T("%s = new mpScaleY(_(\"%s\"), %d, %b);\n"), vname.c_str(), mLabel.c_str(), mAlign, mTics);
+    if (mType == 0) Codef(_T("%s = new mpScaleX(_(\"%s\"), %d, %b);\n"), vname.wx_str(), mLabel.wx_str(), mAlign, mTics);
+    else            Codef(_T("%s = new mpScaleY(_(\"%s\"), %d, %b);\n"), vname.wx_str(), mLabel.wx_str(), mAlign, mTics);
 //  BuildSetupWindowCode();
 
 // assign a pen to the layer
@@ -113,8 +112,8 @@
 
     dtext = mPenColour.BuildCode(GetCoderContext());
     if (dtext.Len() > 0) {
-        Codef(_T("wxPen   %s(%s);\n"), cname.c_str(), dtext.c_str());
-        Codef(_T("%s->SetPen(%s);\n"), vname.c_str(), cname.c_str());
+        Codef(_T("wxPen   %s(%s);\n"), cname.wx_str(), dtext.wx_str());
+        Codef(_T("%s->SetPen(%s);\n"), vname.wx_str(), cname.wx_str());
     };
 
 // assign a font to the layer
@@ -121,8 +120,8 @@
 
     dtext = mPenFont.BuildFontCode(fname, GetCoderContext());
     if (dtext.Len() > 0) {
-        Codef(_T("%s"), dtext.c_str());
-        Codef(_T("%s->SetFont(%s);\n"), vname.c_str(), fname.c_str());
+        Codef(_T("%s"), dtext.wx_str());
+        Codef(_T("%s->SetFont(%s);\n"), vname.wx_str(), fname.wx_str());
     };
 
 // add to parent window -- should be a mpWindow
@@ -130,7 +129,7 @@
     if ((GetPropertiesFlags() & flHidden) && GetBaseProps()->m_Hidden)
         ; // do nothing
     else
-        Codef(_T("%s->AddLayer(%s);\n"), pname.c_str(), vname.c_str());
+        Codef(_T("%s->AddLayer(%s);\n"), pname.wx_str(), vname.wx_str());
 }
 
 //------------------------------------------------------------------------------
Index: src/plugins/contrib/wxSmithPlot/wxsAxis.h
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsAxis.h b/trunk/src/plugins/contrib/wxSmithPlot/wxsAxis.h
--- a/trunk/src/plugins/contrib/wxSmithPlot/wxsAxis.h	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsAxis.h	(copie de travail)
@@ -23,7 +23,7 @@
 #ifndef WXSSTATICTEXT1_H
 #define WXSSTATICTEXT1_H
 
-#include    "../wxswidget.h"
+#include    <wxwidgets/wxswidget.h>
 
 #include    <wx/stattext.h>
 #include    <mathplot.h>
Index: src/plugins/contrib/wxSmithPlot/wxsMarker.cpp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsMarker.cpp b/trunk/src/plugins/contrib/wxSmithPlot/wxsMarker.cpp
--- a/trunk/src/plugins/contrib/wxSmithPlot/wxsMarker.cpp	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsMarker.cpp	(copie de travail)
@@ -18,7 +18,7 @@
 */
 
 #include "wxsMarker.h"
-#include "../wxsitemresdata.h"
+#include <wxwidgets/wxsitemresdata.h>
 
 //------------------------------------------------------------------------------
 
@@ -27,8 +27,8 @@
 
 // Loading images from xpm files
 
-    #include "marker16.xpm"
-    #include "marker32.xpm"
+    #include "images/marker16.xpm"
+    #include "images/marker32.xpm"
 
     wxsRegisterItem<wxsMarker> Reg(
         _T("mpMarker"),                 // Class name
@@ -102,11 +102,11 @@
 
 // the header for mathplot
 
-    AddHeader(_T("<mpMarker.h>"),GetInfo().ClassName,hfInPCH);
+    AddHeader(_T("<mathplot.h>"),GetInfo().ClassName,hfInPCH);
 
 // create the vector -- but not the setup code
 
-    Codef(_T("%s = new mpMarker(%t, %s, %s);\n"), vname.c_str(), mLabel.c_str(), mXpos.c_str(), mYpos.c_str());
+    Codef(_T("%s = new mpMarker(%t, %s, %s);\n"), vname.wx_str(), mLabel.wx_str(), mXpos.wx_str(), mYpos.wx_str());
 //  BuildSetupWindowCode();
 
 // assign a pen to the layer
@@ -113,8 +113,8 @@
 
     dtext = mPenColour.BuildCode(GetCoderContext());
     if (dtext.Len() > 0) {
-        Codef(_T("wxPen   %s(%s);\n"), cname.c_str(), dtext.c_str());
-        Codef(_T("%s->SetPen(%s);\n"), vname.c_str(), cname.c_str());
+        Codef(_T("wxPen   %s(%s);\n"), cname.wx_str(), dtext.wx_str());
+        Codef(_T("%s->SetPen(%s);\n"), vname.wx_str(), cname.wx_str());
     };
 
 // assign a font to the layer
@@ -121,8 +121,8 @@
 
     dtext = mPenFont.BuildFontCode(fname, GetCoderContext());
     if (dtext.Len() > 0) {
-        Codef(_T("%s"), dtext.c_str());
-        Codef(_T("%s->SetFont(%s);\n"), vname.c_str(), fname.c_str());
+        Codef(_T("%s"), dtext.wx_str());
+        Codef(_T("%s->SetFont(%s);\n"), vname.wx_str(), fname.wx_str());
     };
 
 // add to parent window -- should be a mpWindow
@@ -130,7 +130,7 @@
     if ((GetPropertiesFlags() & flHidden) && GetBaseProps()->m_Hidden)
         ; // do nothing
     else
-        Codef(_T("%s->AddLayer(%s);\n"), pname.c_str(), vname.c_str());
+        Codef(_T("%s->AddLayer(%s);\n"), pname.wx_str(), vname.wx_str());
 
 
 }
Index: src/plugins/contrib/wxSmithPlot/wxsMarker.h
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsMarker.h b/trunk/src/plugins/contrib/wxSmithPlot/wxsMarker.h
--- a/trunk/src/plugins/contrib/wxSmithPlot/wxsMarker.h	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsMarker.h	(copie de travail)
@@ -23,9 +23,8 @@
 #include    <iostream>
 
 #include    <wx/stattext.h>
-#include    "../wxswidget.h"
+#include    <wxwidgets/wxswidget.h>
 #include    <mathplot.h>
-#include    <mpMarker.h>
 
 
 class wxsMarker: public wxsWidget
Index: src/plugins/contrib/wxSmithPlot/wxsMathPlot.cpp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsMathPlot.cpp b/trunk/src/plugins/contrib/wxSmithPlot/wxsMathPlot.cpp
--- a/trunk/src/plugins/contrib/wxSmithPlot/wxsMathPlot.cpp	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsMathPlot.cpp	(copie de travail)
@@ -29,8 +29,8 @@
 
 // Loading images from xpm files
 
-    #include "plot16.xpm"
-    #include "plot32.xpm"
+    #include "images/plot16.xpm"
+    #include "images/plot32.xpm"
 
     wxsRegisterItem<wxsMathPlot> Reg(
         _T("mpWindow"),                 // Class name
@@ -99,7 +99,7 @@
 
 // create the panel
 
-    Codef(_T("%s = new mpWindow(%W, %I, %P, %S, %T);\n"), vname.c_str());
+    Codef(_T("%s = new mpWindow(%W, %I, %P, %S, %T);\n"), vname.wx_str());
     BuildSetupWindowCode();
 
 // add children
Index: src/plugins/contrib/wxSmithPlot/wxsMathPlot.h
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsMathPlot.h b/trunk/src/plugins/contrib/wxSmithPlot/wxsMathPlot.h
--- a/trunk/src/plugins/contrib/wxSmithPlot/wxsMathPlot.h	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsMathPlot.h	(copie de travail)
@@ -26,7 +26,6 @@
 #include    <cmath>
 #include    <iostream>
 
-#include    <windef.h>
 #include    <wx/settings.h>
 #include    <wx/utils.h>
 #include    <wx/string.h>
@@ -33,8 +32,8 @@
 #include    <wx/filename.h>
 
 
-#include "../wxscontainer.h"
-#include "../wxsitemresdata.h"
+#include <wxwidgets/wxscontainer.h>
+#include <wxwidgets/wxsitemresdata.h>
 
 #include    <mathplot.h>
 
Index: src/plugins/contrib/wxSmithPlot/wxsSmithPlot-unix.cbp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsSmithPlot-unix.cbp b/trunk/src/plugins/contrib/wxSmithPlot/wxsSmithPlot-unix.cbp
new file mode 10644
--- /dev/null	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsSmithPlot-unix.cbp	(copie de travail)
@@ -0,0 +1,138 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="6" />
+	<Project>
+		<Option title="wxSmithPlot - Curve Plotting" />
+		<Option pch_mode="2" />
+		<Option compiler="gcc" />
+		<Build>
+			<Target title="MathPlot">
+				<Option output="../../../devel/MathPlot" prefix_auto="1" extension_auto="1" />
+				<Option working_dir="wxmathplot/" />
+				<Option object_output="../../../.objs/plugins/contrib/wxSmithPlot/MathPlot" />
+				<Option type="2" />
+				<Option compiler="gcc" />
+				<Option createDefFile="1" />
+			</Target>
+			<Target title="wxSmithPlot">
+				<Option platforms="Unix;" />
+				<Option output="../../../devel/share/codeblocks/plugins/wxSmithPlot" prefix_auto="0" extension_auto="1" />
+				<Option working_dir="../../../devel" />
+				<Option object_output="../../../.objs/plugins/contrib/wxSmithPlot" />
+				<Option type="3" />
+				<Option compiler="gcc" />
+				<Option parameters="--debug-log --multiple-instance -ns -ni -p debug" />
+				<Option host_application="../../../devel/codeblocks" />
+				<Option run_host_application_in_terminal="0" />
+				<Option projectLinkerOptionsRelation="2" />
+				<Compiler>
+					<Add option="-ansi" />
+					<Add option="-Winvalid-pch" />
+					<Add option="-fexceptions" />
+					<Add option="-DBUILDING_PLUGIN" />
+					<Add option="-DcbDEBUG" />
+					<Add option="-DCB_PRECOMP" />
+					<Add directory="../../../include" />
+					<Add directory="../../../sdk/wxscintilla/include" />
+					<Add directory="../../../sdk/wxpropgrid/include" />
+					<Add directory="../wxSmith/properties" />
+					<Add directory="../wxSmith/wxwidgets" />
+					<Add directory="../wxSmith/wxwidgets/properties" />
+					<Add directory="../wxSmith" />
+					<Add directory="images" />
+				</Compiler>
+				<Linker>
+					<Add option="-Wl,--no-undefined" />
+					<Add library="MathPlot" />
+					<Add library="wxsmithlib" />
+					<Add library="codeblocks" />
+					<Add library="wx_gtk2u_propgrid-3.0" />
+					<Add directory="../../../devel" />
+				</Linker>
+				<ExtraCommands>
+					<Add after="zip -j9 ../../../devel/share/codeblocks/wxSmithPlot.zip manifest.xml" />
+					<Mode after="always" />
+				</ExtraCommands>
+			</Target>
+		</Build>
+		<VirtualTargets>
+			<Add alias="All" targets="MathPlot;wxSmithPlot;" />
+		</VirtualTargets>
+		<Compiler>
+			<Add option="-ansi" />
+			<Add option="`wx-config --cflags`" />
+			<Add option="-fPIC" />
+		</Compiler>
+		<Linker>
+			<Add option="`wx-config --libs`" />
+		</Linker>
+		<Unit filename="images/axis16.xpm">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="images/axis32.xpm">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="images/text16.xpm">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="images/text32.xpm">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="images/plot16.xpm">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="images/plot32.xpm">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="images/vector16.xpm">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="images/vector32.xpm">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="manifest.xml">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="wxmathplot/mathplot.cpp">
+			<Option target="MathPlot" />
+		</Unit>
+		<Unit filename="wxmathplot/mathplot.h">
+			<Option target="MathPlot" />
+		</Unit>
+		<Unit filename="wxsAxis.cpp">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="wxsAxis.h">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="wxsText.cpp">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="wxsText.h">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="wxsMathPlot.cpp">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="wxsMathPlot.h">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="wxsSmithPlot.cpp">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="wxsSmithPlot.h">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="wxsVector.cpp">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="wxsVector.h">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Extensions>
+			<code_completion />
+			<envvars />
+			<debugger />
+		</Extensions>
+	</Project>
+</CodeBlocks_project_file>
Index: src/plugins/contrib/wxSmithPlot/wxsSmithPlot.cbp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsSmithPlot.cbp b/trunk/src/plugins/contrib/wxSmithPlot/wxsSmithPlot.cbp
--- a/trunk/src/plugins/contrib/wxSmithPlot/wxsSmithPlot.cbp	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsSmithPlot.cbp	(copie de travail)
@@ -8,7 +8,7 @@
 		<Build>
 			<Target title="MathPlot">
 				<Option output="..\..\..\devel\libMathPlot" prefix_auto="1" extension_auto="1" />
-				<Option working_dir="" />
+				<Option working_dir="wxmathplot\" />
 				<Option object_output="..\..\..\.objs\plugins\contrib\wxSmithPlot\MathPlot" />
 				<Option type="2" />
 				<Option compiler="gcc" />
@@ -72,6 +72,7 @@
 			<Add directory="$(#wx.include)" />
 			<Add directory="$(#wx.lib)\gcc_dll$(WX_CFG)\msw$(WX_SUFFIX)" />
 			<Add directory="." />
+			<Add directory="wxmathplot\" />
 		</Compiler>
 		<Linker>
 			<Add option="-Wl,--enable-auto-image-base" />
@@ -86,12 +87,18 @@
 		<Unit filename="images\axis32.xpm">
 			<Option target="wxSmithPlot" />
 		</Unit>
-		<Unit filename="images\marker16.xpm">
+		<Unit filename="images\text16.xpm">
 			<Option target="wxSmithPlot" />
 		</Unit>
 		<Unit filename="images\marker32.xpm">
 			<Option target="wxSmithPlot" />
 		</Unit>
+		<Unit filename="images\marker16.xpm">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="images\text32.xpm">
+			<Option target="wxSmithPlot" />
+		</Unit>
 		<Unit filename="images\plot16.xpm">
 			<Option target="wxSmithPlot" />
 		</Unit>
@@ -107,18 +114,12 @@
 		<Unit filename="manifest.xml">
 			<Option target="wxSmithPlot" />
 		</Unit>
-		<Unit filename="mathplot.cpp">
+		<Unit filename="wxmathplot\mathplot.cpp">
 			<Option target="MathPlot" />
 		</Unit>
-		<Unit filename="mathplot.h">
+		<Unit filename="wxmathplot\mathplot.h">
 			<Option target="MathPlot" />
 		</Unit>
-		<Unit filename="mpMarker.cpp">
-			<Option target="MathPlot" />
-		</Unit>
-		<Unit filename="mpMarker.h">
-			<Option target="MathPlot" />
-		</Unit>
 		<Unit filename="wxsAxis.cpp">
 			<Option target="wxSmithPlot" />
 		</Unit>
@@ -131,6 +132,12 @@
 		<Unit filename="wxsMarker.h">
 			<Option target="wxSmithPlot" />
 		</Unit>
+		<Unit filename="wxsText.cpp">
+			<Option target="wxSmithPlot" />
+		</Unit>
+		<Unit filename="wxsText.h">
+			<Option target="wxSmithPlot" />
+		</Unit>
 		<Unit filename="wxsMathPlot.cpp">
 			<Option target="wxSmithPlot" />
 		</Unit>
Index: src/plugins/contrib/wxSmithPlot/wxsText.cpp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsText.cpp b/trunk/src/plugins/contrib/wxSmithPlot/wxsText.cpp
new file mode 10644
--- /dev/null	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsText.cpp	(copie de travail)
@@ -0,0 +1,232 @@
+/*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2006-2007  Bartlomiej Swiecki
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+*/
+
+#include "wxsText.h"
+#include <wxwidgets/wxsitemresdata.h>
+
+//------------------------------------------------------------------------------
+
+namespace
+{
+
+// Loading images from xpm files
+
+    #include "images/text16.xpm"
+    #include "images/text32.xpm"
+
+    wxsRegisterItem<wxsText> Reg(
+        _T("mpText"),                 // Class name
+        wxsTWidget,                     // Item type
+        _T("wxWindows"),                // License
+        _T("Ron Collins"),              // Author
+        _T("rcoll@theriver.com"),       // Author's email
+        _T(""),                         // Item's homepage
+        _T("MathPlot"),                 // Category in palette
+        60,                             // Priority in palette
+        _T("Marker"),                   // Base part of names for new items
+        wxsCPP,                         // List of coding languages supported by this item
+        1, 0,                           // Version
+        wxBitmap(text32_xpm),         // 32x32 bitmap
+        wxBitmap(text16_xpm),         // 16x16 bitmap
+        false);                         // We do not allow this item inside XRC files
+
+
+    WXS_ST_BEGIN(wxsTextStyles,_T(""))
+        WXS_ST_CATEGORY("mpText")
+        WXS_ST(wxST_NO_AUTORESIZE)
+        WXS_ST(wxALIGN_LEFT)
+        WXS_ST(wxALIGN_RIGHT)
+        WXS_ST(wxALIGN_CENTRE)
+        WXS_ST_DEFAULTS()
+    WXS_ST_END()
+
+    WXS_EV_BEGIN(wxsTextEvents)
+    WXS_EV_END()
+
+}
+
+//------------------------------------------------------------------------------
+
+wxsText::wxsText(wxsItemResData* Data):
+    wxsWidget(
+        Data,
+        &Reg.Info,
+        wxsTextEvents,
+        wxsTextStyles)
+{
+    mLabel = _("*");
+    mXpos  = _("0.0");
+    mYpos  = _("0.0");
+}
+
+//------------------------------------------------------------------------------
+//
+// need to set line color and style
+
+void wxsText::OnBuildCreatingCode() {
+wxString    vname;
+wxString    pname;
+wxString    cname;
+wxString    fname;
+wxString    xname;
+wxString    yname;
+wxString    dtext;
+wxString    s;
+
+// we only know C++ language
+
+    if (GetLanguage() != wxsCPP) wxsCodeMarks::Unknown(_T("wxsText::OnBuildCreatingCode"),GetLanguage());
+
+// usefull names
+
+    vname = GetVarName();
+    pname = GetParent()->GetVarName();
+    cname = vname + _("_PEN");
+    fname = vname + _("_FONT");
+
+// the header for mathplot
+
+    AddHeader(_T("<mathplot.h>"),GetInfo().ClassName,hfInPCH);
+
+// create the vector -- but not the setup code
+
+    Codef(_T("%s = new mpText(%t, %s, %s);\n"), vname.wx_str(), mLabel.wx_str(), mXpos.wx_str(), mYpos.wx_str());
+//  BuildSetupWindowCode();
+
+// assign a pen to the layer
+
+    dtext = mPenColour.BuildCode(GetCoderContext());
+    if (dtext.Len() > 0) {
+        Codef(_T("wxPen   %s(%s);\n"), cname.wx_str(), dtext.wx_str());
+        Codef(_T("%s->SetPen(%s);\n"), vname.wx_str(), cname.wx_str());
+    };
+
+// assign a font to the layer
+
+    dtext = mPenFont.BuildFontCode(fname, GetCoderContext());
+    if (dtext.Len() > 0) {
+        Codef(_T("%s"), dtext.wx_str());
+        Codef(_T("%s->SetFont(%s);\n"), vname.wx_str(), fname.wx_str());
+    };
+
+// add to parent window -- should be a mpWindow
+
+    if ((GetPropertiesFlags() & flHidden) && GetBaseProps()->m_Hidden)
+        ; // do nothing
+    else
+        Codef(_T("%s->AddLayer(%s);\n"), pname.wx_str(), vname.wx_str());
+
+
+}
+
+//------------------------------------------------------------------------------
+
+wxObject* wxsText::OnBuildPreview(wxWindow* Parent, long Flags) {
+wxStaticText    *Preview;
+mpText        *mk;
+mpWindow        *mp;
+wxPen           pen;
+wxColour        cc;
+wxFont          ff;
+bool            hide;
+double          xp, yp;
+
+// if parent is not an mpWindow, then exit out
+
+    if (! Parent->IsKindOf(CLASSINFO(mpWindow))) return NULL;
+    mp = (mpWindow *) Parent;
+
+// hide this marker
+
+    hide = ((Flags & pfExact) && (GetPropertiesFlags() & flHidden) && GetBaseProps()->m_Hidden);
+
+// make the place-holder
+
+    Preview = new wxStaticText(Parent, GetId(), mLabel, Pos(Parent), Size(Parent), (wxSUNKEN_BORDER|Style()));
+    Preview->SetForegroundColour(wxColour(255,255,255));
+    Preview->SetBackgroundColour(wxColour(0,128,0));
+    SetupWindow(Preview,Flags);
+    if (Flags & pfExact) Preview->Hide();
+
+// pen color
+
+    cc = mPenColour.GetColour();
+    if (cc.IsOk()) pen.SetColour(cc);
+
+// text font
+
+    ff = mPenFont.BuildFont();
+
+// update the place-holder
+
+    if (cc.IsOk()) Preview->SetBackgroundColour(cc);
+    Preview->SetFont(ff);
+
+// X & Y position
+
+    if (! mXpos.ToDouble(&xp)) {
+        xp = 0.0;
+        mXpos = _("0.0");
+    };
+    if (! mYpos.ToDouble(&yp)) {
+        yp = 0.0;
+        mYpos = _("0.0");
+    };
+
+// the actual marker
+
+    mk = new mpText(mLabel, xp, yp);
+    mk->SetPen(pen);
+    mk->SetFont(ff);
+
+// and add layer to parent
+
+    if (! hide) mp->AddLayer(mk);
+
+// done
+
+    return Preview;
+}
+
+//------------------------------------------------------------------------------
+// declare the var as a simple wxPanel
+
+void wxsText::OnBuildDeclarationsCode() {
+
+    if (GetLanguage() == wxsCPP) {
+        AddDeclaration(_T("mpText   *") + GetVarName() + _T(";"));
+    }
+    else {
+        wxsCodeMarks::Unknown(_T("wxsText::OnBuildDeclarationsCode"),GetLanguage());
+    };
+}
+
+
+
+
+//------------------------------------------------------------------------------
+
+void wxsText::OnEnumWidgetProperties(long Flags) {
+
+    WXS_SHORT_STRING(wxsText, mLabel,      _("Marker Text"),     _("mLabelText"),  _("*"), true);
+    WXS_SHORT_STRING(wxsText, mXpos,       _("X Position"),      _("mXpos"),       _("0.0"), true);
+    WXS_SHORT_STRING(wxsText, mYpos,       _("Y Position"),      _("mYpos"),       _("0.0"), true);
+    WXS_COLOUR(      wxsText, mPenColour,  _("Pen Colour"),      _("mPenColour"));
+    WXS_FONT(        wxsText, mPenFont,    _("Pen Font"),        _("mPenFont"));
+}
Index: src/plugins/contrib/wxSmithPlot/wxsText.h
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsText.h b/trunk/src/plugins/contrib/wxSmithPlot/wxsText.h
new file mode 10644
--- /dev/null	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsText.h	(copie de travail)
@@ -0,0 +1,49 @@
+/*
+* This file is part of wxSmith plugin for Code::Blocks Studio
+* Copyright (C) 2006-2007  Bartlomiej Swiecki
+*
+* wxSmith is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 3 of the License, or
+* (at your option) any later version.
+*
+* wxSmith is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with wxSmith. If not, see <http://www.gnu.org/licenses/>.
+*
+*/
+
+#ifndef WXSTEXT_H
+#define WXSTEXT_H
+
+#include    <iostream>
+
+#include    <wx/stattext.h>
+#include    <wxwidgets/wxswidget.h>
+#include    <mathplot.h>
+
+
+class wxsText: public wxsWidget
+{
+    public:
+
+        wxsText(wxsItemResData* Data);
+
+    private:
+
+        virtual void        OnBuildCreatingCode();
+        virtual wxObject*   OnBuildPreview(wxWindow* Parent, long Flags);
+        virtual void        OnBuildDeclarationsCode();
+        virtual void        OnEnumWidgetProperties(long Flags);
+
+        wxString            mLabel;
+        wxString            mXpos, mYpos;
+        wxsColourData       mPenColour;     // color to draw
+        wxsFontData         mPenFont;       // for drawing the text
+};
+
+#endif      // WXSTEXT_H
Index: src/plugins/contrib/wxSmithPlot/wxsVector.cpp
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsVector.cpp b/trunk/src/plugins/contrib/wxSmithPlot/wxsVector.cpp
--- a/trunk/src/plugins/contrib/wxSmithPlot/wxsVector.cpp	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsVector.cpp	(copie de travail)
@@ -18,7 +18,7 @@
 */
 
 #include "wxsVector.h"
-#include "../wxsitemresdata.h"
+#include <wxwidgets/wxsitemresdata.h>
 
 //------------------------------------------------------------------------------
 
@@ -27,8 +27,8 @@
 
 // Loading images from xpm files
 
-    #include "vector16.xpm"
-    #include "vector32.xpm"
+    #include "images/vector16.xpm"
+    #include "images/vector32.xpm"
 
     wxsRegisterItem<wxsVector> Reg(
         _T("mpVector"),                 // Class name
@@ -119,7 +119,7 @@
 
 // create the vector -- but not the setup code
 
-    Codef(_T("%s = new mpFXYVector(_(\"%s\"), %d);\n"), vname.c_str(), mLabel.c_str(), mAlign);
+    Codef(_T("%s = new mpFXYVector(_(\"%s\"), %d);\n"), vname.wx_str(), mLabel.wx_str(), mAlign);
 //  BuildSetupWindowCode();
 
 // assign a pen to the layer
@@ -126,8 +126,8 @@
 
     dtext = mPenColour.BuildCode(GetCoderContext());
     if (dtext.Len() > 0) {
-        Codef(_T("wxPen   %s(%s);\n"), cname.c_str(), dtext.c_str());
-        Codef(_T("%s->SetPen(%s);\n"), vname.c_str(), cname.c_str());
+        Codef(_T("wxPen   %s(%s);\n"), cname.wx_str(), dtext.wx_str());
+        Codef(_T("%s->SetPen(%s);\n"), vname.wx_str(), cname.wx_str());
     };
 
 // assign a font to the layer
@@ -134,15 +134,15 @@
 
     dtext = mPenFont.BuildFontCode(fname, GetCoderContext());
     if (dtext.Len() > 0) {
-        Codef(_T("%s"), dtext.c_str());
-        Codef(_T("%s->SetFont(%s);\n"), vname.c_str(), fname.c_str());
+        Codef(_T("%s"), dtext.wx_str());
+        Codef(_T("%s->SetFont(%s);\n"), vname.wx_str(), fname.wx_str());
     };
 
 // define the arrays
 
-    dtext = _("std::vector<float>  ") + xname + _(";");
+    dtext = _("std::vector<double>  ") + xname + _(";");
     AddDeclaration(dtext);
-    dtext = _("std::vector<float>  ") + yname + _(";");
+    dtext = _("std::vector<double>  ") + yname + _(";");
     AddDeclaration(dtext);
 
 // assign the data
@@ -151,11 +151,11 @@
     n = mXs.GetCount();
     if (n > 0) {
         for(i=0; i<n; i++) {
-            Codef(_T("%s.push_back(%s);   %s.push_back(%s);\n"), xname.c_str(), mXs[i].c_str(),
-                                                                 yname.c_str(), mYs[i].c_str());
+            Codef(_T("%s.push_back(%s);   %s.push_back(%s);\n"), xname.wx_str(), mXs[i].wx_str(),
+                                                                 yname.wx_str(), mYs[i].wx_str());
         };
 
-        Codef(_T("%ASetData(%s, %s);\n"), xname.c_str(), yname.c_str());
+        Codef(_T("%ASetData(%s, %s);\n"), xname.wx_str(), yname.wx_str());
     };
 
 // draw as points or a continuous line
@@ -165,13 +165,13 @@
 // add to parent window -- should be a mpWindow
 
     if ((GetPropertiesFlags() & flHidden) && GetBaseProps()->m_Hidden) n = 0;        // do nothing
-    else Codef(_T("%s->AddLayer(%s);\n"), pname.c_str(), vname.c_str());
+    else Codef(_T("%s->AddLayer(%s);\n"), pname.wx_str(), vname.wx_str());
 
 
 }
 
 //------------------------------------------------------------------------------
-// parse the mXYData into strings and floats
+// parse the mXYData into strings and doubles
 
 void    wxsVector::ParseXY(void) {
 int         i,n;
@@ -215,7 +215,7 @@
         t.Trim(false);
         t.ToDouble(&d);
         mXs.Add(t);
-        mXf.push_back((float) d);
+        mXf.push_back(d);
 
 // the second number
 
@@ -224,7 +224,7 @@
         t.Trim(false);
         t.ToDouble(&d);
         mYs.Add(t);
-        mYf.push_back((float) d);
+        mYf.push_back(d);
     };
 
 // there is a problem with mpFXYVector getting the count of items wrong,
@@ -238,9 +238,9 @@
         mYs.Add(s);
 
         d = mXf[n-1];
-        mXf.push_back((float) d);
+        mXf.push_back(d);
         d = mYf[n-1];
-        mYf.push_back((float) d);
+        mYf.push_back(d);
     };
 }
 
Index: src/plugins/contrib/wxSmithPlot/wxsVector.h
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsVector.h b/trunk/src/plugins/contrib/wxSmithPlot/wxsVector.h
--- a/trunk/src/plugins/contrib/wxSmithPlot/wxsVector.h	(révision 10042)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsVector.h	(copie de travail)
@@ -23,7 +23,7 @@
 #include    <iostream>
 
 #include    <wx/stattext.h>
-#include    "../wxswidget.h"
+#include    <wxwidgets/wxswidget.h>
 #include    <mathplot.h>
 
 
@@ -53,8 +53,8 @@
 
         wxArrayString       mXs;            // internal use; X data as a string
         wxArrayString       mYs;            // Y data as a string
-        std::vector<float>  mXf;            // X data as a float value
-        std::vector<float>  mYf;            // Y data as a float
+        std::vector<double>  mXf;            // X data as a double value
+        std::vector<double>  mYf;            // Y data as a double
 
 };
 
Index: src/plugins/contrib/wxSmithPlot/wxsmithplot.pc.in
===================================================================
diff --git a/trunk/src/plugins/contrib/wxSmithPlot/wxsmithplot.pc.in b/trunk/src/plugins/contrib/wxSmithPlot/wxsmithplot.pc.in
new file mode 10644
--- /dev/null	(révision 0)
+++ b/trunk/src/plugins/contrib/wxSmithPlot/wxsmithplot.pc.in	(copie de travail)
@@ -0,0 +1,12 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@/wxSmithPlot
+includedir=@includedir@/wxSmithPlot
+datarootdir = @datarootdir@
+sharedir=@datadir@
+
+Name: wxSmithPlot
+Description: wxMathPlot support for wxSmith
+Version: @VERSION@
+Libs: -L${libdir} -lwxsmithlib
+Cflags: -fPIC -I${includedir}
